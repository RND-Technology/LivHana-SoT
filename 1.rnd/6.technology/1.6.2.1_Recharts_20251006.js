import {
  clsx,
  require_react_is
} from "./chunk-4MHI5WMA.js";
import {
  require_react_dom
} from "./chunk-WRD5HZVH.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js
const require_isUnsafeProperty = __commonJS({
  "node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isUnsafeProperty2(key) {
      return key === "__proto__";
    }
    exports.isUnsafeProperty = isUnsafeProperty2;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js
const require_isDeepKey = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isDeepKey(key) {
      switch (typeof key) {
        case "number":
        case "symbol": {
          return false;
        }
        case "string": {
          return key.includes(".") || key.includes("[") || key.includes("]");
        }
      }
    }
    exports.isDeepKey = isDeepKey;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/toKey.js
const require_toKey = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/toKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toKey(value) {
      let _a;
      if (typeof value === "string" || typeof value === "symbol") {
        return value;
      }
      if (Object.is((_a = value == null ? void 0 : value.valueOf) == null ? void 0 : _a.call(value), -0)) {
        return "-0";
      }
      return String(value);
    }
    exports.toKey = toKey;
  }
});

// node_modules/es-toolkit/dist/compat/util/toPath.js
const require_toPath = __commonJS({
  "node_modules/es-toolkit/dist/compat/util/toPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toPath(deepKey) {
      const result = [];
      const length = deepKey.length;
      if (length === 0) {
        return result;
      }
      let index2 = 0;
      let key = "";
      let quoteChar = "";
      let bracket = false;
      if (deepKey.charCodeAt(0) === 46) {
        result.push("");
        index2++;
      }
      while (index2 < length) {
        const char = deepKey[index2];
        if (quoteChar) {
          if (char === "\\" && index2 + 1 < length) {
            index2++;
            key += deepKey[index2];
          } else if (char === quoteChar) {
            quoteChar = "";
          } else {
            key += char;
          }
        } else if (bracket) {
          if (char === '"' || char === "'") {
            quoteChar = char;
          } else if (char === "]") {
            bracket = false;
            result.push(key);
            key = "";
          } else {
            key += char;
          }
        } else {
          if (char === "[") {
            bracket = true;
            if (key) {
              result.push(key);
              key = "";
            }
          } else if (char === ".") {
            if (key) {
              result.push(key);
              key = "";
            }
          } else {
            key += char;
          }
        }
        index2++;
      }
      if (key) {
        result.push(key);
      }
      return result;
    }
    exports.toPath = toPath;
  }
});

// node_modules/es-toolkit/dist/compat/object/get.js
const require_get = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/get.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isUnsafeProperty2 = require_isUnsafeProperty();
    const isDeepKey = require_isDeepKey();
    const toKey = require_toKey();
    const toPath = require_toPath();
    function get9(object, path2, defaultValue) {
      if (object == null) {
        return defaultValue;
      }
      switch (typeof path2) {
        case "string": {
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object[path2];
          if (result === void 0) {
            if (isDeepKey.isDeepKey(path2)) {
              return get9(object, toPath.toPath(path2), defaultValue);
            } else {
              return defaultValue;
            }
          }
          return result;
        }
        case "number":
        case "symbol": {
          if (typeof path2 === "number") {
            path2 = toKey.toKey(path2);
          }
          const result = object[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
        default: {
          if (Array.isArray(path2)) {
            return getWithPath(object, path2, defaultValue);
          }
          if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
            path2 = "-0";
          } else {
            path2 = String(path2);
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return defaultValue;
          }
          const result = object[path2];
          if (result === void 0) {
            return defaultValue;
          }
          return result;
        }
      }
    }
    function getWithPath(object, path2, defaultValue) {
      if (path2.length === 0) {
        return defaultValue;
      }
      let current2 = object;
      for (let index2 = 0; index2 < path2.length; index2++) {
        if (current2 == null) {
          return defaultValue;
        }
        if (isUnsafeProperty2.isUnsafeProperty(path2[index2])) {
          return defaultValue;
        }
        current2 = current2[path2[index2]];
      }
      if (current2 === void 0) {
        return defaultValue;
      }
      return current2;
    }
    exports.get = get9;
  }
});

// node_modules/es-toolkit/compat/get.js
const require_get2 = __commonJS({
  "node_modules/es-toolkit/compat/get.js"(exports, module) {
    module.exports = require_get().get;
  }
});

// node_modules/es-toolkit/dist/array/uniqBy.js
const require_uniqBy = __commonJS({
  "node_modules/es-toolkit/dist/array/uniqBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function uniqBy3(arr, mapper) {
      const map5 = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = mapper(item);
        if (!map5.has(key)) {
          map5.set(key, item);
        }
      }
      return Array.from(map5.values());
    }
    exports.uniqBy = uniqBy3;
  }
});

// node_modules/es-toolkit/dist/function/identity.js
const require_identity = __commonJS({
  "node_modules/es-toolkit/dist/function/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function identity7(x2) {
      return x2;
    }
    exports.identity = identity7;
  }
});

// node_modules/es-toolkit/dist/predicate/isLength.js
const require_isLength = __commonJS({
  "node_modules/es-toolkit/dist/predicate/isLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isLength2(value) {
      return Number.isSafeInteger(value) && value >= 0;
    }
    exports.isLength = isLength2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js
const require_isArrayLike = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isLength2 = require_isLength();
    function isArrayLike(value) {
      return value != null && typeof value !== "function" && isLength2.isLength(value.length);
    }
    exports.isArrayLike = isArrayLike;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js
const require_isObjectLike = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isObjectLike2(value) {
      return typeof value === "object" && value !== null;
    }
    exports.isObjectLike = isObjectLike2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js
const require_isArrayLikeObject = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isArrayLike = require_isArrayLike();
    const isObjectLike2 = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike2.isObjectLike(value) && isArrayLike.isArrayLike(value);
    }
    exports.isArrayLikeObject = isArrayLikeObject;
  }
});

// node_modules/es-toolkit/dist/compat/object/property.js
const require_property = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/property.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const get9 = require_get();
    function property(path2) {
      return function(object) {
        return get9.get(object, path2);
      };
    }
    exports.property = property;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isObject.js
const require_isObject = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isObject(value) {
      return value !== null && (typeof value === "object" || typeof value === "function");
    }
    exports.isObject = isObject;
  }
});

// node_modules/es-toolkit/dist/predicate/isPrimitive.js
const require_isPrimitive = __commonJS({
  "node_modules/es-toolkit/dist/predicate/isPrimitive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isPrimitive2(value) {
      return value == null || typeof value !== "object" && typeof value !== "function";
    }
    exports.isPrimitive = isPrimitive2;
  }
});

// node_modules/es-toolkit/dist/compat/util/eq.js
const require_eq = __commonJS({
  "node_modules/es-toolkit/dist/compat/util/eq.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function eq2(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    exports.eq = eq2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js
const require_isMatchWith = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatch = require_isMatch();
    const isObject = require_isObject();
    const isPrimitive2 = require_isPrimitive();
    const eq2 = require_eq();
    function isMatchWith(target, source, compare) {
      if (typeof compare !== "function") {
        return isMatch.isMatch(target, source);
      }
      return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object, source2, stack) {
        const isEqual2 = compare(objValue, srcValue, key, object, source2, stack);
        if (isEqual2 !== void 0) {
          return Boolean(isEqual2);
        }
        return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
      }, /* @__PURE__ */ new Map());
    }
    function isMatchWithInternal(target, source, compare, stack) {
      if (source === target) {
        return true;
      }
      switch (typeof source) {
        case "object": {
          return isObjectMatch(target, source, compare, stack);
        }
        case "function": {
          const sourceKeys = Object.keys(source);
          if (sourceKeys.length > 0) {
            return isMatchWithInternal(target, { ...source }, compare, stack);
          }
          return eq2.eq(target, source);
        }
        default: {
          if (!isObject.isObject(target)) {
            return eq2.eq(target, source);
          }
          if (typeof source === "string") {
            return source === "";
          }
          return true;
        }
      }
    }
    function isObjectMatch(target, source, compare, stack) {
      if (source == null) {
        return true;
      }
      if (Array.isArray(source)) {
        return isArrayMatch(target, source, compare, stack);
      }
      if (source instanceof Map) {
        return isMapMatch(target, source, compare, stack);
      }
      if (source instanceof Set) {
        return isSetMatch(target, source, compare, stack);
      }
      const keys = Object.keys(source);
      if (target == null) {
        return keys.length === 0;
      }
      if (keys.length === 0) {
        return true;
      }
      if (stack && stack.has(source)) {
        return stack.get(source) === target;
      }
      if (stack) {
        stack.set(source, target);
      }
      try {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (!isPrimitive2.isPrimitive(target) && !(key in target)) {
            return false;
          }
          if (source[key] === void 0 && target[key] !== void 0) {
            return false;
          }
          if (source[key] === null && target[key] !== null) {
            return false;
          }
          const isEqual2 = compare(target[key], source[key], key, target, source, stack);
          if (!isEqual2) {
            return false;
          }
        }
        return true;
      } finally {
        if (stack) {
          stack.delete(source);
        }
      }
    }
    function isMapMatch(target, source, compare, stack) {
      if (source.size === 0) {
        return true;
      }
      if (!(target instanceof Map)) {
        return false;
      }
      for (const [key, sourceValue] of source.entries()) {
        const targetValue = target.get(key);
        const isEqual2 = compare(targetValue, sourceValue, key, target, source, stack);
        if (isEqual2 === false) {
          return false;
        }
      }
      return true;
    }
    function isArrayMatch(target, source, compare, stack) {
      if (source.length === 0) {
        return true;
      }
      if (!Array.isArray(target)) {
        return false;
      }
      const countedIndex = /* @__PURE__ */ new Set();
      for (let i = 0; i < source.length; i++) {
        const sourceItem = source[i];
        let found = false;
        for (let j = 0; j < target.length; j++) {
          if (countedIndex.has(j)) {
            continue;
          }
          const targetItem = target[j];
          let matches2 = false;
          const isEqual2 = compare(targetItem, sourceItem, i, target, source, stack);
          if (isEqual2) {
            matches2 = true;
          }
          if (matches2) {
            countedIndex.add(j);
            found = true;
            break;
          }
        }
        if (!found) {
          return false;
        }
      }
      return true;
    }
    function isSetMatch(target, source, compare, stack) {
      if (source.size === 0) {
        return true;
      }
      if (!(target instanceof Set)) {
        return false;
      }
      return isArrayMatch([...target], [...source], compare, stack);
    }
    exports.isMatchWith = isMatchWith;
    exports.isSetMatch = isSetMatch;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isMatch.js
var require_isMatch = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isMatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatchWith = require_isMatchWith();
    function isMatch(target, source) {
      return isMatchWith.isMatchWith(target, source, () => void 0);
    }
    exports.isMatch = isMatch;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/getSymbols.js
const require_getSymbols = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/getSymbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getSymbols2(object) {
      return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
    }
    exports.getSymbols = getSymbols2;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/getTag.js
const require_getTag = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/getTag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getTag2(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    exports.getTag = getTag2;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/tags.js
const require_tags = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/tags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const regexpTag2 = "[object RegExp]";
    const stringTag2 = "[object String]";
    const numberTag2 = "[object Number]";
    const booleanTag2 = "[object Boolean]";
    const argumentsTag2 = "[object Arguments]";
    const symbolTag2 = "[object Symbol]";
    const dateTag2 = "[object Date]";
    const mapTag2 = "[object Map]";
    const setTag2 = "[object Set]";
    const arrayTag2 = "[object Array]";
    const functionTag2 = "[object Function]";
    const arrayBufferTag2 = "[object ArrayBuffer]";
    const objectTag2 = "[object Object]";
    const errorTag2 = "[object Error]";
    const dataViewTag2 = "[object DataView]";
    const uint8ArrayTag2 = "[object Uint8Array]";
    const uint8ClampedArrayTag2 = "[object Uint8ClampedArray]";
    const uint16ArrayTag2 = "[object Uint16Array]";
    const uint32ArrayTag2 = "[object Uint32Array]";
    const bigUint64ArrayTag2 = "[object BigUint64Array]";
    const int8ArrayTag2 = "[object Int8Array]";
    const int16ArrayTag2 = "[object Int16Array]";
    const int32ArrayTag2 = "[object Int32Array]";
    const bigInt64ArrayTag2 = "[object BigInt64Array]";
    const float32ArrayTag2 = "[object Float32Array]";
    const float64ArrayTag2 = "[object Float64Array]";
    exports.argumentsTag = argumentsTag2;
    exports.arrayBufferTag = arrayBufferTag2;
    exports.arrayTag = arrayTag2;
    exports.bigInt64ArrayTag = bigInt64ArrayTag2;
    exports.bigUint64ArrayTag = bigUint64ArrayTag2;
    exports.booleanTag = booleanTag2;
    exports.dataViewTag = dataViewTag2;
    exports.dateTag = dateTag2;
    exports.errorTag = errorTag2;
    exports.float32ArrayTag = float32ArrayTag2;
    exports.float64ArrayTag = float64ArrayTag2;
    exports.functionTag = functionTag2;
    exports.int16ArrayTag = int16ArrayTag2;
    exports.int32ArrayTag = int32ArrayTag2;
    exports.int8ArrayTag = int8ArrayTag2;
    exports.mapTag = mapTag2;
    exports.numberTag = numberTag2;
    exports.objectTag = objectTag2;
    exports.regexpTag = regexpTag2;
    exports.setTag = setTag2;
    exports.stringTag = stringTag2;
    exports.symbolTag = symbolTag2;
    exports.uint16ArrayTag = uint16ArrayTag2;
    exports.uint32ArrayTag = uint32ArrayTag2;
    exports.uint8ArrayTag = uint8ArrayTag2;
    exports.uint8ClampedArrayTag = uint8ClampedArrayTag2;
  }
});

// node_modules/es-toolkit/dist/predicate/isTypedArray.js
const require_isTypedArray = __commonJS({
  "node_modules/es-toolkit/dist/predicate/isTypedArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isTypedArray2(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    exports.isTypedArray = isTypedArray2;
  }
});

// node_modules/es-toolkit/dist/object/cloneDeepWith.js
const require_cloneDeepWith = __commonJS({
  "node_modules/es-toolkit/dist/object/cloneDeepWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const getSymbols2 = require_getSymbols();
    const getTag2 = require_getTag();
    const tags = require_tags();
    const isPrimitive2 = require_isPrimitive();
    const isTypedArray2 = require_isTypedArray();
    function cloneDeepWith2(obj, cloneValue) {
      return cloneDeepWithImpl2(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
    }
    function cloneDeepWithImpl2(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
      const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack);
      if (cloned !== void 0) {
        return cloned;
      }
      if (isPrimitive2.isPrimitive(valueToClone)) {
        return valueToClone;
      }
      if (stack.has(valueToClone)) {
        return stack.get(valueToClone);
      }
      if (Array.isArray(valueToClone)) {
        const result = new Array(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl2(valueToClone[i], i, objectToClone, stack, cloneValue);
        }
        if (Object.hasOwn(valueToClone, "index")) {
          result.index = valueToClone.index;
        }
        if (Object.hasOwn(valueToClone, "input")) {
          result.input = valueToClone.input;
        }
        return result;
      }
      if (valueToClone instanceof Date) {
        return new Date(valueToClone.getTime());
      }
      if (valueToClone instanceof RegExp) {
        const result = new RegExp(valueToClone.source, valueToClone.flags);
        result.lastIndex = valueToClone.lastIndex;
        return result;
      }
      if (valueToClone instanceof Map) {
        const result = /* @__PURE__ */ new Map();
        stack.set(valueToClone, result);
        for (const [key, value] of valueToClone) {
          result.set(key, cloneDeepWithImpl2(value, key, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (valueToClone instanceof Set) {
        const result = /* @__PURE__ */ new Set();
        stack.set(valueToClone, result);
        for (const value of valueToClone) {
          result.add(cloneDeepWithImpl2(value, void 0, objectToClone, stack, cloneValue));
        }
        return result;
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
        return valueToClone.subarray();
      }
      if (isTypedArray2.isTypedArray(valueToClone)) {
        const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
        stack.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl2(valueToClone[i], i, objectToClone, stack, cloneValue);
        }
        return result;
      }
      if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
        return valueToClone.slice(0);
      }
      if (valueToClone instanceof DataView) {
        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof File !== "undefined" && valueToClone instanceof File) {
        const result = new File([valueToClone], valueToClone.name, {
          type: valueToClone.type
        });
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Blob) {
        const result = new Blob([valueToClone], { type: valueToClone.type });
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (valueToClone instanceof Error) {
        const result = new valueToClone.constructor();
        stack.set(valueToClone, result);
        result.message = valueToClone.message;
        result.name = valueToClone.name;
        result.stack = valueToClone.stack;
        result.cause = valueToClone.cause;
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
        const result = Object.create(Object.getPrototypeOf(valueToClone));
        stack.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
        return result;
      }
      return valueToClone;
    }
    function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
      const keys = [...Object.keys(source), ...getSymbols2.getSymbols(source)];
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor == null || descriptor.writable) {
          target[key] = cloneDeepWithImpl2(source[key], key, objectToClone, stack, cloneValue);
        }
      }
    }
    function isCloneableObject(object) {
      switch (getTag2.getTag(object)) {
        case tags.argumentsTag:
        case tags.arrayTag:
        case tags.arrayBufferTag:
        case tags.dataViewTag:
        case tags.booleanTag:
        case tags.dateTag:
        case tags.float32ArrayTag:
        case tags.float64ArrayTag:
        case tags.int8ArrayTag:
        case tags.int16ArrayTag:
        case tags.int32ArrayTag:
        case tags.mapTag:
        case tags.numberTag:
        case tags.objectTag:
        case tags.regexpTag:
        case tags.setTag:
        case tags.stringTag:
        case tags.symbolTag:
        case tags.uint8ArrayTag:
        case tags.uint8ClampedArrayTag:
        case tags.uint16ArrayTag:
        case tags.uint32ArrayTag: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    exports.cloneDeepWith = cloneDeepWith2;
    exports.cloneDeepWithImpl = cloneDeepWithImpl2;
    exports.copyProperties = copyProperties;
  }
});

// node_modules/es-toolkit/dist/object/cloneDeep.js
const require_cloneDeep = __commonJS({
  "node_modules/es-toolkit/dist/object/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = require_cloneDeepWith();
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
    }
    exports.cloneDeep = cloneDeep2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/matches.js
const require_matches = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/matches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatch = require_isMatch();
    const cloneDeep2 = require_cloneDeep();
    function matches2(source) {
      source = cloneDeep2.cloneDeep(source);
      return (target) => {
        return isMatch.isMatch(target, source);
      };
    }
    exports.matches = matches2;
  }
});

// node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js
const require_cloneDeepWith2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith$1 = require_cloneDeepWith();
    const tags = require_tags();
    function cloneDeepWith2(obj, customizer) {
      return cloneDeepWith$1.cloneDeepWith(obj, (value, key, object, stack) => {
        const cloned = customizer == null ? void 0 : customizer(value, key, object, stack);
        if (cloned !== void 0) {
          return cloned;
        }
        if (typeof obj !== "object") {
          return void 0;
        }
        switch (Object.prototype.toString.call(obj)) {
          case tags.numberTag:
          case tags.stringTag:
          case tags.booleanTag: {
            const result = new obj.constructor(obj == null ? void 0 : obj.valueOf());
            cloneDeepWith$1.copyProperties(result, obj);
            return result;
          }
          case tags.argumentsTag: {
            const result = {};
            cloneDeepWith$1.copyProperties(result, obj);
            result.length = obj.length;
            result[Symbol.iterator] = obj[Symbol.iterator];
            return result;
          }
          default: {
            return void 0;
          }
        }
      });
    }
    exports.cloneDeepWith = cloneDeepWith2;
  }
});

// node_modules/es-toolkit/dist/compat/object/cloneDeep.js
const require_cloneDeep2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/cloneDeep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const cloneDeepWith2 = require_cloneDeepWith2();
    function cloneDeep2(obj) {
      return cloneDeepWith2.cloneDeepWith(obj);
    }
    exports.cloneDeep = cloneDeep2;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isIndex.js
const require_isIndex = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/isIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length = Number.MAX_SAFE_INTEGER) {
      switch (typeof value) {
        case "number": {
          return Number.isInteger(value) && value >= 0 && value < length;
        }
        case "symbol": {
          return false;
        }
        case "string": {
          return IS_UNSIGNED_INTEGER.test(value);
        }
      }
    }
    exports.isIndex = isIndex;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isArguments.js
const require_isArguments = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isArguments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const getTag2 = require_getTag();
    function isArguments(value) {
      return value !== null && typeof value === "object" && getTag2.getTag(value) === "[object Arguments]";
    }
    exports.isArguments = isArguments;
  }
});

// node_modules/es-toolkit/dist/compat/object/has.js
const require_has = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/has.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isDeepKey = require_isDeepKey();
    const isIndex = require_isIndex();
    const isArguments = require_isArguments();
    const toPath = require_toPath();
    function has2(object, path2) {
      let resolvedPath;
      if (Array.isArray(path2)) {
        resolvedPath = path2;
      } else if (typeof path2 === "string" && isDeepKey.isDeepKey(path2) && (object == null ? void 0 : object[path2]) == null) {
        resolvedPath = toPath.toPath(path2);
      } else {
        resolvedPath = [path2];
      }
      if (resolvedPath.length === 0) {
        return false;
      }
      let current2 = object;
      for (let i = 0; i < resolvedPath.length; i++) {
        const key = resolvedPath[i];
        if (current2 == null || !Object.hasOwn(current2, key)) {
          const isSparseIndex = (Array.isArray(current2) || isArguments.isArguments(current2)) && isIndex.isIndex(key) && key < current2.length;
          if (!isSparseIndex) {
            return false;
          }
        }
        current2 = current2[key];
      }
      return true;
    }
    exports.has = has2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js
const require_matchesProperty = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isMatch = require_isMatch();
    const toKey = require_toKey();
    const cloneDeep2 = require_cloneDeep2();
    const get9 = require_get();
    const has2 = require_has();
    function matchesProperty(property, source) {
      switch (typeof property) {
        case "object": {
          if (Object.is(property == null ? void 0 : property.valueOf(), -0)) {
            property = "-0";
          }
          break;
        }
        case "number": {
          property = toKey.toKey(property);
          break;
        }
      }
      source = cloneDeep2.cloneDeep(source);
      return function(target) {
        const result = get9.get(target, property);
        if (result === void 0) {
          return has2.has(target, property);
        }
        if (source === void 0) {
          return result === void 0;
        }
        return isMatch.isMatch(result, source);
      };
    }
    exports.matchesProperty = matchesProperty;
  }
});

// node_modules/es-toolkit/dist/compat/util/iteratee.js
const require_iteratee = __commonJS({
  "node_modules/es-toolkit/dist/compat/util/iteratee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const identity7 = require_identity();
    const property = require_property();
    const matches2 = require_matches();
    const matchesProperty = require_matchesProperty();
    function iteratee(value) {
      if (value == null) {
        return identity7.identity;
      }
      switch (typeof value) {
        case "function": {
          return value;
        }
        case "object": {
          if (Array.isArray(value) && value.length === 2) {
            return matchesProperty.matchesProperty(value[0], value[1]);
          }
          return matches2.matches(value);
        }
        case "string":
        case "symbol":
        case "number": {
          return property.property(value);
        }
      }
    }
    exports.iteratee = iteratee;
  }
});

// node_modules/es-toolkit/dist/compat/array/uniqBy.js
const require_uniqBy2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/array/uniqBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const uniqBy$1 = require_uniqBy();
    const identity7 = require_identity();
    const isArrayLikeObject = require_isArrayLikeObject();
    const iteratee = require_iteratee();
    function uniqBy3(array2, iteratee$1 = identity7.identity) {
      if (!isArrayLikeObject.isArrayLikeObject(array2)) {
        return [];
      }
      return uniqBy$1.uniqBy(Array.from(array2), iteratee.iteratee(iteratee$1));
    }
    exports.uniqBy = uniqBy3;
  }
});

// node_modules/es-toolkit/compat/uniqBy.js
const require_uniqBy3 = __commonJS({
  "node_modules/es-toolkit/compat/uniqBy.js"(exports, module) {
    module.exports = require_uniqBy2().uniqBy;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
const require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React74.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        const value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState21({
          inst: { value, getSnapshot }
        });
        const inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect3(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect29(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        const latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          const nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React74 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState21 = React74.useState, useEffect29 = React74.useEffect, useLayoutEffect3 = React74.useLayoutEffect, useDebugValue2 = React74.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React74.useSyncExternalStore ? React74.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
const require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
const require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      const React74 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = shim.useSyncExternalStore, useRef21 = React74.useRef, useEffect29 = React74.useEffect, useMemo12 = React74.useMemo, useDebugValue2 = React74.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
        let instRef = useRef21(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo12(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual2 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              const nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual2]
        );
        const value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
        useEffect29(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
const require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/es-toolkit/dist/compat/_internal/compareValues.js
const require_compareValues = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/compareValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function getPriority(a2) {
      if (typeof a2 === "symbol") {
        return 1;
      }
      if (a2 === null) {
        return 2;
      }
      if (a2 === void 0) {
        return 3;
      }
      if (a2 !== a2) {
        return 4;
      }
      return 0;
    }
    const compareValues2 = (a2, b, order) => {
      if (a2 !== b) {
        const aPriority = getPriority(a2);
        const bPriority = getPriority(b);
        if (aPriority === bPriority && aPriority === 0) {
          if (a2 < b) {
            return order === "desc" ? 1 : -1;
          }
          if (a2 > b) {
            return order === "desc" ? -1 : 1;
          }
        }
        return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
      }
      return 0;
    };
    exports.compareValues = compareValues2;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isSymbol.js
const require_isSymbol = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isSymbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isSymbol3(value) {
      return typeof value === "symbol" || value instanceof Symbol;
    }
    exports.isSymbol = isSymbol3;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isKey.js
const require_isKey = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/isKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isSymbol3 = require_isSymbol();
    const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    const regexIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (Array.isArray(value)) {
        return false;
      }
      if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol3.isSymbol(value)) {
        return true;
      }
      return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
    }
    exports.isKey = isKey;
  }
});

// node_modules/es-toolkit/dist/compat/array/orderBy.js
const require_orderBy = __commonJS({
  "node_modules/es-toolkit/dist/compat/array/orderBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const compareValues2 = require_compareValues();
    const isKey = require_isKey();
    const toPath = require_toPath();
    function orderBy2(collection, criteria, orders, guard) {
      if (collection == null) {
        return [];
      }
      orders = guard ? void 0 : orders;
      if (!Array.isArray(collection)) {
        collection = Object.values(collection);
      }
      if (!Array.isArray(criteria)) {
        criteria = criteria == null ? [null] : [criteria];
      }
      if (criteria.length === 0) {
        criteria = [null];
      }
      if (!Array.isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      orders = orders.map((order) => String(order));
      const getValueByNestedPath = (object, path2) => {
        let target = object;
        for (let i = 0; i < path2.length && target != null; ++i) {
          target = target[path2[i]];
        }
        return target;
      };
      const getValueByCriterion = (criterion, object) => {
        if (object == null || criterion == null) {
          return object;
        }
        if (typeof criterion === "object" && "key" in criterion) {
          if (Object.hasOwn(object, criterion.key)) {
            return object[criterion.key];
          }
          return getValueByNestedPath(object, criterion.path);
        }
        if (typeof criterion === "function") {
          return criterion(object);
        }
        if (Array.isArray(criterion)) {
          return getValueByNestedPath(object, criterion);
        }
        if (typeof object === "object") {
          return object[criterion];
        }
        return object;
      };
      const preparedCriteria = criteria.map((criterion) => {
        if (Array.isArray(criterion) && criterion.length === 1) {
          criterion = criterion[0];
        }
        if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey.isKey(criterion)) {
          return criterion;
        }
        return { key: criterion, path: toPath.toPath(criterion) };
      });
      const preparedCollection = collection.map((item) => ({
        original: item,
        criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
      }));
      return preparedCollection.slice().sort((a2, b) => {
        for (let i = 0; i < preparedCriteria.length; i++) {
          const comparedResult = compareValues2.compareValues(a2.criteria[i], b.criteria[i], orders[i]);
          if (comparedResult !== 0) {
            return comparedResult;
          }
        }
        return 0;
      }).map((item) => item.original);
    }
    exports.orderBy = orderBy2;
  }
});

// node_modules/es-toolkit/dist/array/flatten.js
const require_flatten = __commonJS({
  "node_modules/es-toolkit/dist/array/flatten.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function flatten2(arr, depth = 1) {
      const result = [];
      const flooredDepth = Math.floor(depth);
      const recursive = (arr2, currentDepth) => {
        for (let i = 0; i < arr2.length; i++) {
          const item = arr2[i];
          if (Array.isArray(item) && currentDepth < flooredDepth) {
            recursive(item, currentDepth + 1);
          } else {
            result.push(item);
          }
        }
      };
      recursive(arr, 0);
      return result;
    }
    exports.flatten = flatten2;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js
const require_isIterateeCall = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isIndex = require_isIndex();
    const isArrayLike = require_isArrayLike();
    const isObject = require_isObject();
    const eq2 = require_eq();
    function isIterateeCall(value, index2, object) {
      if (!isObject.isObject(object)) {
        return false;
      }
      if (typeof index2 === "number" && isArrayLike.isArrayLike(object) && isIndex.isIndex(index2) && index2 < object.length || typeof index2 === "string" && index2 in object) {
        return eq2.eq(object[index2], value);
      }
      return false;
    }
    exports.isIterateeCall = isIterateeCall;
  }
});

// node_modules/es-toolkit/dist/compat/array/sortBy.js
const require_sortBy = __commonJS({
  "node_modules/es-toolkit/dist/compat/array/sortBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const orderBy2 = require_orderBy();
    const flatten2 = require_flatten();
    const isIterateeCall = require_isIterateeCall();
    function sortBy6(collection, ...criteria) {
      const length = criteria.length;
      if (length > 1 && isIterateeCall.isIterateeCall(collection, criteria[0], criteria[1])) {
        criteria = [];
      } else if (length > 2 && isIterateeCall.isIterateeCall(criteria[0], criteria[1], criteria[2])) {
        criteria = [criteria[0]];
      }
      return orderBy2.orderBy(collection, flatten2.flatten(criteria), ["asc"]);
    }
    exports.sortBy = sortBy6;
  }
});

// node_modules/es-toolkit/compat/sortBy.js
const require_sortBy2 = __commonJS({
  "node_modules/es-toolkit/compat/sortBy.js"(exports, module) {
    module.exports = require_sortBy().sortBy;
  }
});

// node_modules/es-toolkit/dist/compat/util/toNumber.js
const require_toNumber = __commonJS({
  "node_modules/es-toolkit/dist/compat/util/toNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isSymbol3 = require_isSymbol();
    function toNumber2(value) {
      if (isSymbol3.isSymbol(value)) {
        return NaN;
      }
      return Number(value);
    }
    exports.toNumber = toNumber2;
  }
});

// node_modules/es-toolkit/dist/compat/util/toFinite.js
const require_toFinite = __commonJS({
  "node_modules/es-toolkit/dist/compat/util/toFinite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const toNumber2 = require_toNumber();
    function toFinite2(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber2.toNumber(value);
      if (value === Infinity || value === -Infinity) {
        const sign2 = value < 0 ? -1 : 1;
        return sign2 * Number.MAX_VALUE;
      }
      return value === value ? value : 0;
    }
    exports.toFinite = toFinite2;
  }
});

// node_modules/es-toolkit/dist/compat/math/range.js
const require_range = __commonJS({
  "node_modules/es-toolkit/dist/compat/math/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const isIterateeCall = require_isIterateeCall();
    const toFinite2 = require_toFinite();
    function range6(start, end, step) {
      if (step && typeof step !== "number" && isIterateeCall.isIterateeCall(start, end, step)) {
        end = step = void 0;
      }
      start = toFinite2.toFinite(start);
      if (end === void 0) {
        end = start;
        start = 0;
      } else {
        end = toFinite2.toFinite(end);
      }
      step = step === void 0 ? start < end ? 1 : -1 : toFinite2.toFinite(step);
      const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
      const result = new Array(length);
      for (let index2 = 0; index2 < length; index2++) {
        result[index2] = start;
        start += step;
      }
      return result;
    }
    exports.range = range6;
  }
});

// node_modules/es-toolkit/compat/range.js
const require_range2 = __commonJS({
  "node_modules/es-toolkit/compat/range.js"(exports, module) {
    module.exports = require_range().range;
  }
});

// node_modules/eventemitter3/index.js
const require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    const has2 = Object.prototype.hasOwnProperty;
    let prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener2(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      const listener2 = new EE(fn, context || emitter, once2), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
      else emitter._events[evt] = [emitter._events[evt], listener2];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      let names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      const evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      const evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      const evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      let listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        let length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once2(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once2) {
      const evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      const listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      let evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/es-toolkit/dist/function/debounce.js
const require_debounce = __commonJS({
  "node_modules/es-toolkit/dist/function/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function debounce2(func, debounceMs, { signal, edges } = {}) {
      let pendingThis = void 0;
      let pendingArgs = null;
      const leading = edges != null && edges.includes("leading");
      const trailing = edges == null || edges.includes("trailing");
      const invoke = () => {
        if (pendingArgs !== null) {
          func.apply(pendingThis, pendingArgs);
          pendingThis = void 0;
          pendingArgs = null;
        }
      };
      const onTimerEnd = () => {
        if (trailing) {
          invoke();
        }
        cancel();
      };
      let timeoutId = null;
      const schedule = () => {
        if (timeoutId != null) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          timeoutId = null;
          onTimerEnd();
        }, debounceMs);
      };
      const cancelTimer = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const cancel = () => {
        cancelTimer();
        pendingThis = void 0;
        pendingArgs = null;
      };
      const flush = () => {
        invoke();
      };
      const debounced = function(...args) {
        if (signal == null ? void 0 : signal.aborted) {
          return;
        }
        pendingThis = this;
        pendingArgs = args;
        const isFirstCall = timeoutId == null;
        schedule();
        if (leading && isFirstCall) {
          invoke();
        }
      };
      debounced.schedule = schedule;
      debounced.cancel = cancel;
      debounced.flush = flush;
      signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
      return debounced;
    }
    exports.debounce = debounce2;
  }
});

// node_modules/es-toolkit/dist/compat/function/debounce.js
const require_debounce2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/function/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const debounce$1 = require_debounce();
    function debounce2(func, debounceMs = 0, options3 = {}) {
      if (typeof options3 !== "object") {
        options3 = {};
      }
      const { leading = false, trailing = true, maxWait } = options3;
      const edges = Array(2);
      if (leading) {
        edges[0] = "leading";
      }
      if (trailing) {
        edges[1] = "trailing";
      }
      let result = void 0;
      let pendingAt = null;
      const _debounced = debounce$1.debounce(function(...args) {
        result = func.apply(this, args);
        pendingAt = null;
      }, debounceMs, { edges });
      const debounced = function(...args) {
        if (maxWait != null) {
          if (pendingAt === null) {
            pendingAt = Date.now();
          }
          if (Date.now() - pendingAt >= maxWait) {
            result = func.apply(this, args);
            pendingAt = Date.now();
            _debounced.cancel();
            _debounced.schedule();
            return result;
          }
        }
        _debounced.apply(this, args);
        return result;
      };
      const flush = () => {
        _debounced.flush();
        return result;
      };
      debounced.cancel = _debounced.cancel;
      debounced.flush = flush;
      return debounced;
    }
    exports.debounce = debounce2;
  }
});

// node_modules/es-toolkit/dist/compat/function/throttle.js
const require_throttle = __commonJS({
  "node_modules/es-toolkit/dist/compat/function/throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const debounce2 = require_debounce2();
    function throttle3(func, throttleMs = 0, options3 = {}) {
      const { leading = true, trailing = true } = options3;
      return debounce2.debounce(func, throttleMs, {
        leading,
        maxWait: throttleMs,
        trailing
      });
    }
    exports.throttle = throttle3;
  }
});

// node_modules/es-toolkit/compat/throttle.js
const require_throttle2 = __commonJS({
  "node_modules/es-toolkit/compat/throttle.js"(exports, module) {
    module.exports = require_throttle().throttle;
  }
});

// node_modules/es-toolkit/dist/array/last.js
const require_last = __commonJS({
  "node_modules/es-toolkit/dist/array/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function last4(arr) {
      return arr[arr.length - 1];
    }
    exports.last = last4;
  }
});

// node_modules/es-toolkit/dist/compat/_internal/toArray.js
const require_toArray = __commonJS({
  "node_modules/es-toolkit/dist/compat/_internal/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function toArray2(value) {
      return Array.isArray(value) ? value : Array.from(value);
    }
    exports.toArray = toArray2;
  }
});

// node_modules/es-toolkit/dist/compat/array/last.js
const require_last2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/array/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const last$1 = require_last();
    const toArray2 = require_toArray();
    const isArrayLike = require_isArrayLike();
    function last4(array2) {
      if (!isArrayLike.isArrayLike(array2)) {
        return void 0;
      }
      return last$1.last(toArray2.toArray(array2));
    }
    exports.last = last4;
  }
});

// node_modules/es-toolkit/compat/last.js
const require_last3 = __commonJS({
  "node_modules/es-toolkit/compat/last.js"(exports, module) {
    module.exports = require_last2().last;
  }
});

// node_modules/es-toolkit/dist/array/maxBy.js
const require_maxBy = __commonJS({
  "node_modules/es-toolkit/dist/array/maxBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function maxBy4(items, getValue2) {
      if (items.length === 0) {
        return void 0;
      }
      let maxElement = items[0];
      let max3 = getValue2(maxElement);
      for (let i = 1; i < items.length; i++) {
        const element = items[i];
        const value = getValue2(element);
        if (value > max3) {
          max3 = value;
          maxElement = element;
        }
      }
      return maxElement;
    }
    exports.maxBy = maxBy4;
  }
});

// node_modules/es-toolkit/dist/compat/math/maxBy.js
const require_maxBy2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/math/maxBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const maxBy$1 = require_maxBy();
    const identity7 = require_identity();
    const iteratee = require_iteratee();
    function maxBy4(items, iteratee$1) {
      if (items == null) {
        return void 0;
      }
      return maxBy$1.maxBy(Array.from(items), iteratee.iteratee(iteratee$1 ?? identity7.identity));
    }
    exports.maxBy = maxBy4;
  }
});

// node_modules/es-toolkit/compat/maxBy.js
const require_maxBy3 = __commonJS({
  "node_modules/es-toolkit/compat/maxBy.js"(exports, module) {
    module.exports = require_maxBy2().maxBy;
  }
});

// node_modules/es-toolkit/dist/array/minBy.js
const require_minBy = __commonJS({
  "node_modules/es-toolkit/dist/array/minBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function minBy3(items, getValue2) {
      if (items.length === 0) {
        return void 0;
      }
      let minElement = items[0];
      let min3 = getValue2(minElement);
      for (let i = 1; i < items.length; i++) {
        const element = items[i];
        const value = getValue2(element);
        if (value < min3) {
          min3 = value;
          minElement = element;
        }
      }
      return minElement;
    }
    exports.minBy = minBy3;
  }
});

// node_modules/es-toolkit/dist/compat/math/minBy.js
const require_minBy2 = __commonJS({
  "node_modules/es-toolkit/dist/compat/math/minBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const minBy$1 = require_minBy();
    const identity7 = require_identity();
    const iteratee = require_iteratee();
    function minBy3(items, iteratee$1) {
      if (items == null) {
        return void 0;
      }
      return minBy$1.minBy(Array.from(items), iteratee.iteratee(iteratee$1 ?? identity7.identity));
    }
    exports.minBy = minBy3;
  }
});

// node_modules/es-toolkit/compat/minBy.js
const require_minBy3 = __commonJS({
  "node_modules/es-toolkit/compat/minBy.js"(exports, module) {
    module.exports = require_minBy2().minBy;
  }
});

// node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js
const require_isPlainObject = __commonJS({
  "node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    function isPlainObject6(object) {
      let _a;
      if (typeof object !== "object") {
        return false;
      }
      if (object == null) {
        return false;
      }
      if (Object.getPrototypeOf(object) === null) {
        return true;
      }
      if (Object.prototype.toString.call(object) !== "[object Object]") {
        const tag = object[Symbol.toStringTag];
        if (tag == null) {
          return false;
        }
        const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)) == null ? void 0 : _a.writable);
        if (isTagReadonly) {
          return false;
        }
        return object.toString() === `[object ${tag}]`;
      }
      let proto2 = object;
      while (Object.getPrototypeOf(proto2) !== null) {
        proto2 = Object.getPrototypeOf(proto2);
      }
      return Object.getPrototypeOf(object) === proto2;
    }
    exports.isPlainObject = isPlainObject6;
  }
});

// node_modules/es-toolkit/compat/isPlainObject.js
const require_isPlainObject2 = __commonJS({
  "node_modules/es-toolkit/compat/isPlainObject.js"(exports, module) {
    module.exports = require_isPlainObject().isPlainObject;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
const require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      const React74 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = React74.useSyncExternalStore, useRef21 = React74.useRef, useEffect29 = React74.useEffect, useMemo12 = React74.useMemo, useDebugValue2 = React74.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
        let instRef = useRef21(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo12(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual2 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              const nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual2]
        );
        const value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
        useEffect29(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/with-selector.js
const require_with_selector2 = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/es-toolkit/dist/compat/object/unset.js
const require_unset = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/unset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const get9 = require_get();
    const isUnsafeProperty2 = require_isUnsafeProperty();
    const isDeepKey = require_isDeepKey();
    const toKey = require_toKey();
    const toPath = require_toPath();
    function unset(obj, path2) {
      if (obj == null) {
        return true;
      }
      switch (typeof path2) {
        case "symbol":
        case "number":
        case "object": {
          if (Array.isArray(path2)) {
            return unsetWithPath(obj, path2);
          }
          if (typeof path2 === "number") {
            path2 = toKey.toKey(path2);
          } else if (typeof path2 === "object") {
            if (Object.is(path2 == null ? void 0 : path2.valueOf(), -0)) {
              path2 = "-0";
            } else {
              path2 = String(path2);
            }
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return false;
          }
          if ((obj == null ? void 0 : obj[path2]) === void 0) {
            return true;
          }
          try {
            delete obj[path2];
            return true;
          } catch {
            return false;
          }
        }
        case "string": {
          if ((obj == null ? void 0 : obj[path2]) === void 0 && isDeepKey.isDeepKey(path2)) {
            return unsetWithPath(obj, toPath.toPath(path2));
          }
          if (isUnsafeProperty2.isUnsafeProperty(path2)) {
            return false;
          }
          try {
            delete obj[path2];
            return true;
          } catch {
            return false;
          }
        }
      }
    }
    function unsetWithPath(obj, path2) {
      const parent = get9.get(obj, path2.slice(0, -1), obj);
      const lastKey = path2[path2.length - 1];
      if ((parent == null ? void 0 : parent[lastKey]) === void 0) {
        return true;
      }
      if (isUnsafeProperty2.isUnsafeProperty(lastKey)) {
        return false;
      }
      try {
        delete parent[lastKey];
        return true;
      } catch {
        return false;
      }
    }
    exports.unset = unset;
  }
});

// node_modules/es-toolkit/dist/compat/object/omit.js
const require_omit = __commonJS({
  "node_modules/es-toolkit/dist/compat/object/omit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const unset = require_unset();
    const cloneDeep2 = require_cloneDeep();
    function omit4(obj, ...keysArr) {
      if (obj == null) {
        return {};
      }
      const result = cloneDeep2.cloneDeep(obj);
      for (let i = 0; i < keysArr.length; i++) {
        let keys = keysArr[i];
        switch (typeof keys) {
          case "object": {
            if (!Array.isArray(keys)) {
              keys = Array.from(keys);
            }
            for (let j = 0; j < keys.length; j++) {
              const key = keys[j];
              unset.unset(result, key);
            }
            break;
          }
          case "string":
          case "symbol":
          case "number": {
            unset.unset(result, keys);
            break;
          }
        }
      }
      return result;
    }
    exports.omit = omit4;
  }
});

// node_modules/es-toolkit/compat/omit.js
const require_omit2 = __commonJS({
  "node_modules/es-toolkit/compat/omit.js"(exports, module) {
    module.exports = require_omit().omit;
  }
});

// node_modules/es-toolkit/dist/compat/math/sumBy.js
const require_sumBy = __commonJS({
  "node_modules/es-toolkit/dist/compat/math/sumBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    const iteratee = require_iteratee();
    function sumBy3(array2, iteratee$1) {
      if (!array2 || !array2.length) {
        return 0;
      }
      if (iteratee$1 != null) {
        iteratee$1 = iteratee.iteratee(iteratee$1);
      }
      let result = void 0;
      for (let i = 0; i < array2.length; i++) {
        const current2 = iteratee$1 ? iteratee$1(array2[i]) : array2[i];
        if (current2 !== void 0) {
          if (result === void 0) {
            result = current2;
          } else {
            result += current2;
          }
        }
      }
      return result;
    }
    exports.sumBy = sumBy3;
  }
});

// node_modules/es-toolkit/compat/sumBy.js
const require_sumBy2 = __commonJS({
  "node_modules/es-toolkit/compat/sumBy.js"(exports, module) {
    module.exports = require_sumBy().sumBy;
  }
});

// node_modules/recharts/es6/container/Surface.js
const React = __toESM(require_react());
const import_react3 = __toESM(require_react());

// node_modules/recharts/es6/util/ReactUtils.js
const import_get2 = __toESM(require_get2());
const import_react2 = __toESM(require_react());
const import_react_is = __toESM(require_react_is());

// node_modules/recharts/es6/util/DataUtils.js
const import_get = __toESM(require_get2());
const mathSign = (value) => {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return 1;
  }
  return -1;
};
const isNan = (value) => {
  return typeof value == "number" && value != +value;
};
const isPercent = (value) => typeof value === "string" && value.indexOf("%") === value.length - 1;
const isNumber = (value) => (typeof value === "number" || value instanceof Number) && !isNan(value);
const isNumOrStr = (value) => isNumber(value) || typeof value === "string";
let idCounter = 0;
const uniqueId = (prefix2) => {
  const id = ++idCounter;
  return "".concat(prefix2 || "").concat(id);
};
const getPercentValue = function getPercentValue2(percent, totalValue) {
  const defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!isNumber(percent) && typeof percent !== "string") {
    return defaultValue;
  }
  let value;
  if (isPercent(percent)) {
    if (totalValue == null) {
      return defaultValue;
    }
    const index2 = percent.indexOf("%");
    value = totalValue * parseFloat(percent.slice(0, index2)) / 100;
  } else {
    value = +percent;
  }
  if (isNan(value)) {
    value = defaultValue;
  }
  if (validate && totalValue != null && value > totalValue) {
    value = totalValue;
  }
  return value;
};
const hasDuplicate = (ary2) => {
  if (!Array.isArray(ary2)) {
    return false;
  }
  const len = ary2.length;
  const cache = {};
  for (let i = 0; i < len; i++) {
    if (!cache[ary2[i]]) {
      cache[ary2[i]] = true;
    } else {
      return true;
    }
  }
  return false;
};
const interpolateNumber = (numberA, numberB) => {
  if (isNumber(numberA) && isNumber(numberB)) {
    return (t) => numberA + t * (numberB - numberA);
  }
  return () => numberB;
};
function interpolate(start, end, t) {
  if (isNumber(start) && isNumber(end)) {
    return start + t * (end - start);
  }
  return end;
}
function findEntryInArray(ary2, specifiedKey, specifiedValue) {
  if (!ary2 || !ary2.length) {
    return void 0;
  }
  return ary2.find((entry) => entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : (0, import_get.default)(entry, specifiedKey)) === specifiedValue);
}
const getLinearRegression = (data) => {
  if (!data || !data.length) {
    return null;
  }
  const len = data.length;
  let xsum = 0;
  let ysum = 0;
  let xysum = 0;
  let xxsum = 0;
  let xmin = Infinity;
  let xmax = -Infinity;
  let xcurrent = 0;
  let ycurrent = 0;
  for (let i = 0; i < len; i++) {
    xcurrent = data[i].cx || 0;
    ycurrent = data[i].cy || 0;
    xsum += xcurrent;
    ysum += ycurrent;
    xysum += xcurrent * ycurrent;
    xxsum += xcurrent * xcurrent;
    xmin = Math.min(xmin, xcurrent);
    xmax = Math.max(xmax, xcurrent);
  }
  const a2 = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;
  return {
    xmin,
    xmax,
    a: a2,
    b: (ysum - a2 * xsum) / len
  };
};
const isNullish = (value) => {
  return value === null || typeof value === "undefined";
};
const upperFirst = (value) => {
  if (isNullish(value)) {
    return value;
  }
  return "".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
};

// node_modules/recharts/es6/util/types.js
const import_react = __toESM(require_react());

// node_modules/recharts/es6/util/excludeEventProps.js
const EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
function isEventKey(key) {
  if (typeof key !== "string") {
    return false;
  }
  const allowedEventKeys = EventKeys;
  return allowedEventKeys.includes(key);
}

// node_modules/recharts/es6/util/types.js
const SVGContainerPropKeys = ["viewBox", "children"];
const PolyElementKeys = ["points", "pathLength"];
const FilteredElementKeyMap = {
  svg: SVGContainerPropKeys,
  polygon: PolyElementKeys,
  polyline: PolyElementKeys
};
const adaptEventHandlers = (props, newHandler) => {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  let inputProps = props;
  if ((0, import_react.isValidElement)(props)) {
    inputProps = props.props;
  }
  if (typeof inputProps !== "object" && typeof inputProps !== "function") {
    return null;
  }
  const out = {};
  Object.keys(inputProps).forEach((key) => {
    if (isEventKey(key)) {
      out[key] = newHandler || ((e) => inputProps[key](inputProps, e));
    }
  });
  return out;
};
const getEventHandlerOfChild = (originalHandler, data, index2) => (e) => {
  originalHandler(data, index2, e);
  return null;
};
const adaptEventsOfChild = (props, data, index2) => {
  if (props === null || typeof props !== "object" && typeof props !== "function") {
    return null;
  }
  let out = null;
  Object.keys(props).forEach((key) => {
    const item = props[key];
    if (isEventKey(key) && typeof item === "function") {
      if (!out) out = {};
      out[key] = getEventHandlerOfChild(item, data, index2);
    }
  });
  return out;
};

// node_modules/recharts/es6/util/svgPropertiesNoEvents.js
const SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it, and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
function isSvgElementPropKey(key) {
  if (typeof key !== "string") {
    return false;
  }
  const allowedSvgKeys = SVGElementPropKeys;
  return allowedSvgKeys.includes(key);
}
function svgPropertiesNoEvents(obj) {
  const filteredEntries = Object.entries(obj).filter((_ref2) => {
    const [key] = _ref2;
    return isSvgElementPropKey(key);
  });
  return Object.fromEntries(filteredEntries);
}

// node_modules/recharts/es6/util/ReactUtils.js
const getDisplayName = (Comp) => {
  if (typeof Comp === "string") {
    return Comp;
  }
  if (!Comp) {
    return "";
  }
  return Comp.displayName || Comp.name || "Component";
};
let lastChildren = null;
let lastResult = null;
const toArray = (children) => {
  if (children === lastChildren && Array.isArray(lastResult)) {
    return lastResult;
  }
  let result = [];
  import_react2.Children.forEach(children, (child) => {
    if (isNullish(child)) return;
    if ((0, import_react_is.isFragment)(child)) {
      result = result.concat(toArray(child.props.children));
    } else {
      result.push(child);
    }
  });
  lastResult = result;
  lastChildren = children;
  return result;
};
function findAllByType(children, type) {
  const result = [];
  let types = [];
  if (Array.isArray(type)) {
    types = type.map((t) => getDisplayName(t));
  } else {
    types = [getDisplayName(type)];
  }
  toArray(children).forEach((child) => {
    const childType = (0, import_get2.default)(child, "type.displayName") || (0, import_get2.default)(child, "type.name");
    if (types.indexOf(childType) !== -1) {
      result.push(child);
    }
  });
  return result;
}
const isClipDot = (dot) => {
  if (dot && typeof dot === "object" && "clipDot" in dot) {
    return Boolean(dot.clipDot);
  }
  return true;
};
const isValidSpreadableProp = (property, key, includeEvents, svgElementType) => {
  let _ref2;
  if (typeof key === "symbol" || typeof key === "number") {
    return true;
  }
  const matchingElementTypeKeys = (_ref2 = svgElementType && (FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType])) !== null && _ref2 !== void 0 ? _ref2 : [];
  const isDataAttribute = key.startsWith("data-");
  const isSpecificSvgAttribute = typeof property !== "function" && (Boolean(svgElementType) && matchingElementTypeKeys.includes(key) || isSvgElementPropKey(key));
  const isEventAttribute = Boolean(includeEvents) && isEventKey(key);
  return isDataAttribute || isSpecificSvgAttribute || isEventAttribute;
};
const filterProps = (props, includeEvents, svgElementType) => {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  let inputProps = props;
  if ((0, import_react2.isValidElement)(props)) {
    inputProps = props.props;
  }
  if (typeof inputProps !== "object" && typeof inputProps !== "function") {
    return null;
  }
  const out = {};
  Object.keys(inputProps).forEach((key) => {
    let _inputProps;
    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
      out[key] = inputProps[key];
    }
  });
  return out;
};

// node_modules/recharts/es6/container/Surface.js
const _excluded = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const Surface = (0, import_react3.forwardRef)((props, ref) => {
  let {
    children,
    width,
    height,
    viewBox,
    className,
    style,
    title,
    desc
  } = props, others = _objectWithoutProperties(props, _excluded);
  const svgView = viewBox || {
    width,
    height,
    x: 0,
    y: 0
  };
  const layerClass = clsx("recharts-surface", className);
  return React.createElement("svg", _extends({}, filterProps(others, true, "svg"), {
    className: layerClass,
    width,
    height,
    style,
    viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
    ref
  }), React.createElement("title", null, title), React.createElement("desc", null, desc), children);
});

// node_modules/recharts/es6/container/Layer.js
const React2 = __toESM(require_react());
const _excluded2 = ["children", "className"];
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}
function _objectWithoutProperties2(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose2(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose2(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const Layer = React2.forwardRef((props, ref) => {
  let {
    children,
    className
  } = props, others = _objectWithoutProperties2(props, _excluded2);
  const layerClass = clsx("recharts-layer", className);
  return React2.createElement("g", _extends2({
    className: layerClass
  }, filterProps(others, true), {
    ref
  }), children);
});

// node_modules/recharts/es6/component/Legend.js
const React6 = __toESM(require_react());
const import_react12 = __toESM(require_react());
const import_react_dom = __toESM(require_react_dom());

// node_modules/recharts/es6/context/legendPortalContext.js
const import_react4 = __toESM(require_react());
const LegendPortalContext = (0, import_react4.createContext)(null);
const useLegendPortal = () => (0, import_react4.useContext)(LegendPortalContext);

// node_modules/recharts/es6/component/DefaultLegendContent.js
const React4 = __toESM(require_react());
const import_react5 = __toESM(require_react());

// node_modules/recharts/es6/shape/Symbols.js
const React3 = __toESM(require_react());

// node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant2() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
const cos = Math.cos;
const sin = Math.sin;
const sqrt = Math.sqrt;
const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

// node_modules/d3-path/src/path.js
const pi2 = Math.PI;
const tau2 = 2 * pi2;
const epsilon2 = 1e-6;
const tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
const Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    const x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      const x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
      this._append`L${x0},${y0}`;
    }
    if (!r) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon2) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/array.js
const slice = Array.prototype.slice;
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  let defined2 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default(y2);
  function line(data) {
    let i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), line) : defined2;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  let x1 = null, defined2 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default(0) : constant_default(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default(+y1);
  function area(data) {
    let i, j, k2, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined2).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), area) : defined2;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/curve/radial.js
const curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/curve/bump.js
const Bump = class {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x2, y2);
        else this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/d3-shape/src/symbol/asterisk.js
const sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/circle.js
const circle_default = {
  draw(context, size) {
    const r = sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
const cross_default = {
  draw(context, size) {
    const r = sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
const tan30 = sqrt(1 / 3);
const tan30_2 = tan30 * 2;
const diamond_default = {
  draw(context, size) {
    const y2 = sqrt(size / tan30_2);
    const x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/square.js
const square_default = {
  draw(context, size) {
    const w = sqrt(size);
    const x2 = -w / 2;
    context.rect(x2, x2, w, w);
  }
};

// node_modules/d3-shape/src/symbol/star.js
const ka = 0.8908130915292852;
const kr = sin(pi / 10) / sin(7 * pi / 10);
const kx = sin(tau / 10) * kr;
const ky = -cos(tau / 10) * kr;
const star_default = {
  draw(context, size) {
    const r = sqrt(size * ka);
    const x2 = kx * r;
    const y2 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x2, y2);
    for (let i = 1; i < 5; ++i) {
      const a2 = tau * i / 5;
      const c2 = cos(a2);
      const s2 = sin(a2);
      context.lineTo(s2 * r, -c2 * r);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
const sqrt32 = sqrt(3);
const triangle_default = {
  draw(context, size) {
    const y2 = -sqrt(size / (sqrt32 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt32 * y2, -y2);
    context.lineTo(sqrt32 * y2, -y2);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
const sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
const c = -0.5;
const s = sqrt(3) / 2;
const k = 1 / sqrt(12);
const a = (k / 2 + 1) * 3;
const wye_default = {
  draw(context, size) {
    const r = sqrt(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol.js
function Symbol2(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant_default(type || circle_default);
  size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant_default(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basis_default(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisClosed_default(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    const x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      let x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
const bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  let x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    const a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    const b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      const x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRom_default = function custom5(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom5(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      const x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomClosed_default = function custom6(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomClosed(context, alpha2) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom6(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      const x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomOpen_default = function custom7(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom7(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  const h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  const h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t03, t13) {
  const x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    let t13 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
        break;
      default:
        point4(this, this._t0, t13 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    const x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        const px = controlPoints(x2), py = controlPoints(y2);
        for (let i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  let i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          const x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  let n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  let keys = constant_default([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    let sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
    for (y2 = i = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    if (y2) for (i = 0; i < n; ++i) series[i][j][1] /= y2;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      let si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (let k2 = 0; k2 < i; ++k2) {
        const sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1) y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  none_default(series, order);
}

// node_modules/recharts/es6/shape/Symbols.js
const _excluded3 = ["type", "size", "sizeType"];
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends3.apply(null, arguments);
}
function ownKeys(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  const i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties3(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose3(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose3(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const symbolFactories = {
  symbolCircle: circle_default,
  symbolCross: cross_default,
  symbolDiamond: diamond_default,
  symbolSquare: square_default,
  symbolStar: star_default,
  symbolTriangle: triangle_default,
  symbolWye: wye_default
};
const RADIAN = Math.PI / 180;
const getSymbolFactory = (type) => {
  const name = "symbol".concat(upperFirst(type));
  return symbolFactories[name] || circle_default;
};
const calculateAreaSize = (size, sizeType, type) => {
  if (sizeType === "area") {
    return size;
  }
  switch (type) {
    case "cross":
      return 5 * size * size / 9;
    case "diamond":
      return 0.5 * size * size / Math.sqrt(3);
    case "square":
      return size * size;
    case "star": {
      const angle = 18 * RADIAN;
      return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.tan(angle) ** 2);
    }
    case "triangle":
      return Math.sqrt(3) * size * size / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * size * size / 8;
    default:
      return Math.PI * size * size / 4;
  }
};
const registerSymbol = (key, factory) => {
  symbolFactories["symbol".concat(upperFirst(key))] = factory;
};
const Symbols = (_ref2) => {
  let {
    type = "circle",
    size = 64,
    sizeType = "area"
  } = _ref2, rest2 = _objectWithoutProperties3(_ref2, _excluded3);
  const props = _objectSpread(_objectSpread({}, rest2), {}, {
    type,
    size,
    sizeType
  });
  let realType = "circle";
  if (typeof type === "string") {
    realType = type;
  }
  const getPath3 = () => {
    const symbolFactory = getSymbolFactory(realType);
    const symbol = Symbol2().type(symbolFactory).size(calculateAreaSize(size, sizeType, realType));
    return symbol();
  };
  const {
    className,
    cx,
    cy
  } = props;
  const filteredProps = filterProps(props, true);
  if (cx === +cx && cy === +cy && size === +size) {
    return React3.createElement("path", _extends3({}, filteredProps, {
      className: clsx("recharts-symbols", className),
      transform: "translate(".concat(cx, ", ").concat(cy, ")"),
      d: getPath3()
    }));
  }
  return null;
};
Symbols.registerSymbol = registerSymbol;

// node_modules/recharts/es6/component/DefaultLegendContent.js
function _extends4() {
  return _extends4 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends4.apply(null, arguments);
}
function ownKeys2(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty2(e, r, t) {
  return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey2(t) {
  const i = _toPrimitive2(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive2(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const SIZE = 32;
const DefaultLegendContent = class extends import_react5.PureComponent {
  /**
   * Render the path of icon
   * @param data Data of each legend item
   * @param iconType if defined, it will always render this icon. If undefined then it uses icon from data.type
   * @return Path element
   */
  renderIcon(data, iconType) {
    const {
      inactiveColor
    } = this.props;
    const halfSize = SIZE / 2;
    const sixthSize = SIZE / 6;
    const thirdSize = SIZE / 3;
    const color2 = data.inactive ? inactiveColor : data.color;
    const preferredIcon = iconType !== null && iconType !== void 0 ? iconType : data.type;
    if (preferredIcon === "none") {
      return null;
    }
    if (preferredIcon === "plainline") {
      return React4.createElement("line", {
        strokeWidth: 4,
        fill: "none",
        stroke: color2,
        strokeDasharray: data.payload.strokeDasharray,
        x1: 0,
        y1: halfSize,
        x2: SIZE,
        y2: halfSize,
        className: "recharts-legend-icon"
      });
    }
    if (preferredIcon === "line") {
      return React4.createElement("path", {
        strokeWidth: 4,
        fill: "none",
        stroke: color2,
        d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
        className: "recharts-legend-icon"
      });
    }
    if (preferredIcon === "rect") {
      return React4.createElement("path", {
        stroke: "none",
        fill: color2,
        d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
        className: "recharts-legend-icon"
      });
    }
    if (React4.isValidElement(data.legendIcon)) {
      const iconProps = _objectSpread2({}, data);
      delete iconProps.legendIcon;
      return React4.cloneElement(data.legendIcon, iconProps);
    }
    return React4.createElement(Symbols, {
      fill: color2,
      cx: halfSize,
      cy: halfSize,
      size: SIZE,
      sizeType: "diameter",
      type: preferredIcon
    });
  }
  /**
   * Draw items of legend
   * @return Items
   */
  renderItems() {
    const {
      payload,
      iconSize,
      layout,
      formatter,
      inactiveColor,
      iconType
    } = this.props;
    const viewBox = {
      x: 0,
      y: 0,
      width: SIZE,
      height: SIZE
    };
    const itemStyle = {
      display: layout === "horizontal" ? "inline-block" : "block",
      marginRight: 10
    };
    const svgStyle = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4
    };
    return payload.map((entry, i) => {
      const finalFormatter = entry.formatter || formatter;
      const className = clsx({
        "recharts-legend-item": true,
        ["legend-item-".concat(i)]: true,
        inactive: entry.inactive
      });
      if (entry.type === "none") {
        return null;
      }
      const color2 = entry.inactive ? inactiveColor : entry.color;
      const finalValue = finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value;
      return React4.createElement("li", _extends4({
        className,
        style: itemStyle,
        key: "legend-item-".concat(i)
      }, adaptEventsOfChild(this.props, entry, i)), React4.createElement(Surface, {
        width: iconSize,
        height: iconSize,
        viewBox,
        style: svgStyle,
        "aria-label": "".concat(finalValue, " legend icon")
      }, this.renderIcon(entry, iconType)), React4.createElement("span", {
        className: "recharts-legend-item-text",
        style: {
          color: color2
        }
      }, finalValue));
    });
  }
  render() {
    const {
      payload,
      layout,
      align
    } = this.props;
    if (!payload || !payload.length) {
      return null;
    }
    const finalStyle = {
      padding: 0,
      margin: 0,
      textAlign: layout === "horizontal" ? align : "left"
    };
    return React4.createElement("ul", {
      className: "recharts-default-legend",
      style: finalStyle
    }, this.renderItems());
  }
};
_defineProperty2(DefaultLegendContent, "displayName", "Legend");
_defineProperty2(DefaultLegendContent, "defaultProps", {
  align: "center",
  iconSize: 14,
  inactiveColor: "#ccc",
  layout: "horizontal",
  verticalAlign: "middle"
});

// node_modules/recharts/es6/util/payload/getUniqPayload.js
const import_uniqBy = __toESM(require_uniqBy3());
function getUniqPayload(payload, option, defaultUniqBy3) {
  if (option === true) {
    return (0, import_uniqBy.default)(payload, defaultUniqBy3);
  }
  if (typeof option === "function") {
    return (0, import_uniqBy.default)(payload, option);
  }
  return payload;
}

// node_modules/recharts/es6/state/hooks.js
const import_with_selector = __toESM(require_with_selector());
const import_react7 = __toESM(require_react());

// node_modules/recharts/es6/state/RechartsReduxContext.js
const import_react6 = __toESM(require_react());
const RechartsReduxContext = (0, import_react6.createContext)(null);

// node_modules/recharts/es6/state/hooks.js
const noopDispatch = (a2) => a2;
const useAppDispatch = () => {
  const context = (0, import_react7.useContext)(RechartsReduxContext);
  if (context) {
    return context.store.dispatch;
  }
  return noopDispatch;
};
const noop = () => {
};
const addNestedSubNoop = () => noop;
const refEquality = (a2, b) => a2 === b;
function useAppSelector(selector) {
  const context = (0, import_react7.useContext)(RechartsReduxContext);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(context ? context.subscription.addNestedSub : addNestedSubNoop, context ? context.store.getState : noop, context ? context.store.getState : noop, context ? selector : noop, refEquality);
}

// node_modules/reselect/dist/reselect.mjs
const runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        
        ({ stack } = e);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
const runInputStabilityCheck = (inputSelectorResultsObject, options3, inputSelectorArgs) => {
  const { memoize: memoize3, memoizeOptions } = options3;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize3(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      
      ({ stack } = e);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
const globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
const NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
const ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
const getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
const REDUX_PROXY_LABEL = Symbol();
const proto = Object.getPrototypeOf({});
const StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
const Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
const UNTERMINATED = 0;
const TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options3 = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options3;
  let lastResult2;
  let resultsCount = 0;
  function memoized() {
    let _a;
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a = lastResult2 == null ? void 0 : lastResult2.deref) == null ? void 0 : _a.call(lastResult2)) ?? lastResult2;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult2 = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult2;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize3,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize3(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult2
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize: memoize3, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult2;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult2,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize3,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
const createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index2) => {
          composition[inputSelectorKeys[index2]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/recharts/es6/state/selectors/legendSelectors.js
const import_sortBy = __toESM(require_sortBy2());
const selectLegendSettings = (state) => state.legend.settings;
const selectLegendSize = (state) => state.legend.size;
const selectAllLegendPayload2DArray = (state) => state.legend.payload;
const selectLegendPayload = createSelector([selectAllLegendPayload2DArray, selectLegendSettings], (payloads, _ref2) => {
  const {
    itemSorter
  } = _ref2;
  const flat = payloads.flat(1);
  return itemSorter ? (0, import_sortBy.default)(flat, itemSorter) : flat;
});

// node_modules/recharts/es6/context/legendPayloadContext.js
function useLegendPayload() {
  return useAppSelector(selectLegendPayload);
}

// node_modules/recharts/es6/util/useElementOffset.js
const import_react8 = __toESM(require_react());
const EPS = 1;
function useElementOffset() {
  const extraDependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const [lastBoundingBox, setLastBoundingBox] = (0, import_react8.useState)({
    height: 0,
    left: 0,
    top: 0,
    width: 0
  });
  const updateBoundingBox = (0, import_react8.useCallback)(
    (node) => {
      if (node != null) {
        const rect = node.getBoundingClientRect();
        const box = {
          height: rect.height,
          left: rect.left,
          top: rect.top,
          width: rect.width
        };
        if (Math.abs(box.height - lastBoundingBox.height) > EPS || Math.abs(box.left - lastBoundingBox.left) > EPS || Math.abs(box.top - lastBoundingBox.top) > EPS || Math.abs(box.width - lastBoundingBox.width) > EPS) {
          setLastBoundingBox({
            height: box.height,
            left: box.left,
            top: box.top,
            width: box.width
          });
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [lastBoundingBox.width, lastBoundingBox.height, lastBoundingBox.top, lastBoundingBox.left, ...extraDependencies]
  );
  return [lastBoundingBox, updateBoundingBox];
}

// node_modules/recharts/es6/context/chartLayoutContext.js
const import_react11 = __toESM(require_react());

// node_modules/redux/dist/redux.mjs
const $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
const symbol_observable_default = $$observable;
const randomString = () => Math.random().toString(36).substring(7).split("").join(".");
const ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
const actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState2, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
  }
  if (typeof preloadedState2 === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState2 === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState2;
    preloadedState2 = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer, preloadedState2);
  }
  let currentReducer = reducer;
  let currentState = preloadedState2;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener2, key) => {
        nextListeners.set(key, listener2);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener2)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener2) => {
      listener2();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach((key) => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach((key) => {
    const reducer = reducers[key];
    const initialState12 = reducer(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState12 === "undefined") {
      throw new Error(false ? formatProdErrorMessage(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(false ? formatProdErrorMessage(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);
  const finalReducers = {};
  for (let i = 0; i < reducerKeys.length; i++) {
    const key = reducerKeys[i];
    if (true) {
      if (typeof reducers[key] === "undefined") {
        warning(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (true) {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (true) {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i];
      const reducer = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(false ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState2) => {
    const store = createStore2(reducer, preloadedState2);
    let dispatch = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}

// node_modules/immer/dist/immer.mjs
const NOTHING = Symbol.for("immer-nothing");
const DRAFTABLE = Symbol.for("immer-draftable");
const DRAFT_STATE = Symbol.for("immer-state");
const errors = true ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (true) {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
const getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  let _a;
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
}
const objectCtorString = Object.prototype.constructor.toString();
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto2 = getPrototypeOf(value);
  if (proto2 === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index2) => iter(index2, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain2 = isPlainObject2(base);
  if (strict === true || strict === "class_only" && !isPlain2) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    const keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto2 = getPrototypeOf(base);
    if (proto2 !== null && isPlain2) {
      return { ...base };
    }
    const obj = Object.create(proto2);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: { value: dontMutateFrozenCollections },
      add: { value: dontMutateFrozenCollections },
      clear: { value: dontMutateFrozenCollections },
      delete: { value: dontMutateFrozenCollections }
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
const plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
let currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path2) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path2)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet22 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet22 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path2, isSet22)
    );
    maybeFreeze(rootScope, result, false);
    if (path2 && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path2,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path2);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray2 = Array.isArray(base);
  const state = {
    type_: isArray2 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray2) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  let _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto2 = getPrototypeOf(source);
  while (proto2) {
    const desc = Object.getOwnPropertyDescriptor(proto2, prop);
    if (desc)
      return desc;
    proto2 = getPrototypeOf(proto2);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
const Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
      this.setAutoFreeze(config2.autoFreeze);
    if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy3;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy3 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy3 = shallowCopy(value, true);
  }
  each(copy3, (key, childValue) => {
    set(copy3, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy3;
}
const immer = new Immer2();
const produce = immer.produce;
const produceWithPatches = immer.produceWithPatches.bind(
  immer
);
const setAutoFreeze = immer.setAutoFreeze.bind(immer);
const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(
  immer
);
const applyPatches = immer.applyPatches.bind(immer);
const createDraft = immer.createDraft.bind(immer);
const finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
  return value;
}

// node_modules/redux-thunk/dist/redux-thunk.mjs
function createThunkMiddleware(extraArgument) {
  const middleware = ({ dispatch, getState }) => (next) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
  return middleware;
}
const thunk = createThunkMiddleware();
const withExtraArgument = createThunkMiddleware;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
const createDraftSafeSelectorCreator = (...args) => {
  const createSelector2 = createSelectorCreator(...args);
  const createDraftSafeSelector2 = Object.assign((...args2) => {
    const selector = createSelector2(...args2);
    const wrappedSelector = (value, ...rest2) => selector(isDraft(value) ? current(value) : value, ...rest2);
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
const createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize);
const composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
const devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop32) {
    return noop32;
  };
};
const hasMatchFunction = (v) => {
  return v && typeof v.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      const prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options3 = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options3;
  return () => (next) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn) {
      const started = Date.now();
      try {
        return fn();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
const Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map5, key, compute) {
  if (map5.has(key)) return map5.get(key);
  return map5.set(key, compute(key)).get(key);
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path2 = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path2 ? path2 + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path2 = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path: path2
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (const key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (const key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const key in keysToDetect) {
    const nestedPath = path2 ? path2 + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options3 = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  } else {
    const stringify2 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      const stack = [], keys = [];
      if (!decycler) decycler = function(_, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = decycler.call(this, key, value);
        } else stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
      };
    };
    const stringify = stringify2, getSerialize = getSerialize2;
    const {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options3;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path2 = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path2 || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache == null ? void 0 : cache.has(value)) return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path2 ? path2 + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache && isNestedFrozen(value)) cache.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value)) return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options3 = {}) {
  if (false) {
    return () => (next) => (action) => next(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options3;
    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next) => (action) => {
      if (!isAction(action)) {
        return next(action);
      }
      const result = next(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean(x2) {
  return typeof x2 === "boolean";
}
const buildGetDefaultMiddleware = () => function getDefaultMiddleware(options3) {
  const {
    thunk: thunk2 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options3 ?? {};
  const middlewareArray = new Tuple();
  if (thunk2) {
    if (isBoolean(thunk2)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk2.extraArgument));
    }
  }
  if (true) {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
const SHOULD_AUTOBATCH = "RTK_autoBatch";
const createQueueWithTimer = (timeout2) => {
  return (notify) => {
    setTimeout(notify, timeout2);
  };
};
const autoBatchEnhancer = (options3 = {
  type: "raf"
}) => (next) => (...args) => {
  const store = next(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options3.type === "tick" ? queueMicrotask : options3.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options3.type === "callback" ? options3.queueNotification : createQueueWithTimer(options3.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l) => l());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      let _a;
      try {
        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
const buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options3) {
  const {
    autoBatch = true
  } = options3 ?? {};
  const enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options3) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware,
    devTools = true,
    duplicateMiddlewareCheck = true,
    preloadedState: preloadedState2 = void 0,
    enhancers = void 0
  } = options3 || {};
  let rootReducer2;
  if (typeof reducer === "function") {
    rootReducer2 = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer2 = combineReducers(reducer);
  } else {
    throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (middleware && typeof middleware !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware === "function") {
    finalMiddleware = middleware(getDefaultMiddleware);
    if (!Array.isArray(finalMiddleware)) {
      throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  if (duplicateMiddlewareCheck) {
    const middlewareReferences = /* @__PURE__ */ new Set();
    finalMiddleware.forEach((middleware2) => {
      if (middlewareReferences.has(middleware2)) {
        throw new Error(false ? formatProdErrorMessage(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      }
      middlewareReferences.add(middleware2);
    });
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: true,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (enhancers && typeof enhancers !== "function") {
    throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  const storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (!Array.isArray(storeEnhancers)) {
    throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState2, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (true) {
        if (actionMatchers.length > 0) {
          throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addAsyncThunk(asyncThunk, reducers) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(43) : "`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`");
        }
      }
      if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
      if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
      if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
      if (reducers.settled) actionMatchers.push({
        matcher: asyncThunk.settled,
        reducer: reducers.settled
      });
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer
      });
      return builder;
    },
    addDefaultCase(reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState12, mapOrBuilderCallback) {
  if (true) {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  const [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState12)) {
    getInitialState = () => freezeDraftable(initialState12());
  } else {
    const frozenInitialState = freezeDraftable(initialState12);
    getInitialState = () => frozenInitialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer2
    }) => reducer2)];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
const matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
const urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
const nanoid = (size = 21) => {
  let id = "";
  let i = size;
  while (i--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
const commonProperties = ["name", "message", "stack", "code"];
const RejectWithValue = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
const FulfillWithMeta = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
const miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
const externalAbortMessage = "External signal was aborted";
const createAsyncThunk = (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options3) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options3 && options3.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error == null ? void 0 : error.name) === "AbortError",
        condition: (error == null ? void 0 : error.name) === "ConditionError"
      }
    }));
    function actionCreator(arg, {
      signal
    } = {}) {
      return (dispatch, getState, extra) => {
        const requestId = (options3 == null ? void 0 : options3.idGenerator) ? options3.idGenerator(arg) : nanoid();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        if (signal) {
          if (signal.aborted) {
            abort(externalAbortMessage);
          } else {
            signal.addEventListener("abort", () => abort(externalAbortMessage), {
              once: true
            });
          }
        }
        const promise = async function() {
          let _a, _b;
          let finalAction;
          try {
            let conditionResult = (_a = options3 == null ? void 0 : options3.condition) == null ? void 0 : _a.call(options3, arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, (_b = options3 == null ? void 0 : options3.getPendingMeta) == null ? void 0 : _b.call(options3, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options3 && !options3.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        }();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
const asyncThunkSymbol = Symbol.for("rtk-slice-createasyncthunk");
const asyncThunkCreator = {
  [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = ((ReducerType2) => {
  ReducerType2["reducer"] = "reducer";
  ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
  ReducerType2["asyncThunk"] = "asyncThunk";
  return ReducerType2;
})(ReducerType || {});
function getType(slice3, actionKey) {
  return `${slice3}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  let _a;
  const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
  return function createSlice2(options3) {
    const {
      name,
      reducerPath = name
    } = options3;
    if (!name) {
      throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && true) {
      if (options3.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers = (typeof options3.reducers === "function" ? options3.reducers(buildReducerCreators()) : options3.reducers) || {};
    const reducerNames = Object.keys(reducers);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer2) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer2;
        return contextMethods;
      },
      addMatcher(matcher, reducer2) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer2
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer2) {
        context.sliceCaseReducersByName[name2] = reducer2;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options3.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (true) {
        if (typeof options3.extraReducers === "object") {
          throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options3.extraReducers === "function" ? executeReducerBuilderCallback(options3.extraReducers) : [options3.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options3.initialState, (builder) => {
        for (const key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (const sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (const m of actionMatchers) {
          builder.addMatcher(m.matcher, m.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
          } else if (true) {
            throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map5 = {};
          for (const [name2, selector] of Object.entries(options3.selectors ?? {})) {
            map5[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
          }
          return map5;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice3 = {
      name,
      reducer,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config2
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer
        }, config2);
        return {
          ...slice3,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice3;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (true) {
        throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
const createSlice = buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config2) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config2
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options: options3
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options3);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop2,
    pending: pending || noop2,
    rejected: rejected || noop2,
    settled: settled || noop2
  });
}
function noop2() {
}
const task = "task";
const listener = "listener";
const completed = "completed";
const cancelled = "cancelled";
const taskCancelled = `task-${cancelled}`;
const taskCompleted = `task-${completed}`;
const listenerCancelled = `${listener}-${cancelled}`;
const listenerCompleted = `${listener}-${completed}`;
const TaskAbortError = class {
  constructor(code) {
    __publicField(this, "name", "TaskAbortError");
    __publicField(this, "message");
    this.code = code;
    this.message = `${task} ${cancelled} (reason: ${code})`;
  }
};
const assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new TypeError(false ? formatProdErrorMessage(32) : `${expected} is not a function`);
  }
};
const noop22 = () => {
};
const catchRejection = (promise, onError = noop22) => {
  promise.catch(onError);
  return promise;
};
const addAbortSignalListener = (abortSignal, callback) => {
  abortSignal.addEventListener("abort", callback, {
    once: true
  });
  return () => abortSignal.removeEventListener("abort", callback);
};
const abortControllerWithReason = (abortController, reason) => {
  const signal = abortController.signal;
  if (signal.aborted) {
    return;
  }
  if (!("reason" in signal)) {
    Object.defineProperty(signal, "reason", {
      enumerable: true,
      value: reason,
      configurable: true,
      writable: true
    });
  }
  
  abortController.abort(reason);
};
const validateActive = (signal) => {
  if (signal.aborted) {
    const {
      reason
    } = signal;
    throw new TaskAbortError(reason);
  }
};
function raceWithSignal(signal, promise) {
  let cleanup = noop22;
  return new Promise((resolve, reject) => {
    const notifyRejection = () => reject(new TaskAbortError(signal.reason));
    if (signal.aborted) {
      notifyRejection();
      return;
    }
    cleanup = addAbortSignalListener(signal, notifyRejection);
    promise.finally(() => cleanup()).then(resolve, reject);
  }).finally(() => {
    cleanup = noop22;
  });
}
const runTask = async (task2, cleanUp) => {
  try {
    await Promise.resolve();
    const value = await task2();
    return {
      status: "ok",
      value
    };
  } catch (error) {
    return {
      status: error instanceof TaskAbortError ? "cancelled" : "rejected",
      error
    };
  } finally {
    cleanUp == null ? void 0 : cleanUp();
  }
};
const createPause = (signal) => {
  return (promise) => {
    return catchRejection(raceWithSignal(signal, promise).then((output) => {
      validateActive(signal);
      return output;
    }));
  };
};
const createDelay = (signal) => {
  const pause = createPause(signal);
  return (timeoutMs) => {
    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
  };
};
const {
  assign
} = Object;
const INTERNAL_NIL_TOKEN = {};
const alm = "listenerMiddleware";
const createFork = (parentAbortSignal, parentBlockingPromises) => {
  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
  return (taskExecutor, opts) => {
    assertFunction(taskExecutor, "taskExecutor");
    const childAbortController = new AbortController();
    linkControllers(childAbortController);
    const result = runTask(async () => {
      validateActive(parentAbortSignal);
      validateActive(childAbortController.signal);
      const result2 = await taskExecutor({
        pause: createPause(childAbortController.signal),
        delay: createDelay(childAbortController.signal),
        signal: childAbortController.signal
      });
      validateActive(childAbortController.signal);
      return result2;
    }, () => abortControllerWithReason(childAbortController, taskCompleted));
    if (opts == null ? void 0 : opts.autoJoin) {
      parentBlockingPromises.push(result.catch(noop22));
    }
    return {
      result: createPause(parentAbortSignal)(result),
      cancel() {
        abortControllerWithReason(childAbortController, taskCancelled);
      }
    };
  };
};
const createTakePattern = (startListening, signal) => {
  const take2 = async (predicate, timeout2) => {
    validateActive(signal);
    let unsubscribe = () => {
    };
    const tuplePromise = new Promise((resolve, reject) => {
      const stopListening = startListening({
        predicate,
        effect: (action, listenerApi) => {
          listenerApi.unsubscribe();
          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);
        }
      });
      unsubscribe = () => {
        stopListening();
        reject();
      };
    });
    const promises = [tuplePromise];
    if (timeout2 != null) {
      promises.push(new Promise((resolve) => setTimeout(resolve, timeout2, null)));
    }
    try {
      const output = await raceWithSignal(signal, Promise.race(promises));
      validateActive(signal);
      return output;
    } finally {
      unsubscribe();
    }
  };
  return (predicate, timeout2) => catchRejection(take2(predicate, timeout2));
};
const getListenerEntryPropsFrom = (options3) => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options3;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) {
  } else {
    throw new Error(false ? formatProdErrorMessage(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  }
  assertFunction(effect, "options.listener");
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = assign((options3) => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options3);
  const entry = {
    id: nanoid(),
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(false ? formatProdErrorMessage(22) : "Unsubscribe not initialized");
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
const findListenerEntry = (listenerMap, options3) => {
  const {
    type,
    effect,
    predicate
  } = getListenerEntryPropsFrom(options3);
  return Array.from(listenerMap.values()).find((entry) => {
    const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
    return matchPredicateOrType && entry.effect === effect;
  });
};
const cancelActiveListeners = (entry) => {
  entry.pending.forEach((controller) => {
    abortControllerWithReason(controller, listenerCancelled);
  });
};
const createClearListenerMiddleware = (listenerMap) => {
  return () => {
    listenerMap.forEach(cancelActiveListeners);
    listenerMap.clear();
  };
};
const safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
  try {
    errorHandler(errorToNotify, errorInfo);
  } catch (errorHandlerError) {
    setTimeout(() => {
      throw errorHandlerError;
    }, 0);
  }
};
var addListener = assign(createAction(`${alm}/add`), {
  withTypes: () => addListener
});
const clearAllListeners = createAction(`${alm}/removeAll`);
var removeListener = assign(createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
const defaultErrorHandler = (...args) => {
  console.error(`${alm}/error`, ...args);
};
const createListenerMiddleware = (middlewareOptions = {}) => {
  const listenerMap = /* @__PURE__ */ new Map();
  const {
    extra,
    onError = defaultErrorHandler
  } = middlewareOptions;
  assertFunction(onError, "onError");
  const insertEntry = (entry) => {
    entry.unsubscribe = () => listenerMap.delete(entry.id);
    listenerMap.set(entry.id, entry);
    return (cancelOptions) => {
      entry.unsubscribe();
      if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {
        cancelActiveListeners(entry);
      }
    };
  };
  const startListening = (options3) => {
    const entry = findListenerEntry(listenerMap, options3) ?? createListenerEntry(options3);
    return insertEntry(entry);
  };
  assign(startListening, {
    withTypes: () => startListening
  });
  const stopListening = (options3) => {
    const entry = findListenerEntry(listenerMap, options3);
    if (entry) {
      entry.unsubscribe();
      if (options3.cancelActive) {
        cancelActiveListeners(entry);
      }
    }
    return !!entry;
  };
  assign(stopListening, {
    withTypes: () => stopListening
  });
  const notifyListener = async (entry, action, api, getOriginalState) => {
    const internalTaskController = new AbortController();
    const take2 = createTakePattern(startListening, internalTaskController.signal);
    const autoJoinPromises = [];
    try {
      entry.pending.add(internalTaskController);
      await Promise.resolve(entry.effect(
        action,
        // Use assign() rather than ... to avoid extra helper functions added to bundle
        assign({}, api, {
          getOriginalState,
          condition: (predicate, timeout2) => take2(predicate, timeout2).then(Boolean),
          take: take2,
          delay: createDelay(internalTaskController.signal),
          pause: createPause(internalTaskController.signal),
          extra,
          signal: internalTaskController.signal,
          fork: createFork(internalTaskController.signal, autoJoinPromises),
          unsubscribe: entry.unsubscribe,
          subscribe: () => {
            listenerMap.set(entry.id, entry);
          },
          cancelActiveListeners: () => {
            entry.pending.forEach((controller, _, set2) => {
              if (controller !== internalTaskController) {
                abortControllerWithReason(controller, listenerCancelled);
                set2.delete(controller);
              }
            });
          },
          cancel: () => {
            abortControllerWithReason(internalTaskController, listenerCancelled);
            entry.pending.delete(internalTaskController);
          },
          throwIfCancelled: () => {
            validateActive(internalTaskController.signal);
          }
        })
      ));
    } catch (listenerError) {
      if (!(listenerError instanceof TaskAbortError)) {
        safelyNotifyError(onError, listenerError, {
          raisedBy: "effect"
        });
      }
    } finally {
      await Promise.all(autoJoinPromises);
      abortControllerWithReason(internalTaskController, listenerCompleted);
      entry.pending.delete(internalTaskController);
    }
  };
  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
  const middleware = (api) => (next) => (action) => {
    if (!isAction(action)) {
      return next(action);
    }
    if (addListener.match(action)) {
      return startListening(action.payload);
    }
    if (clearAllListeners.match(action)) {
      clearListenerMiddleware();
      return;
    }
    if (removeListener.match(action)) {
      return stopListening(action.payload);
    }
    let originalState = api.getState();
    const getOriginalState = () => {
      if (originalState === INTERNAL_NIL_TOKEN) {
        throw new Error(false ? formatProdErrorMessage(23) : `${alm}: getOriginalState can only be called synchronously`);
      }
      return originalState;
    };
    let result;
    try {
      result = next(action);
      if (listenerMap.size > 0) {
        const currentState = api.getState();
        const listenerEntries = Array.from(listenerMap.values());
        for (const entry of listenerEntries) {
          let runListener = false;
          try {
            runListener = entry.predicate(action, currentState, originalState);
          } catch (predicateError) {
            runListener = false;
            safelyNotifyError(onError, predicateError, {
              raisedBy: "predicate"
            });
          }
          if (!runListener) {
            continue;
          }
          notifyListener(entry, action, api, getOriginalState);
        }
      }
    } finally {
      originalState = INTERNAL_NIL_TOKEN;
    }
    return result;
  };
  return {
    middleware,
    startListening,
    stopListening,
    clearListeners: clearListenerMiddleware
  };
};
const ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

// node_modules/recharts/es6/state/layoutSlice.js
const initialState = {
  layoutType: "horizontal",
  width: 0,
  height: 0,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  scale: 1
};
const chartLayoutSlice = createSlice({
  name: "chartLayout",
  initialState,
  reducers: {
    setLayout(state, action) {
      state.layoutType = action.payload;
    },
    setChartSize(state, action) {
      state.width = action.payload.width;
      state.height = action.payload.height;
    },
    setMargin(state, action) {
      let _action$payload$top, _action$payload$right, _action$payload$botto, _action$payload$left;
      state.margin.top = (_action$payload$top = action.payload.top) !== null && _action$payload$top !== void 0 ? _action$payload$top : 0;
      state.margin.right = (_action$payload$right = action.payload.right) !== null && _action$payload$right !== void 0 ? _action$payload$right : 0;
      state.margin.bottom = (_action$payload$botto = action.payload.bottom) !== null && _action$payload$botto !== void 0 ? _action$payload$botto : 0;
      state.margin.left = (_action$payload$left = action.payload.left) !== null && _action$payload$left !== void 0 ? _action$payload$left : 0;
    },
    setScale(state, action) {
      state.scale = action.payload;
    }
  }
});
const {
  setMargin,
  setLayout,
  setChartSize,
  setScale
} = chartLayoutSlice.actions;
const chartLayoutReducer = chartLayoutSlice.reducer;

// node_modules/recharts/es6/util/ChartUtils.js
const import_sortBy2 = __toESM(require_sortBy2());
const import_get3 = __toESM(require_get2());

// node_modules/recharts/es6/util/PolarUtils.js
const import_react9 = __toESM(require_react());
function ownKeys3(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty3(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty3(e, r, t) {
  return (r = _toPropertyKey3(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey3(t) {
  const i = _toPrimitive3(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive3(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const RADIAN2 = Math.PI / 180;
const degreeToRadian = (angle) => angle * Math.PI / 180;
const radianToDegree = (angleInRadian) => angleInRadian * 180 / Math.PI;
const polarToCartesian = (cx, cy, radius, angle) => ({
  x: cx + Math.cos(-RADIAN2 * angle) * radius,
  y: cy + Math.sin(-RADIAN2 * angle) * radius
});
const getMaxRadius = function getMaxRadius2(width, height) {
  const offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    width: 0,
    height: 0,
    brushBottom: 0
  };
  return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
};
const distanceBetweenPoints = (point6, anotherPoint) => {
  const {
    x: x1,
    y: y1
  } = point6;
  const {
    x: x2,
    y: y2
  } = anotherPoint;
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
};
const getAngleOfPoint = (_ref2, _ref22) => {
  const {
    x: x2,
    y: y2
  } = _ref2;
  const {
    cx,
    cy
  } = _ref22;
  const radius = distanceBetweenPoints({
    x: x2,
    y: y2
  }, {
    x: cx,
    y: cy
  });
  if (radius <= 0) {
    return {
      radius,
      angle: 0
    };
  }
  const cos2 = (x2 - cx) / radius;
  let angleInRadian = Math.acos(cos2);
  if (y2 > cy) {
    angleInRadian = 2 * Math.PI - angleInRadian;
  }
  return {
    radius,
    angle: radianToDegree(angleInRadian),
    angleInRadian
  };
};
const formatAngleOfSector = (_ref3) => {
  const {
    startAngle,
    endAngle
  } = _ref3;
  const startCnt = Math.floor(startAngle / 360);
  const endCnt = Math.floor(endAngle / 360);
  const min3 = Math.min(startCnt, endCnt);
  return {
    startAngle: startAngle - min3 * 360,
    endAngle: endAngle - min3 * 360
  };
};
const reverseFormatAngleOfSector = (angle, _ref4) => {
  const {
    startAngle,
    endAngle
  } = _ref4;
  const startCnt = Math.floor(startAngle / 360);
  const endCnt = Math.floor(endAngle / 360);
  const min3 = Math.min(startCnt, endCnt);
  return angle + min3 * 360;
};
const inRangeOfSector = (_ref5, viewBox) => {
  const {
    x: x2,
    y: y2
  } = _ref5;
  const {
    radius,
    angle
  } = getAngleOfPoint({
    x: x2,
    y: y2
  }, viewBox);
  const {
    innerRadius,
    outerRadius
  } = viewBox;
  if (radius < innerRadius || radius > outerRadius) {
    return null;
  }
  if (radius === 0) {
    return null;
  }
  const {
    startAngle,
    endAngle
  } = formatAngleOfSector(viewBox);
  let formatAngle = angle;
  let inRange3;
  if (startAngle <= endAngle) {
    while (formatAngle > endAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < startAngle) {
      formatAngle += 360;
    }
    inRange3 = formatAngle >= startAngle && formatAngle <= endAngle;
  } else {
    while (formatAngle > startAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < endAngle) {
      formatAngle += 360;
    }
    inRange3 = formatAngle >= endAngle && formatAngle <= startAngle;
  }
  if (inRange3) {
    return _objectSpread3(_objectSpread3({}, viewBox), {}, {
      radius,
      angle: reverseFormatAngleOfSector(formatAngle, viewBox)
    });
  }
  return null;
};
const getTickClassName = (tick) => !(0, import_react9.isValidElement)(tick) && typeof tick !== "function" && typeof tick !== "boolean" && tick != null ? tick.className : "";

// node_modules/recharts/es6/util/getSliced.js
function getSliced(arr, startIndex, endIndex) {
  if (!Array.isArray(arr)) {
    return arr;
  }
  if (arr && startIndex + endIndex !== 0) {
    return arr.slice(startIndex, endIndex + 1);
  }
  return arr;
}

// node_modules/recharts/es6/util/ChartUtils.js
function ownKeys4(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty4(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty4(e, r, t) {
  return (r = _toPropertyKey4(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey4(t) {
  const i = _toPrimitive4(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive4(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
  if (isNullish(obj) || isNullish(dataKey)) {
    return defaultValue;
  }
  if (isNumOrStr(dataKey)) {
    return (0, import_get3.default)(obj, dataKey, defaultValue);
  }
  if (typeof dataKey === "function") {
    return dataKey(obj);
  }
  return defaultValue;
}
const calculateActiveTickIndex = (coordinate, ticks2, unsortedTicks, axisType, range6) => {
  let _ticks$length;
  let index2 = -1;
  const len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
  if (len <= 1 || coordinate == null) {
    return 0;
  }
  if (axisType === "angleAxis" && range6 != null && Math.abs(Math.abs(range6[1] - range6[0]) - 360) <= 1e-6) {
    for (let i = 0; i < len; i++) {
      const before2 = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
      const cur = unsortedTicks[i].coordinate;
      const after2 = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
      let sameDirectionCoord = void 0;
      if (mathSign(cur - before2) !== mathSign(after2 - cur)) {
        const diffInterval = [];
        if (mathSign(after2 - cur) === mathSign(range6[1] - range6[0])) {
          sameDirectionCoord = after2;
          const curInRange = cur + range6[1] - range6[0];
          diffInterval[0] = Math.min(curInRange, (curInRange + before2) / 2);
          diffInterval[1] = Math.max(curInRange, (curInRange + before2) / 2);
        } else {
          sameDirectionCoord = before2;
          const afterInRange = after2 + range6[1] - range6[0];
          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
        }
        const sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
          ({
            index: index2
          } = unsortedTicks[i]);
          break;
        }
      } else {
        const minValue = Math.min(before2, after2);
        const maxValue = Math.max(before2, after2);
        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
          ({
            index: index2
          } = unsortedTicks[i]);
          break;
        }
      }
    }
  } else if (ticks2) {
    for (let _i = 0; _i < len; _i++) {
      if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
        ({
          index: index2
        } = ticks2[_i]);
        break;
      }
    }
  }
  return index2;
};
const appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
  if (legendSettings && legendSize) {
    const {
      width: boxWidth,
      height: boxHeight
    } = legendSize;
    const {
      align,
      verticalAlign,
      layout
    } = legendSettings;
    if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) {
      return _objectSpread4(_objectSpread4({}, offset), {}, {
        [align]: offset[align] + (boxWidth || 0)
      });
    }
    if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) {
      return _objectSpread4(_objectSpread4({}, offset), {}, {
        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)
      });
    }
  }
  return offset;
};
const isCategoricalAxis = (layout, axisType) => layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
const getCoordinatesOfGrid = (ticks2, minValue, maxValue, syncWithTicks) => {
  if (syncWithTicks) {
    return ticks2.map((entry) => entry.coordinate);
  }
  let hasMin, hasMax;
  const values = ticks2.map((entry) => {
    if (entry.coordinate === minValue) {
      hasMin = true;
    }
    if (entry.coordinate === maxValue) {
      hasMax = true;
    }
    return entry.coordinate;
  });
  if (!hasMin) {
    values.push(minValue);
  }
  if (!hasMax) {
    values.push(maxValue);
  }
  return values;
};
const getTicksOfAxis = (axis, isGrid, isAll) => {
  if (!axis) {
    return null;
  }
  const {
    duplicateDomain,
    type,
    range: range6,
    scale,
    realScaleType,
    isCategorical,
    categoricalDomain,
    tickCount,
    ticks: ticks2,
    niceTicks,
    axisType
  } = axis;
  if (!scale) {
    return null;
  }
  const offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
  let offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && range6 && range6.length >= 2 ? mathSign(range6[0] - range6[1]) * 2 * offset : offset;
  if (isGrid && (ticks2 || niceTicks)) {
    const result = (ticks2 || niceTicks || []).map((entry, index2) => {
      const scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale(scaleContent) + offset,
        value: entry,
        offset,
        index: index2
      };
    });
    return result.filter((row) => !isNan(row.coordinate));
  }
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index: index2,
      offset
    }));
  }
  if (scale.ticks && !isAll && tickCount != null) {
    return scale.ticks(tickCount).map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset,
      index: index2
    }));
  }
  return scale.domain().map((entry, index2) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index: index2,
    offset
  }));
};
const EPS2 = 1e-4;
const checkDomainOfScale = (scale) => {
  const domain = scale.domain();
  if (!domain || domain.length <= 2) {
    return;
  }
  const len = domain.length;
  const range6 = scale.range();
  const minValue = Math.min(range6[0], range6[1]) - EPS2;
  const maxValue = Math.max(range6[0], range6[1]) + EPS2;
  const first = scale(domain[0]);
  const last4 = scale(domain[len - 1]);
  if (first < minValue || first > maxValue || last4 < minValue || last4 > maxValue) {
    scale.domain([domain[0], domain[len - 1]]);
  }
};
const truncateByDomain = (value, domain) => {
  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
    return value;
  }
  const minValue = Math.min(domain[0], domain[1]);
  const maxValue = Math.max(domain[0], domain[1]);
  const result = [value[0], value[1]];
  if (!isNumber(value[0]) || value[0] < minValue) {
    result[0] = minValue;
  }
  if (!isNumber(value[1]) || value[1] > maxValue) {
    result[1] = maxValue;
  }
  if (result[0] > maxValue) {
    result[0] = maxValue;
  }
  if (result[1] < minValue) {
    result[1] = minValue;
  }
  return result;
};
const offsetSign = (series) => {
  const n = series.length;
  if (n <= 0) {
    return;
  }
  for (let j = 0, m = series[0].length; j < m; ++j) {
    let positive = 0;
    let negative = 0;
    for (let i = 0; i < n; ++i) {
      const value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = negative;
        series[i][j][1] = negative + value;
        negative = series[i][j][1];
      }
    }
  }
};
const offsetPositive = (series) => {
  const n = series.length;
  if (n <= 0) {
    return;
  }
  for (let j = 0, m = series[0].length; j < m; ++j) {
    let positive = 0;
    for (let i = 0; i < n; ++i) {
      const value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = 0;
        series[i][j][1] = 0;
      }
    }
  }
};
const STACK_OFFSET_MAP = {
  sign: offsetSign,
  // @ts-expect-error definitelytyped types are incorrect
  expand: expand_default,
  // @ts-expect-error definitelytyped types are incorrect
  none: none_default,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: silhouette_default,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: wiggle_default,
  positive: offsetPositive
};
const getStackedData = (data, dataKeys, offsetType) => {
  const offsetAccessor = STACK_OFFSET_MAP[offsetType];
  const stack = stack_default().keys(dataKeys).value((d, key) => +getValueByDataKey(d, key, 0)).order(none_default2).offset(offsetAccessor);
  return stack(data);
};
function getNormalizedStackId(publicStackId) {
  return publicStackId == null ? void 0 : String(publicStackId);
}
function getCateCoordinateOfLine(_ref2) {
  const {
    axis,
    ticks: ticks2,
    bandSize,
    entry,
    index: index2,
    dataKey
  } = _ref2;
  if (axis.type === "category") {
    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {
      const matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
      if (matchedTick) {
        return matchedTick.coordinate + bandSize / 2;
      }
    }
    return ticks2[index2] ? ticks2[index2].coordinate + bandSize / 2 : null;
  }
  const value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);
  return !isNullish(value) ? axis.scale(value) : null;
}
const getCateCoordinateOfBar = (_ref2) => {
  const {
    axis,
    ticks: ticks2,
    offset,
    bandSize,
    entry,
    index: index2
  } = _ref2;
  if (axis.type === "category") {
    return ticks2[index2] ? ticks2[index2].coordinate + offset : null;
  }
  const value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index2]);
  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
const getBaseValueOfBar = (_ref3) => {
  const {
    numericAxis
  } = _ref3;
  const domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    const minValue = Math.min(domain[0], domain[1]);
    const maxValue = Math.max(domain[0], domain[1]);
    if (minValue <= 0 && maxValue >= 0) {
      return 0;
    }
    if (maxValue < 0) {
      return maxValue;
    }
    return minValue;
  }
  return domain[0];
};
const getDomainOfSingle = (data) => {
  const flat = data.flat(2).filter(isNumber);
  return [Math.min(...flat), Math.max(...flat)];
};
const makeDomainFinite = (domain) => {
  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];
};
const getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
  if (stackGroups == null) {
    return void 0;
  }
  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {
    const group2 = stackGroups[stackId];
    const {
      stackedData
    } = group2;
    const domain = stackedData.reduce((res, entry) => {
      const sliced = getSliced(entry, startIndex, endIndex);
      const s2 = getDomainOfSingle(sliced);
      return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
    }, [Infinity, -Infinity]);
    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
  }, [Infinity, -Infinity]));
};
const MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
const MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
const getBandSizeOfAxis = (axis, ticks2, isBar) => {
  if (axis && axis.scale && axis.scale.bandwidth) {
    const bandWidth = axis.scale.bandwidth();
    if (!isBar || bandWidth > 0) {
      return bandWidth;
    }
  }
  if (axis && ticks2 && ticks2.length >= 2) {
    const orderedTicks = (0, import_sortBy2.default)(ticks2, (o) => o.coordinate);
    let bandSize = Infinity;
    for (let i = 1, len = orderedTicks.length; i < len; i++) {
      const cur = orderedTicks[i];
      const prev = orderedTicks[i - 1];
      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
    }
    return bandSize === Infinity ? 0 : bandSize;
  }
  return isBar ? void 0 : 0;
};
function getTooltipEntry(_ref4) {
  const {
    tooltipEntrySettings,
    dataKey,
    payload,
    value,
    name
  } = _ref4;
  return _objectSpread4(_objectSpread4({}, tooltipEntrySettings), {}, {
    dataKey,
    payload,
    value,
    name
  });
}
function getTooltipNameProp(nameFromItem, dataKey) {
  if (nameFromItem) {
    return String(nameFromItem);
  }
  if (typeof dataKey === "string") {
    return dataKey;
  }
  return void 0;
}
function inRange(x2, y2, layout, polarViewBox, offset) {
  if (layout === "horizontal" || layout === "vertical") {
    const isInRange = x2 >= offset.left && x2 <= offset.left + offset.width && y2 >= offset.top && y2 <= offset.top + offset.height;
    return isInRange ? {
      x: x2,
      y: y2
    } : null;
  }
  if (polarViewBox) {
    return inRangeOfSector({
      x: x2,
      y: y2
    }, polarViewBox);
  }
  return null;
}
const getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {
  const entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
  if (entry) {
    if (layout === "horizontal") {
      return {
        x: entry.coordinate,
        y: rangeObj.y
      };
    }
    if (layout === "vertical") {
      return {
        x: rangeObj.x,
        y: entry.coordinate
      };
    }
    if (layout === "centric") {
      const _angle = entry.coordinate;
      const {
        radius: _radius
      } = rangeObj;
      return _objectSpread4(_objectSpread4(_objectSpread4({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
        angle: _angle,
        radius: _radius
      });
    }
    const radius = entry.coordinate;
    const {
      angle
    } = rangeObj;
    return _objectSpread4(_objectSpread4(_objectSpread4({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
      angle,
      radius
    });
  }
  return {
    x: 0,
    y: 0
  };
};
const calculateTooltipPos = (rangeObj, layout) => {
  if (layout === "horizontal") {
    return rangeObj.x;
  }
  if (layout === "vertical") {
    return rangeObj.y;
  }
  if (layout === "centric") {
    return rangeObj.angle;
  }
  return rangeObj.radius;
};

// node_modules/recharts/es6/state/selectors/containerSelectors.js
const selectChartWidth = (state) => state.layout.width;
const selectChartHeight = (state) => state.layout.height;
const selectContainerScale = (state) => state.layout.scale;
const selectMargin = (state) => state.layout.margin;

// node_modules/recharts/es6/state/selectors/selectAllAxes.js
const selectAllXAxes = createSelector((state) => state.cartesianAxis.xAxis, (xAxisMap) => {
  return Object.values(xAxisMap);
});
const selectAllYAxes = createSelector((state) => state.cartesianAxis.yAxis, (yAxisMap) => {
  return Object.values(yAxisMap);
});

// node_modules/recharts/es6/util/Constants.js
const COLOR_PANEL = ["#1890FF", "#66B5FF", "#41D9C7", "#2FC25B", "#6EDB8F", "#9AE65C", "#FACC14", "#E6965C", "#57AD71", "#223273", "#738AE6", "#7564CC", "#8543E0", "#A877ED", "#5C8EE6", "#13C2C2", "#70E0E0", "#5CA3E6", "#3436C7", "#8082FF", "#DD81E6", "#F04864", "#FA7D92", "#D598D9"];
const DATA_ITEM_INDEX_ATTRIBUTE_NAME = "data-recharts-item-index";
const DATA_ITEM_DATAKEY_ATTRIBUTE_NAME = "data-recharts-item-data-key";
const DEFAULT_Y_AXIS_WIDTH = 60;

// node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js
function ownKeys5(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty5(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty5(e, r, t) {
  return (r = _toPropertyKey5(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey5(t) {
  const i = _toPrimitive5(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive5(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const selectBrushHeight = (state) => state.brush.height;
function selectLeftAxesOffset(state) {
  const yAxes = selectAllYAxes(state);
  return yAxes.reduce((result, entry) => {
    if (entry.orientation === "left" && !entry.mirror && !entry.hide) {
      const width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
      return result + width;
    }
    return result;
  }, 0);
}
function selectRightAxesOffset(state) {
  const yAxes = selectAllYAxes(state);
  return yAxes.reduce((result, entry) => {
    if (entry.orientation === "right" && !entry.mirror && !entry.hide) {
      const width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
      return result + width;
    }
    return result;
  }, 0);
}
function selectTopAxesOffset(state) {
  const xAxes = selectAllXAxes(state);
  return xAxes.reduce((result, entry) => {
    if (entry.orientation === "top" && !entry.mirror && !entry.hide) {
      return result + entry.height;
    }
    return result;
  }, 0);
}
function selectBottomAxesOffset(state) {
  const xAxes = selectAllXAxes(state);
  return xAxes.reduce((result, entry) => {
    if (entry.orientation === "bottom" && !entry.mirror && !entry.hide) {
      return result + entry.height;
    }
    return result;
  }, 0);
}
const selectChartOffsetInternal = createSelector([selectChartWidth, selectChartHeight, selectMargin, selectBrushHeight, selectLeftAxesOffset, selectRightAxesOffset, selectTopAxesOffset, selectBottomAxesOffset, selectLegendSettings, selectLegendSize], (chartWidth, chartHeight, margin, brushHeight, leftAxesOffset, rightAxesOffset, topAxesOffset, bottomAxesOffset, legendSettings, legendSize) => {
  const offsetH = {
    left: (margin.left || 0) + leftAxesOffset,
    right: (margin.right || 0) + rightAxesOffset
  };
  const offsetV = {
    top: (margin.top || 0) + topAxesOffset,
    bottom: (margin.bottom || 0) + bottomAxesOffset
  };
  let offset = _objectSpread5(_objectSpread5({}, offsetV), offsetH);
  const brushBottom = offset.bottom;
  offset.bottom += brushHeight;
  offset = appendOffsetOfLegend(offset, legendSettings, legendSize);
  const offsetWidth = chartWidth - offset.left - offset.right;
  const offsetHeight = chartHeight - offset.top - offset.bottom;
  return _objectSpread5(_objectSpread5({
    brushBottom
  }, offset), {}, {
    // never return negative values for height and width
    width: Math.max(offsetWidth, 0),
    height: Math.max(offsetHeight, 0)
  });
});
const selectChartViewBox = createSelector(selectChartOffsetInternal, (offset) => ({
  x: offset.left,
  y: offset.top,
  width: offset.width,
  height: offset.height
}));
const selectAxisViewBox = createSelector(selectChartWidth, selectChartHeight, (width, height) => ({
  x: 0,
  y: 0,
  width,
  height
}));

// node_modules/recharts/es6/context/PanoramaContext.js
const React5 = __toESM(require_react());
const import_react10 = __toESM(require_react());
const PanoramaContext = (0, import_react10.createContext)(null);
const useIsPanorama = () => (0, import_react10.useContext)(PanoramaContext) != null;
const PanoramaContextProvider = (_ref2) => {
  const {
    children
  } = _ref2;
  return React5.createElement(PanoramaContext.Provider, {
    value: true
  }, children);
};

// node_modules/recharts/es6/state/selectors/brushSelectors.js
const selectBrushSettings = (state) => state.brush;
const selectBrushDimensions = createSelector([selectBrushSettings, selectChartOffsetInternal, selectMargin], (brushSettings, offset, margin) => ({
  height: brushSettings.height,
  x: isNumber(brushSettings.x) ? brushSettings.x : offset.left,
  y: isNumber(brushSettings.y) ? brushSettings.y : offset.top + offset.height + offset.brushBottom - ((margin === null || margin === void 0 ? void 0 : margin.bottom) || 0),
  width: isNumber(brushSettings.width) ? brushSettings.width : offset.width
}));

// node_modules/recharts/es6/context/chartLayoutContext.js
const useViewBox = () => {
  let _useAppSelector;
  const panorama = useIsPanorama();
  const rootViewBox = useAppSelector(selectChartViewBox);
  const brushDimensions = useAppSelector(selectBrushDimensions);
  const brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
  if (!panorama || !brushDimensions || !brushPadding) {
    return rootViewBox;
  }
  return {
    width: brushDimensions.width - brushPadding.left - brushPadding.right,
    height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
    x: brushPadding.left,
    y: brushPadding.top
  };
};
const manyComponentsThrowErrorsIfOffsetIsUndefined = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  width: 0,
  height: 0,
  brushBottom: 0
};
const useOffsetInternal = () => {
  let _useAppSelector2;
  return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
};
const useChartWidth = () => {
  return useAppSelector(selectChartWidth);
};
const useChartHeight = () => {
  return useAppSelector(selectChartHeight);
};
const useMargin = () => {
  return useAppSelector((state) => state.layout.margin);
};
const selectChartLayout = (state) => state.layout.layoutType;
const useChartLayout = () => useAppSelector(selectChartLayout);
const ReportChartSize = (props) => {
  const dispatch = useAppDispatch();
  (0, import_react11.useEffect)(() => {
    dispatch(setChartSize(props));
  }, [dispatch, props]);
  return null;
};
const ReportChartMargin = (_ref2) => {
  const {
    margin
  } = _ref2;
  const dispatch = useAppDispatch();
  (0, import_react11.useEffect)(() => {
    dispatch(setMargin(margin));
  }, [dispatch, margin]);
  return null;
};

// node_modules/recharts/es6/state/legendSlice.js
const initialState2 = {
  settings: {
    layout: "horizontal",
    align: "center",
    verticalAlign: "middle",
    itemSorter: "value"
  },
  size: {
    width: 0,
    height: 0
  },
  payload: []
};
const legendSlice = createSlice({
  name: "legend",
  initialState: initialState2,
  reducers: {
    setLegendSize(state, action) {
      state.size.width = action.payload.width;
      state.size.height = action.payload.height;
    },
    setLegendSettings(state, action) {
      state.settings.align = action.payload.align;
      state.settings.layout = action.payload.layout;
      state.settings.verticalAlign = action.payload.verticalAlign;
      state.settings.itemSorter = action.payload.itemSorter;
    },
    addLegendPayload(state, action) {
      state.payload.push(castDraft(action.payload));
    },
    removeLegendPayload(state, action) {
      const index2 = current(state).payload.indexOf(castDraft(action.payload));
      if (index2 > -1) {
        state.payload.splice(index2, 1);
      }
    }
  }
});
const {
  setLegendSize,
  setLegendSettings,
  addLegendPayload,
  removeLegendPayload
} = legendSlice.actions;
const legendReducer = legendSlice.reducer;

// node_modules/recharts/es6/component/Legend.js
const _excluded4 = ["contextPayload"];
function _extends5() {
  return _extends5 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends5.apply(null, arguments);
}
function ownKeys6(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty6(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty6(e, r, t) {
  return (r = _toPropertyKey6(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey6(t) {
  const i = _toPrimitive6(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive6(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties4(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose4(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose4(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function defaultUniqBy(entry) {
  return entry.value;
}
function LegendContent(props) {
  let {
    contextPayload
  } = props, otherProps = _objectWithoutProperties4(props, _excluded4);
  const finalPayload = getUniqPayload(contextPayload, props.payloadUniqBy, defaultUniqBy);
  const contentProps = _objectSpread6(_objectSpread6({}, otherProps), {}, {
    payload: finalPayload
  });
  if (React6.isValidElement(props.content)) {
    return React6.cloneElement(props.content, contentProps);
  }
  if (typeof props.content === "function") {
    return React6.createElement(props.content, contentProps);
  }
  return React6.createElement(DefaultLegendContent, contentProps);
}
function getDefaultPosition(style, props, margin, chartWidth, chartHeight, box) {
  const {
    layout,
    align,
    verticalAlign
  } = props;
  let hPos, vPos;
  if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
    if (align === "center" && layout === "vertical") {
      hPos = {
        left: ((chartWidth || 0) - box.width) / 2
      };
    } else {
      hPos = align === "right" ? {
        right: margin && margin.right || 0
      } : {
        left: margin && margin.left || 0
      };
    }
  }
  if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
    if (verticalAlign === "middle") {
      vPos = {
        top: ((chartHeight || 0) - box.height) / 2
      };
    } else {
      vPos = verticalAlign === "bottom" ? {
        bottom: margin && margin.bottom || 0
      } : {
        top: margin && margin.top || 0
      };
    }
  }
  return _objectSpread6(_objectSpread6({}, hPos), vPos);
}
function LegendSettingsDispatcher(props) {
  const dispatch = useAppDispatch();
  (0, import_react12.useEffect)(() => {
    dispatch(setLegendSettings(props));
  }, [dispatch, props]);
  return null;
}
function LegendSizeDispatcher(props) {
  const dispatch = useAppDispatch();
  (0, import_react12.useEffect)(() => {
    dispatch(setLegendSize(props));
    return () => {
      dispatch(setLegendSize({
        width: 0,
        height: 0
      }));
    };
  }, [dispatch, props]);
  return null;
}
function LegendWrapper(props) {
  const contextPayload = useLegendPayload();
  const legendPortalFromContext = useLegendPortal();
  const margin = useMargin();
  const {
    width: widthFromProps,
    height: heightFromProps,
    wrapperStyle,
    portal: portalFromProps
  } = props;
  const [lastBoundingBox, updateBoundingBox] = useElementOffset([contextPayload]);
  const chartWidth = useChartWidth();
  const chartHeight = useChartHeight();
  if (chartWidth == null || chartHeight == null) {
    return null;
  }
  const maxWidth = chartWidth - (margin.left || 0) - (margin.right || 0);
  const widthOrHeight = Legend.getWidthOrHeight(props.layout, heightFromProps, widthFromProps, maxWidth);
  const outerStyle = portalFromProps ? wrapperStyle : _objectSpread6(_objectSpread6({
    position: "absolute",
    width: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.width) || widthFromProps || "auto",
    height: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.height) || heightFromProps || "auto"
  }, getDefaultPosition(wrapperStyle, props, margin, chartWidth, chartHeight, lastBoundingBox)), wrapperStyle);
  const legendPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : legendPortalFromContext;
  if (legendPortal == null) {
    return null;
  }
  const legendElement = React6.createElement("div", {
    className: "recharts-legend-wrapper",
    style: outerStyle,
    ref: updateBoundingBox
  }, React6.createElement(LegendSettingsDispatcher, {
    layout: props.layout,
    align: props.align,
    verticalAlign: props.verticalAlign,
    itemSorter: props.itemSorter
  }), React6.createElement(LegendSizeDispatcher, {
    width: lastBoundingBox.width,
    height: lastBoundingBox.height
  }), React6.createElement(LegendContent, _extends5({}, props, widthOrHeight, {
    margin,
    chartWidth,
    chartHeight,
    contextPayload
  })));
  return (0, import_react_dom.createPortal)(legendElement, legendPortal);
}
var Legend = class extends import_react12.PureComponent {
  static getWidthOrHeight(layout, height, width, maxWidth) {
    if (layout === "vertical" && isNumber(height)) {
      return {
        height
      };
    }
    if (layout === "horizontal") {
      return {
        width: width || maxWidth
      };
    }
    return null;
  }
  render() {
    return React6.createElement(LegendWrapper, this.props);
  }
};
_defineProperty6(Legend, "displayName", "Legend");
_defineProperty6(Legend, "defaultProps", {
  align: "center",
  iconSize: 14,
  itemSorter: "value",
  layout: "horizontal",
  verticalAlign: "bottom"
});

// node_modules/recharts/es6/component/Tooltip.js
const React14 = __toESM(require_react());
const import_react21 = __toESM(require_react());
const import_react_dom2 = __toESM(require_react_dom());

// node_modules/recharts/es6/component/DefaultTooltipContent.js
const React7 = __toESM(require_react());
const import_sortBy3 = __toESM(require_sortBy2());
function _extends6() {
  return _extends6 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends6.apply(null, arguments);
}
function ownKeys7(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread7(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
      _defineProperty7(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty7(e, r, t) {
  return (r = _toPropertyKey7(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey7(t) {
  const i = _toPrimitive7(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive7(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function defaultFormatter(value) {
  return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
const DefaultTooltipContent = (props) => {
  const {
    separator = " : ",
    contentStyle = {},
    itemStyle = {},
    labelStyle = {},
    payload,
    formatter,
    itemSorter,
    wrapperClassName,
    labelClassName,
    label,
    labelFormatter,
    accessibilityLayer = false
  } = props;
  const renderContent2 = () => {
    if (payload && payload.length) {
      const listStyle = {
        padding: 0,
        margin: 0
      };
      const items = (itemSorter ? (0, import_sortBy3.default)(payload, itemSorter) : payload).map((entry, i) => {
        if (entry.type === "none") {
          return null;
        }
        const finalFormatter = entry.formatter || formatter || defaultFormatter;
        const {
          value,
          name
        } = entry;
        let finalValue = value;
        let finalName = name;
        if (finalFormatter) {
          const formatted = finalFormatter(value, name, entry, i, payload);
          if (Array.isArray(formatted)) {
            [finalValue, finalName] = formatted;
          } else if (formatted != null) {
            finalValue = formatted;
          } else {
            return null;
          }
        }
        const finalItemStyle = _objectSpread7({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: entry.color || "#000"
        }, itemStyle);
        return (
          // eslint-disable-next-line react/no-array-index-key
          React7.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(i),
            style: finalItemStyle
          }, isNumOrStr(finalName) ? React7.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, finalName) : null, isNumOrStr(finalName) ? React7.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, separator) : null, React7.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, finalValue), React7.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, entry.unit || ""))
        );
      });
      return React7.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: listStyle
      }, items);
    }
    return null;
  };
  const finalStyle = _objectSpread7({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, contentStyle);
  const finalLabelStyle = _objectSpread7({
    margin: 0
  }, labelStyle);
  const hasLabel = !isNullish(label);
  let finalLabel = hasLabel ? label : "";
  const wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
  const labelCN = clsx("recharts-tooltip-label", labelClassName);
  if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
    finalLabel = labelFormatter(label, payload);
  }
  const accessibilityAttributes = accessibilityLayer ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return React7.createElement("div", _extends6({
    className: wrapperCN,
    style: finalStyle
  }, accessibilityAttributes), React7.createElement("p", {
    className: labelCN,
    style: finalLabelStyle
  }, React7.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent2());
};

// node_modules/recharts/es6/component/TooltipBoundingBox.js
const React8 = __toESM(require_react());
const import_react13 = __toESM(require_react());

// node_modules/recharts/es6/util/tooltip/translate.js
const CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
const TOOLTIP_HIDDEN = {
  visibility: "hidden"
};
function getTooltipCSSClassName(_ref2) {
  const {
    coordinate,
    translateX,
    translateY
  } = _ref2;
  return clsx(CSS_CLASS_PREFIX, {
    ["".concat(CSS_CLASS_PREFIX, "-right")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x,
    ["".concat(CSS_CLASS_PREFIX, "-left")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x,
    ["".concat(CSS_CLASS_PREFIX, "-bottom")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y,
    ["".concat(CSS_CLASS_PREFIX, "-top")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y
  });
}
function getTooltipTranslateXY(_ref2) {
  const {
    allowEscapeViewBox,
    coordinate,
    key,
    offsetTopLeft,
    position: position2,
    reverseDirection,
    tooltipDimension,
    viewBox,
    viewBoxDimension
  } = _ref2;
  if (position2 && isNumber(position2[key])) {
    return position2[key];
  }
  const negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0);
  const positive = coordinate[key] + offsetTopLeft;
  if (allowEscapeViewBox[key]) {
    return reverseDirection[key] ? negative : positive;
  }
  const viewBoxKey = viewBox[key];
  if (viewBoxKey == null) {
    return 0;
  }
  if (reverseDirection[key]) {
    const _tooltipBoundary = negative;
    const _viewBoxBoundary = viewBoxKey;
    if (_tooltipBoundary < _viewBoxBoundary) {
      return Math.max(positive, viewBoxKey);
    }
    return Math.max(negative, viewBoxKey);
  }
  if (viewBoxDimension == null) {
    return 0;
  }
  const tooltipBoundary = positive + tooltipDimension;
  const viewBoxBoundary = viewBoxKey + viewBoxDimension;
  if (tooltipBoundary > viewBoxBoundary) {
    return Math.max(negative, viewBoxKey);
  }
  return Math.max(positive, viewBoxKey);
}
function getTransformStyle(_ref3) {
  const {
    translateX,
    translateY,
    useTranslate3d
  } = _ref3;
  return {
    transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
  };
}
function getTooltipTranslate(_ref4) {
  const {
    allowEscapeViewBox,
    coordinate,
    offsetTopLeft,
    position: position2,
    reverseDirection,
    tooltipBox,
    useTranslate3d,
    viewBox
  } = _ref4;
  let cssProperties, translateX, translateY;
  if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
    translateX = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "x",
      offsetTopLeft,
      position: position2,
      reverseDirection,
      tooltipDimension: tooltipBox.width,
      viewBox,
      viewBoxDimension: viewBox.width
    });
    translateY = getTooltipTranslateXY({
      allowEscapeViewBox,
      coordinate,
      key: "y",
      offsetTopLeft,
      position: position2,
      reverseDirection,
      tooltipDimension: tooltipBox.height,
      viewBox,
      viewBoxDimension: viewBox.height
    });
    cssProperties = getTransformStyle({
      translateX,
      translateY,
      useTranslate3d
    });
  } else {
    cssProperties = TOOLTIP_HIDDEN;
  }
  return {
    cssProperties,
    cssClasses: getTooltipCSSClassName({
      translateX,
      translateY,
      coordinate
    })
  };
}

// node_modules/recharts/es6/component/TooltipBoundingBox.js
function ownKeys8(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread8(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys8(Object(t), true).forEach(function(r2) {
      _defineProperty8(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty8(e, r, t) {
  return (r = _toPropertyKey8(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey8(t) {
  const i = _toPrimitive8(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive8(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const TooltipBoundingBox = class extends import_react13.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty8(this, "state", {
      dismissed: false,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    });
    _defineProperty8(this, "handleKeyDown", (event) => {
      if (event.key === "Escape") {
        let _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
        this.setState({
          dismissed: true,
          dismissedAtCoordinate: {
            x: (_this$props$coordinat = (_this$props$coordinat2 = this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
            y: (_this$props$coordinat3 = (_this$props$coordinat4 = this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
          }
        });
      }
    });
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleKeyDown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  componentDidUpdate() {
    let _this$props$coordinat5, _this$props$coordinat6;
    if (!this.state.dismissed) {
      return;
    }
    if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) {
      this.state.dismissed = false;
    }
  }
  render() {
    const {
      active,
      allowEscapeViewBox,
      animationDuration,
      animationEasing,
      children,
      coordinate,
      hasPayload,
      isAnimationActive,
      offset,
      position: position2,
      reverseDirection,
      useTranslate3d,
      viewBox,
      wrapperStyle,
      lastBoundingBox,
      innerRef,
      hasPortalFromProps
    } = this.props;
    const {
      cssClasses,
      cssProperties
    } = getTooltipTranslate({
      allowEscapeViewBox,
      coordinate,
      offsetTopLeft: offset,
      position: position2,
      reverseDirection,
      tooltipBox: {
        height: lastBoundingBox.height,
        width: lastBoundingBox.width
      },
      useTranslate3d,
      viewBox
    });
    const positionStyles = hasPortalFromProps ? {} : _objectSpread8(_objectSpread8({
      transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0
    }, cssProperties), {}, {
      pointerEvents: "none",
      visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
      position: "absolute",
      top: 0,
      left: 0
    });
    const outerStyle = _objectSpread8(_objectSpread8({}, positionStyles), {}, {
      visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden"
    }, wrapperStyle);
    return (
      // This element allow listening to the `Escape` key. See https://github.com/recharts/recharts/pull/2925
      React8.createElement("div", {
        // @ts-expect-error typescript library does not recognize xmlns attribute, but it's required for an HTML chunk inside SVG.
        xmlns: "http://www.w3.org/1999/xhtml",
        tabIndex: -1,
        className: cssClasses,
        style: outerStyle,
        ref: innerRef
      }, children)
    );
  }
};

// node_modules/recharts/es6/util/Global.js
const parseIsSsrByDefault = () => !(typeof window !== "undefined" && window.document && Boolean(window.document.createElement) && window.setTimeout);
const Global = {
  devToolsEnabled: false,
  isSsr: parseIsSsrByDefault()
};

// node_modules/recharts/es6/context/accessibilityContext.js
const useAccessibilityLayer = () => useAppSelector((state) => state.rootProps.accessibilityLayer);

// node_modules/recharts/es6/component/Cursor.js
const React13 = __toESM(require_react());
const import_react18 = __toESM(require_react());

// node_modules/recharts/es6/shape/Curve.js
const React9 = __toESM(require_react());

// node_modules/recharts/es6/util/isWellBehavedNumber.js
function isWellBehavedNumber(n) {
  return Number.isFinite(n);
}
function isPositiveNumber(n) {
  return typeof n === "number" && n > 0 && Number.isFinite(n);
}

// node_modules/recharts/es6/shape/Curve.js
function _extends7() {
  return _extends7 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends7.apply(null, arguments);
}
function ownKeys9(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread9(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys9(Object(t), true).forEach(function(r2) {
      _defineProperty9(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty9(e, r, t) {
  return (r = _toPropertyKey9(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey9(t) {
  const i = _toPrimitive9(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive9(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const CURVE_FACTORIES = {
  curveBasisClosed: basisClosed_default,
  curveBasisOpen: basisOpen_default,
  curveBasis: basis_default,
  curveBumpX: bumpX,
  curveBumpY: bumpY,
  curveLinearClosed: linearClosed_default,
  curveLinear: linear_default,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural: natural_default,
  curveStep: step_default,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
const defined = (p) => isWellBehavedNumber(p.x) && isWellBehavedNumber(p.y);
const getX = (p) => p.x;
const getY = (p) => p.y;
const getCurveFactory = (type, layout) => {
  if (typeof type === "function") {
    return type;
  }
  const name = "curve".concat(upperFirst(type));
  if ((name === "curveMonotone" || name === "curveBump") && layout) {
    return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
  }
  return CURVE_FACTORIES[name] || linear_default;
};
const getPath = (_ref2) => {
  const {
    type = "linear",
    points = [],
    baseLine,
    layout,
    connectNulls = false
  } = _ref2;
  const curveFactory = getCurveFactory(type, layout);
  const formatPoints = connectNulls ? points.filter(defined) : points;
  let lineFunction;
  if (Array.isArray(baseLine)) {
    const formatBaseLine = connectNulls ? baseLine.filter((base) => defined(base)) : baseLine;
    const areaPoints = formatPoints.map((entry, index2) => _objectSpread9(_objectSpread9({}, entry), {}, {
      base: formatBaseLine[index2]
    }));
    if (layout === "vertical") {
      lineFunction = area_default().y(getY).x1(getX).x0((d) => d.base.x);
    } else {
      lineFunction = area_default().x(getX).y1(getY).y0((d) => d.base.y);
    }
    lineFunction.defined(defined).curve(curveFactory);
    return lineFunction(areaPoints);
  }
  if (layout === "vertical" && isNumber(baseLine)) {
    lineFunction = area_default().y(getY).x1(getX).x0(baseLine);
  } else if (isNumber(baseLine)) {
    lineFunction = area_default().x(getX).y1(getY).y0(baseLine);
  } else {
    lineFunction = line_default().x(getX).y(getY);
  }
  lineFunction.defined(defined).curve(curveFactory);
  return lineFunction(formatPoints);
};
const Curve = (props) => {
  const {
    className,
    points,
    path: path2,
    pathRef
  } = props;
  if ((!points || !points.length) && !path2) {
    return null;
  }
  const realPath = points && points.length ? getPath(props) : path2;
  return React9.createElement("path", _extends7({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
    className: clsx("recharts-curve", className),
    d: realPath === null ? void 0 : realPath,
    ref: pathRef
  }));
};

// node_modules/recharts/es6/shape/Cross.js
const React10 = __toESM(require_react());
const _excluded5 = ["x", "y", "top", "left", "width", "height", "className"];
function _extends8() {
  return _extends8 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends8.apply(null, arguments);
}
function ownKeys10(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread10(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys10(Object(t), true).forEach(function(r2) {
      _defineProperty10(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys10(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty10(e, r, t) {
  return (r = _toPropertyKey10(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey10(t) {
  const i = _toPrimitive10(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive10(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties5(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose5(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose5(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const getPath2 = (x2, y2, width, height, top, left) => {
  return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
};
const Cross = (_ref2) => {
  let {
    x: x2 = 0,
    y: y2 = 0,
    top = 0,
    left = 0,
    width = 0,
    height = 0,
    className
  } = _ref2, rest2 = _objectWithoutProperties5(_ref2, _excluded5);
  const props = _objectSpread10({
    x: x2,
    y: y2,
    top,
    left,
    width,
    height
  }, rest2);
  if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
    return null;
  }
  return React10.createElement("path", _extends8({}, filterProps(props, true), {
    className: clsx("recharts-cross", className),
    d: getPath2(x2, y2, width, height, top, left)
  }));
};

// node_modules/recharts/es6/util/cursor/getCursorRectangle.js
function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
  const halfSize = tooltipAxisBandSize / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
    y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
    width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
    height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
  };
}

// node_modules/recharts/es6/shape/Rectangle.js
const React11 = __toESM(require_react());
const import_react17 = __toESM(require_react());

// node_modules/recharts/es6/util/resolveDefaultProps.js
function ownKeys11(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread11(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys11(Object(t), true).forEach(function(r2) {
      _defineProperty11(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys11(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty11(e, r, t) {
  return (r = _toPropertyKey11(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey11(t) {
  const i = _toPrimitive11(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive11(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function resolveDefaultProps(realProps, defaultProps11) {
  const resolvedProps = _objectSpread11({}, realProps);
  const dp = defaultProps11;
  const keys = Object.keys(defaultProps11);
  const withDefaults = keys.reduce((acc, key) => {
    if (acc[key] === void 0 && dp[key] !== void 0) {
      acc[key] = dp[key];
    }
    return acc;
  }, resolvedProps);
  return withDefaults;
}

// node_modules/recharts/es6/animation/JavascriptAnimate.js
const import_react15 = __toESM(require_react());

// node_modules/es-toolkit/dist/function/noop.mjs
function noop3() {
}

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol = Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2 = Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// node_modules/es-toolkit/dist/function/retry.mjs
const DEFAULT_RETRIES = Number.POSITIVE_INFINITY;

// node_modules/es-toolkit/dist/string/words.mjs
const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// node_modules/es-toolkit/dist/string/deburr.mjs
const deburrMap = new Map(Object.entries({
  : "Ae",
  : "D",
  : "O",
  : "Th",
  : "ss",
  : "ae",
  : "d",
  : "o",
  : "th",
  : "D",
  : "d",
  : "H",
  : "h",
  : "i",
  : "IJ",
  : "ij",
  : "k",
  : "L",
  : "l",
  : "L",
  : "l",
  : "'n",
  : "N",
  : "n",
  : "Oe",
  : "oe",
  : "T",
  : "t",
  : "s"
}));

// node_modules/recharts/es6/animation/util.js
function ownKeys12(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread12(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys12(Object(t), true).forEach(function(r2) {
      _defineProperty12(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys12(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty12(e, r, t) {
  return (r = _toPropertyKey12(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey12(t) {
  const i = _toPrimitive12(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive12(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const getDashCase = (name) => name.replace(/([A-Z])/g, (v) => "-".concat(v.toLowerCase()));
const getTransitionVal = (props, duration, easing) => props.map((prop) => "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing)).join(",");
const getIntersectionKeys = (preObj, nextObj) => [Object.keys(preObj), Object.keys(nextObj)].reduce((a2, b) => a2.filter((c2) => b.includes(c2)));
const mapObject = (fn, obj) => Object.keys(obj).reduce((res, key) => _objectSpread12(_objectSpread12({}, res), {}, {
  [key]: fn(key, obj[key])
}), {});

// node_modules/recharts/es6/animation/configUpdate.js
function ownKeys13(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread13(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys13(Object(t), true).forEach(function(r2) {
      _defineProperty13(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys13(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty13(e, r, t) {
  return (r = _toPropertyKey13(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey13(t) {
  const i = _toPrimitive13(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive13(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const alpha = (begin, end, k2) => begin + (end - begin) * k2;
const needContinue = (_ref2) => {
  const {
    from: from2,
    to: to2
  } = _ref2;
  return from2 !== to2;
};
const calStepperVals = (easing, preVals, steps) => {
  const nextStepVals = mapObject((key, val) => {
    if (needContinue(val)) {
      const [newX, newV] = easing(val.from, val.to, val.velocity);
      return _objectSpread13(_objectSpread13({}, val), {}, {
        from: newX,
        velocity: newV
      });
    }
    return val;
  }, preVals);
  if (steps < 1) {
    return mapObject((key, val) => {
      if (needContinue(val)) {
        return _objectSpread13(_objectSpread13({}, val), {}, {
          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
          from: alpha(val.from, nextStepVals[key].from, steps)
        });
      }
      return val;
    }, preVals);
  }
  return calStepperVals(easing, nextStepVals, steps - 1);
};
function createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) {
  let preTime;
  let stepperStyle = interKeys.reduce((res, key) => _objectSpread13(_objectSpread13({}, res), {}, {
    [key]: {
      from: from2[key],
      velocity: 0,
      to: to2[key]
    }
  }), {});
  const getCurrStyle = () => mapObject((key, val) => val.from, stepperStyle);
  const shouldStopAnimation = () => !Object.values(stepperStyle).filter(needContinue).length;
  let stopAnimation = null;
  const stepperUpdate = (now) => {
    if (!preTime) {
      preTime = now;
    }
    const deltaTime = now - preTime;
    const steps = deltaTime / easing.dt;
    stepperStyle = calStepperVals(easing, stepperStyle, steps);
    render(_objectSpread13(_objectSpread13(_objectSpread13({}, from2), to2), getCurrStyle()));
    preTime = now;
    if (!shouldStopAnimation()) {
      stopAnimation = timeoutController.setTimeout(stepperUpdate);
    }
  };
  return () => {
    stopAnimation = timeoutController.setTimeout(stepperUpdate);
    return () => {
      stopAnimation();
    };
  };
}
function createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController) {
  let stopAnimation = null;
  const timingStyle = interKeys.reduce((res, key) => _objectSpread13(_objectSpread13({}, res), {}, {
    [key]: [from2[key], to2[key]]
  }), {});
  let beginTime;
  const timingUpdate = (now) => {
    if (!beginTime) {
      beginTime = now;
    }
    const t = (now - beginTime) / duration;
    const currStyle = mapObject((key, val) => alpha(...val, easing(t)), timingStyle);
    render(_objectSpread13(_objectSpread13(_objectSpread13({}, from2), to2), currStyle));
    if (t < 1) {
      stopAnimation = timeoutController.setTimeout(timingUpdate);
    } else {
      const finalStyle = mapObject((key, val) => alpha(...val, easing(1)), timingStyle);
      render(_objectSpread13(_objectSpread13(_objectSpread13({}, from2), to2), finalStyle));
    }
  };
  return () => {
    stopAnimation = timeoutController.setTimeout(timingUpdate);
    return () => {
      stopAnimation();
    };
  };
}
const configUpdate_default = (from2, to2, easing, duration, render, timeoutController) => {
  const interKeys = getIntersectionKeys(from2, to2);
  return easing.isStepper === true ? createStepperUpdate(from2, to2, easing, interKeys, render, timeoutController) : createTimingUpdate(from2, to2, easing, duration, interKeys, render, timeoutController);
};

// node_modules/recharts/es6/animation/easing.js
const ACCURACY = 1e-4;
const cubicBezierFactor = (c1, c2) => [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
const evaluatePolynomial = (params, t) => params.map((param, i) => param * t ** i).reduce((pre, curr) => pre + curr);
const cubicBezier = (c1, c2) => (t) => {
  const params = cubicBezierFactor(c1, c2);
  return evaluatePolynomial(params, t);
};
const derivativeCubicBezier = (c1, c2) => (t) => {
  const params = cubicBezierFactor(c1, c2);
  const newParams = [...params.map((param, i) => param * i).slice(1), 0];
  return evaluatePolynomial(newParams, t);
};
const configBezier = function configBezier2() {
  let x1, x2, y1, y2;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 1) {
    switch (args[0]) {
      case "linear":
        [x1, y1, x2, y2] = [0, 0, 1, 1];
        break;
      case "ease":
        [x1, y1, x2, y2] = [0.25, 0.1, 0.25, 1];
        break;
      case "ease-in":
        [x1, y1, x2, y2] = [0.42, 0, 1, 1];
        break;
      case "ease-out":
        [x1, y1, x2, y2] = [0.42, 0, 0.58, 1];
        break;
      case "ease-in-out":
        [x1, y1, x2, y2] = [0, 0, 0.58, 1];
        break;
      default: {
        const easing = args[0].split("(");
        if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
          [x1, y1, x2, y2] = easing[1].split(")")[0].split(",").map((x3) => parseFloat(x3));
        }
      }
    }
  } else if (args.length === 4) {
    [x1, y1, x2, y2] = args;
  }
  const curveX = cubicBezier(x1, x2);
  const curveY = cubicBezier(y1, y2);
  const derCurveX = derivativeCubicBezier(x1, x2);
  const rangeValue = (value) => {
    if (value > 1) {
      return 1;
    }
    if (value < 0) {
      return 0;
    }
    return value;
  };
  const bezier = (_t) => {
    const t = _t > 1 ? 1 : _t;
    let x3 = t;
    for (let i = 0; i < 8; ++i) {
      const evalT = curveX(x3) - t;
      const derVal = derCurveX(x3);
      if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) {
        return curveY(x3);
      }
      x3 = rangeValue(x3 - evalT / derVal);
    }
    return curveY(x3);
  };
  bezier.isStepper = false;
  return bezier;
};
const configSpring = function configSpring2() {
  const config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    stiff = 100,
    damping = 8,
    dt = 17
  } = config2;
  const stepper = (currX, destX, currV) => {
    const FSpring = -(currX - destX) * stiff;
    const FDamping = currV * damping;
    const newV = currV + (FSpring - FDamping) * dt / 1e3;
    const newX = currV * dt / 1e3 + currX;
    if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
      return [destX, 0];
    }
    return [newX, newV];
  };
  stepper.isStepper = true;
  stepper.dt = dt;
  return stepper;
};
const configEasing = (easing) => {
  if (typeof easing === "string") {
    switch (easing) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(easing);
      case "spring":
        return configSpring();
      default:
        if (easing.split("(")[0] === "cubic-bezier") {
          return configBezier(easing);
        }
    }
  }
  if (typeof easing === "function") {
    return easing;
  }
  return null;
};

// node_modules/recharts/es6/animation/useAnimationManager.js
const import_react14 = __toESM(require_react());

// node_modules/recharts/es6/animation/AnimationManager.js
function createAnimateManager(timeoutController) {
  let currStyle;
  let handleChange = () => null;
  let shouldStop = false;
  let cancelTimeout = null;
  const setStyle = (_style) => {
    if (shouldStop) {
      return;
    }
    if (Array.isArray(_style)) {
      if (!_style.length) {
        return;
      }
      const styles = _style;
      const [curr, ...restStyles] = styles;
      if (typeof curr === "number") {
        cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles), curr);
        return;
      }
      setStyle(curr);
      cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles));
      return;
    }
    if (typeof _style === "string") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "object") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "function") {
      _style();
    }
  };
  return {
    stop: () => {
      shouldStop = true;
    },
    start: (style) => {
      shouldStop = false;
      if (cancelTimeout) {
        cancelTimeout();
        cancelTimeout = null;
      }
      setStyle(style);
    },
    subscribe: (_handleChange) => {
      handleChange = _handleChange;
      return () => {
        handleChange = () => null;
      };
    },
    getTimeoutController: () => timeoutController
  };
}

// node_modules/recharts/es6/animation/timeoutController.js
const RequestAnimationFrameTimeoutController = class {
  setTimeout(callback) {
    const delay2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const startTime = performance.now();
    let requestId = null;
    const executeCallback = (now) => {
      if (now - startTime >= delay2) {
        callback(now);
      } else if (typeof requestAnimationFrame === "function") {
        requestId = requestAnimationFrame(executeCallback);
      }
    };
    requestId = requestAnimationFrame(executeCallback);
    return () => {
      cancelAnimationFrame(requestId);
    };
  }
};

// node_modules/recharts/es6/animation/createDefaultAnimationManager.js
function createDefaultAnimationManager() {
  return createAnimateManager(new RequestAnimationFrameTimeoutController());
}

// node_modules/recharts/es6/animation/useAnimationManager.js
const AnimationManagerContext = (0, import_react14.createContext)(createDefaultAnimationManager);
function useAnimationManager(animationId, animationManagerFromProps) {
  const contextAnimationManager = (0, import_react14.useContext)(AnimationManagerContext);
  return (0, import_react14.useMemo)(() => animationManagerFromProps !== null && animationManagerFromProps !== void 0 ? animationManagerFromProps : contextAnimationManager(animationId), [animationId, animationManagerFromProps, contextAnimationManager]);
}

// node_modules/recharts/es6/animation/JavascriptAnimate.js
const defaultJavascriptAnimateProps = {
  begin: 0,
  duration: 1e3,
  easing: "ease",
  isActive: true,
  canBegin: true,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
};
const from = {
  t: 0
};
const to = {
  t: 1
};
function JavascriptAnimate(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultJavascriptAnimateProps);
  const {
    isActive,
    canBegin,
    duration,
    easing,
    begin,
    onAnimationEnd,
    onAnimationStart,
    children
  } = props;
  const animationManager = useAnimationManager(props.animationId, props.animationManager);
  const [style, setStyle] = (0, import_react15.useState)(isActive ? from : to);
  const stopJSAnimation = (0, import_react15.useRef)(null);
  (0, import_react15.useEffect)(() => {
    if (!isActive) {
      setStyle(to);
    }
  }, [isActive]);
  (0, import_react15.useEffect)(() => {
    if (!isActive || !canBegin) {
      return noop3;
    }
    const startAnimation = configUpdate_default(from, to, configEasing(easing), duration, setStyle, animationManager.getTimeoutController());
    const onAnimationActive = () => {
      stopJSAnimation.current = startAnimation();
    };
    animationManager.start([onAnimationStart, begin, onAnimationActive, duration, onAnimationEnd]);
    return () => {
      animationManager.stop();
      if (stopJSAnimation.current) {
        stopJSAnimation.current();
      }
      onAnimationEnd();
    };
  }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager]);
  return children(style.t);
}

// node_modules/recharts/es6/util/useAnimationId.js
const import_react16 = __toESM(require_react());
function useAnimationId(input) {
  const prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-";
  const animationId = (0, import_react16.useRef)(uniqueId(prefix2));
  const prevProps = (0, import_react16.useRef)(input);
  if (prevProps.current !== input) {
    animationId.current = uniqueId(prefix2);
    prevProps.current = input;
  }
  return animationId.current;
}

// node_modules/recharts/es6/shape/Rectangle.js
function ownKeys14(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread14(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys14(Object(t), true).forEach(function(r2) {
      _defineProperty14(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys14(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty14(e, r, t) {
  return (r = _toPropertyKey14(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey14(t) {
  const i = _toPrimitive14(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive14(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends9() {
  return _extends9 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends9.apply(null, arguments);
}
const getRectanglePath = (x2, y2, width, height, radius) => {
  const maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
  const ySign = height >= 0 ? 1 : -1;
  const xSign = width >= 0 ? 1 : -1;
  const clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
  let path2;
  if (maxRadius > 0 && radius instanceof Array) {
    const newRadius = [0, 0, 0, 0];
    for (let i = 0, len = 4; i < len; i++) {
      newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
    }
    path2 = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
    if (newRadius[0] > 0) {
      path2 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
    }
    path2 += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
    if (newRadius[1] > 0) {
      path2 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
    }
    path2 += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
    if (newRadius[2] > 0) {
      path2 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
    }
    path2 += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
    if (newRadius[3] > 0) {
      path2 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
    }
    path2 += "Z";
  } else if (maxRadius > 0 && radius === +radius && radius > 0) {
    const _newRadius = Math.min(maxRadius, radius);
    path2 = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
  } else {
    path2 = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
  }
  return path2;
};
const defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: false,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
const Rectangle = (rectangleProps) => {
  const props = resolveDefaultProps(rectangleProps, defaultProps);
  const pathRef = (0, import_react17.useRef)(null);
  const [totalLength, setTotalLength] = (0, import_react17.useState)(-1);
  (0, import_react17.useEffect)(() => {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        const pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (_unused) {
      }
    }
  }, []);
  const {
    x: x2,
    y: y2,
    width,
    height,
    radius,
    className
  } = props;
  const {
    animationEasing,
    animationDuration,
    animationBegin,
    isAnimationActive,
    isUpdateAnimationActive
  } = props;
  const prevWidthRef = (0, import_react17.useRef)(width);
  const prevHeightRef = (0, import_react17.useRef)(height);
  const prevXRef = (0, import_react17.useRef)(x2);
  const prevYRef = (0, import_react17.useRef)(y2);
  const animationIdInput = (0, import_react17.useMemo)(() => ({
    x: x2,
    y: y2,
    width,
    height,
    radius
  }), [x2, y2, width, height, radius]);
  const animationId = useAnimationId(animationIdInput, "rectangle-");
  if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
    return null;
  }
  const layerClass = clsx("recharts-rectangle", className);
  if (!isUpdateAnimationActive) {
    return React11.createElement("path", _extends9({}, filterProps(props, true), {
      className: layerClass,
      d: getRectanglePath(x2, y2, width, height, radius)
    }));
  }
  const prevWidth = prevWidthRef.current;
  const prevHeight = prevHeightRef.current;
  const prevX = prevXRef.current;
  const prevY = prevYRef.current;
  const from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
  const to2 = "".concat(totalLength, "px 0px");
  const transition = getTransitionVal(["strokeDasharray"], animationDuration, typeof animationEasing === "string" ? animationEasing : void 0);
  return React11.createElement(JavascriptAnimate, {
    animationId,
    key: animationId,
    canBegin: totalLength > 0,
    duration: animationDuration,
    easing: animationEasing,
    isActive: isUpdateAnimationActive,
    begin: animationBegin
  }, (t) => {
    const currWidth = interpolate(prevWidth, width, t);
    const currHeight = interpolate(prevHeight, height, t);
    const currX = interpolate(prevX, x2, t);
    const currY = interpolate(prevY, y2, t);
    if (pathRef.current) {
      prevWidthRef.current = currWidth;
      prevHeightRef.current = currHeight;
      prevXRef.current = currX;
      prevYRef.current = currY;
    }
    let animationStyle;
    if (!isAnimationActive) {
      animationStyle = {
        strokeDasharray: to2
      };
    } else if (t > 0) {
      animationStyle = {
        transition,
        strokeDasharray: to2
      };
    } else {
      animationStyle = {
        strokeDasharray: from2
      };
    }
    return React11.createElement("path", _extends9({}, filterProps(props, true), {
      className: layerClass,
      d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
      ref: pathRef,
      style: _objectSpread14(_objectSpread14({}, animationStyle), props.style)
    }));
  });
};

// node_modules/recharts/es6/util/cursor/getRadialCursorPoints.js
function getRadialCursorPoints(activeCoordinate) {
  const {
    cx,
    cy,
    radius,
    startAngle,
    endAngle
  } = activeCoordinate;
  const startPoint = polarToCartesian(cx, cy, radius, startAngle);
  const endPoint = polarToCartesian(cx, cy, radius, endAngle);
  return {
    points: [startPoint, endPoint],
    cx,
    cy,
    radius,
    startAngle,
    endAngle
  };
}

// node_modules/recharts/es6/shape/Sector.js
const React12 = __toESM(require_react());
function _extends10() {
  return _extends10 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends10.apply(null, arguments);
}
const getDeltaAngle = (startAngle, endAngle) => {
  const sign2 = mathSign(endAngle - startAngle);
  const deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
  return sign2 * deltaAngle;
};
const getTangentCircle = (_ref2) => {
  const {
    cx,
    cy,
    radius,
    angle,
    sign: sign2,
    isExternal,
    cornerRadius,
    cornerIsExternal
  } = _ref2;
  const centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
  const theta = Math.asin(cornerRadius / centerRadius) / RADIAN2;
  const centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
  const center = polarToCartesian(cx, cy, centerRadius, centerAngle);
  const circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
  const lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
  const lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN2), lineTangencyAngle);
  return {
    center,
    circleTangency,
    lineTangency,
    theta
  };
};
const getSectorPath = (_ref2) => {
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  } = _ref2;
  const angle = getDeltaAngle(startAngle, endAngle);
  const tempEndAngle = startAngle + angle;
  const outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
  const outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
  let path2 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
  if (innerRadius > 0) {
    const innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
    const innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
    path2 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
  } else {
    path2 += "L ".concat(cx, ",").concat(cy, " Z");
  }
  return path2;
};
const getSectorWithCorner = (_ref3) => {
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    cornerRadius,
    forceCornerRadius,
    cornerIsExternal,
    startAngle,
    endAngle
  } = _ref3;
  const sign2 = mathSign(endAngle - startAngle);
  const {
    circleTangency: soct,
    lineTangency: solt,
    theta: sot
  } = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: startAngle,
    sign: sign2,
    cornerRadius,
    cornerIsExternal
  });
  const {
    circleTangency: eoct,
    lineTangency: eolt,
    theta: eot
  } = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: endAngle,
    sign: -sign2,
    cornerRadius,
    cornerIsExternal
  });
  const outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
  if (outerArcAngle < 0) {
    if (forceCornerRadius) {
      return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
    }
    return getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  let path2 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
  if (innerRadius > 0) {
    const {
      circleTangency: sict,
      lineTangency: silt,
      theta: sit
    } = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: startAngle,
      sign: sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    });
    const {
      circleTangency: eict,
      lineTangency: eilt,
      theta: eit
    } = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: endAngle,
      sign: -sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    });
    const innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
    if (innerArcAngle < 0 && cornerRadius === 0) {
      return "".concat(path2, "L").concat(cx, ",").concat(cy, "Z");
    }
    path2 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
  } else {
    path2 += "L".concat(cx, ",").concat(cy, "Z");
  }
  return path2;
};
const defaultProps2 = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: false,
  cornerIsExternal: false
};
const Sector = (sectorProps) => {
  const props = resolveDefaultProps(sectorProps, defaultProps2);
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    cornerRadius,
    forceCornerRadius,
    cornerIsExternal,
    startAngle,
    endAngle,
    className
  } = props;
  if (outerRadius < innerRadius || startAngle === endAngle) {
    return null;
  }
  const layerClass = clsx("recharts-sector", className);
  const deltaRadius = outerRadius - innerRadius;
  const cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
  let path2;
  if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
    path2 = getSectorWithCorner({
      cx,
      cy,
      innerRadius,
      outerRadius,
      cornerRadius: Math.min(cr, deltaRadius / 2),
      forceCornerRadius,
      cornerIsExternal,
      startAngle,
      endAngle
    });
  } else {
    path2 = getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  return React12.createElement("path", _extends10({}, filterProps(props, true), {
    className: layerClass,
    d: path2
  }));
};

// node_modules/recharts/es6/util/cursor/getCursorPoints.js
function getCursorPoints(layout, activeCoordinate, offset) {
  let x1, y1, x2, y2;
  if (layout === "horizontal") {
    x1 = activeCoordinate.x;
    x2 = x1;
    y1 = offset.top;
    y2 = offset.top + offset.height;
  } else if (layout === "vertical") {
    y1 = activeCoordinate.y;
    y2 = y1;
    x1 = offset.left;
    x2 = offset.left + offset.width;
  } else if (activeCoordinate.cx != null && activeCoordinate.cy != null) {
    if (layout === "centric") {
      const {
        cx,
        cy,
        innerRadius,
        outerRadius,
        angle
      } = activeCoordinate;
      const innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
      const outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
      x1 = innerPoint.x;
      y1 = innerPoint.y;
      x2 = outerPoint.x;
      y2 = outerPoint.y;
    } else {
      return getRadialCursorPoints(activeCoordinate);
    }
  }
  return [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }];
}

// node_modules/recharts/es6/state/selectors/axisSelectors.js
const import_range3 = __toESM(require_range2());

// node_modules/victory-vendor/es/d3-scale.js
const d3_scale_exports = {};
__export(d3_scale_exports, {
  scaleBand: () => band,
  scaleDiverging: () => diverging,
  scaleDivergingLog: () => divergingLog,
  scaleDivergingPow: () => divergingPow,
  scaleDivergingSqrt: () => divergingSqrt,
  scaleDivergingSymlog: () => divergingSymlog,
  scaleIdentity: () => identity5,
  scaleImplicit: () => implicit,
  scaleLinear: () => linear2,
  scaleLog: () => log,
  scaleOrdinal: () => ordinal,
  scalePoint: () => point5,
  scalePow: () => pow,
  scaleQuantile: () => quantile2,
  scaleQuantize: () => quantize,
  scaleRadial: () => radial,
  scaleSequential: () => sequential,
  scaleSequentialLog: () => sequentialLog,
  scaleSequentialPow: () => sequentialPow,
  scaleSequentialQuantile: () => sequentialQuantile,
  scaleSequentialSqrt: () => sequentialSqrt,
  scaleSequentialSymlog: () => sequentialSymlog,
  scaleSqrt: () => sqrt2,
  scaleSymlog: () => symlog,
  scaleThreshold: () => threshold,
  scaleTime: () => time,
  scaleUtc: () => utcTime,
  tickFormat: () => tickFormat
});

// node_modules/d3-array/src/ascending.js
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = bisector(number).center;
const bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
const blur2 = Blur2(blurf);
const blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y2 = 0, n = w * h; y2 < n; ) {
    blur3(T, S, y2, y2 += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x2 = 0, n = w * h; x2 < w; ++x2) {
    blur3(T, S, x2, x2 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop + 0, step);
    blur3(T, S, start + 1, stop + 1, step);
    blur3(T, S, start + 2, stop + 2, step);
    blur3(T, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum4 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius * S[start];
    const s2 = step * radius;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum4 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S[Math.min(stop, i + s2)];
      T[i] = sum4 / w;
      sum4 -= S[Math.max(start, i - s2)];
    }
  };
}

// node_modules/internmap/src/index.js
const InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/sort.js
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a2, b) => {
    const x2 = compare(a2, b);
    if (x2 || x2 === 0) return x2;
    return (compare(b, b) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b) {
  return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
}

// node_modules/d3-array/src/array.js
const array = Array.prototype;
const slice2 = array.slice;
const map = array.map;

// node_modules/d3-array/src/ticks.js
const e10 = Math.sqrt(50);
const e5 = Math.sqrt(10);
const e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start === stop) return [start];
  const reverse3 = stop < start, [i1, i2, inc] = reverse3 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse3 = stop < start, inc = reverse3 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse3 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max2(values, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// node_modules/d3-array/src/min.js
function min2(values, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array2.length - 1, right));
  if (!(left <= k2 && k2 <= right)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k2 - left + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m * s2 / n + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n - m) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left;
    let j = right;
    swap(array2, left, k2);
    if (compare(array2[right], t) > 0) swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left], t) === 0) swap(array2, left, j);
    else ++j, swap(array2, j, right);
    if (j <= k2) left = j + 1;
    if (k2 <= j) right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min2(values);
  if (p >= 1) return max2(values);
  let n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max2(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min2(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  let n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/range.js
function range2(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range6 = new Array(n);
  while (++i < n) {
    range6[i] = start + i * step;
  }
  return range6;
}

// node_modules/d3-array/src/shuffle.js
const shuffle_default = shuffler(Math.random);
function shuffler(random2) {
  return function shuffle2(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random2() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range6) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range6).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  let index2 = new InternMap(), domain = [], range6 = [], unknown = implicit;
  function scale(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range6[i % range6.length];
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _) {
      if (index2.has(value)) continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range6 = Array.from(_), scale) : range6.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range6).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  let scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round3 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    let n = domain().length, reverse3 = r1 < r0, start = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round3) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round3) start = Math.round(start), bandwidth = Math.round(bandwidth);
    const values = range2(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse3 ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round3 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round3 = !!_, rescale()) : round3;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  const copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point5() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  const prototype = Object.create(parent.prototype);
  for (const key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
const darker = 0.7;
const brighter = 1 / darker;
const reI = "\\s*([+-]?\\d+)\\s*";
const reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
const reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
const reHex = /^#([0-9a-f]{3,8})$/;
const reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
const reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
const reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
const reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
const reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
const reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
const named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  let m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  let r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s2 = max3 - min3, l = (max3 + min3) / 2;
  if (s2) {
    if (r === max3) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max3) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    const h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
const K = 18;
const Xn = 0.96422;
const Yn = 1;
const Zn = 0.82521;
const t0 = 4 / 29;
const t1 = 6 / 29;
const t2 = 3 * t1 * t1;
const t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  let r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b) x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    let y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  const h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c2, l, opacity) {
  this.h = +h;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  const h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
const A = -0.14861;
const B = 1.78277;
const C = -0.29227;
const D = -0.90649;
const E = 1.97294;
const ED = E * D;
const EB = E * B;
const BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  const r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    const h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a2 * (A * cosh2 + B * sinh2)),
      255 * (l + a2 * (C * cosh2 + D * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  const t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values) {
  const n = values.length - 1;
  return function(t) {
    const i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values) {
  const n = values.length;
  return function(t) {
    const i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
const constant_default2 = (x2) => () => x2;

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue(a2, b) {
  const d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant_default2(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  const d = b - a2;
  return d ? linear(a2, d) : constant_default2(isNaN(a2) ? b : a2);
}

// node_modules/d3-interpolate/src/rgb.js
const rgb_default = function rgbGamma(y2) {
  const color2 = gamma(y2);
  function rgb2(start, end) {
    const r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    let n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
const rgbBasis = rgbSpline(basis_default2);
const rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b) b = [];
  let n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a2, b) {
  let nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i) c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c2[i] = x2[i](t);
    return c2;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  const d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  let i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = value_default(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i) c2[k2] = i[k2](t);
    return c2;
  };
}

// node_modules/d3-interpolate/src/string.js
const reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
const reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  let bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  let t = typeof b, c2;
  return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default : t === "string" ? (c2 = color(b)) ? (b = c2, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a2, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
const degrees2 = 180 / Math.PI;
const identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b, c2, d, e, f) {
  let scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b)) a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c2 + b * d) c2 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d)) c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c2) a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
let svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity3 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity3;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity3;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      const i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180) b += 360;
      else if (b - a2 > 180) a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      const i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    const s2 = [], q = [];
    a2 = parse(a2), b = parse(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      let i = -1, n = q.length, o;
      while (++i < n) s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
const interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
const interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
const epsilon22 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    let ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      const d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        const s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    const _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    const h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
const hsl_default = hsl2(hue);
const hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    const h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c2 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
const hcl_default = hcl2(hue);
const hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end) {
      const h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y2));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
const cubehelix_default = cubehelix2(hue);
const cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate2, values) {
  if (values === void 0) values = interpolate2, interpolate2 = value_default;
  let i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate2(v, v = values[++i]);
  return function(t) {
    const i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x2) {
  return +x2;
}

// node_modules/d3-scale/src/continuous.js
const unit = [0, 1];
function identity4(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  let t;
  if (a2 > b) t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range6, interpolate2) {
  let d0 = domain[0], d1 = domain[1], r0 = range6[0], r1 = range6[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range6, interpolate2) {
  let j = Math.min(domain.length, range6.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range6 = range6.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range6[i], range6[i + 1]);
  }
  return function(x2) {
    const i2 = bisect_default(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  let domain = unit, range6 = unit, interpolate2 = value_default, transform, untransform, unknown, clamp2 = identity4, piecewise2, output, input;
  function rescale() {
    const n = Math.min(domain.length, range6.length);
    if (clamp2 !== identity4) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range6, interpolate2)))(transform(clamp2(x2)));
  }
  scale.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise2(range6, domain.map(transform), number_default)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range6 = Array.from(_), rescale()) : range6.slice();
  };
  scale.rangeRound = function(_) {
    return range6 = Array.from(_), interpolate2 = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity4, rescale()) : clamp2 !== identity4;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity4, identity4);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  let i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    let i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
const re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  let match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
let prefixExponent;
function formatPrefixAuto_default(x2, p) {
  const d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  const coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p) {
  const d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  const coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
const formatTypes_default = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded_default(x2 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
const map3 = Array.prototype.map;
const prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  const group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    let fill2 = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero3 || fill2 === "0" && align === "=") zero3 = true, fill2 = "0", align = "=";
    const prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    const formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      let valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        let valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group2(value, Infinity);
      let length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill2) : "";
      if (comma && zero3) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    const f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
let locale;
let format;
let formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  let step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      const value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  const domain = scale.domain;
  scale.ticks = function(count2) {
    const d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    const d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null) count2 = 10;
    const d = domain();
    let i0 = 0;
    let i1 = d.length - 1;
    let start = d[i0];
    let stop = d[i1];
    let prestep;
    let step;
    let maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  const scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/identity.js
function identity5(domain) {
  let unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), scale) : domain.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return identity5(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number2) : [0, 1];
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval) {
  domain = domain.slice();
  let i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f) {
  return (x2, k2) => -f(-x2, k2);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;
    if (r) [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k2;
    let t;
    const n = count2 == null ? 10 : +count2;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k2 = 1; k2 < base; ++k2) {
          t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k2 = base - 1; k2 >= 1; --k2) {
          t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null) count2 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity) return specifier;
    const k2 = Math.max(1, base * count2 / scale.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice2(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform) {
  let c2 = 1, scale = transform(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  const scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  let scale = transform(identity4, identity4), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform(identity4, identity4) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow() {
  const scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt2() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/radial.js
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  let squared = continuous(), range6 = [0, 1], round3 = false, unknown;
  function scale(x2) {
    const y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round3 ? Math.round(y2) : y2;
  }
  scale.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };
  scale.range = function(_) {
    return arguments.length ? (squared.range((range6 = Array.from(_, number2)).map(square)), scale) : range6.slice();
  };
  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };
  scale.round = function(_) {
    return arguments.length ? (round3 = !!_, scale) : round3;
  };
  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return radial(squared.domain(), range6).round(round3).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  let domain = [], range6 = [], thresholds = [], unknown;
  function rescale() {
    let i = 0, n = Math.max(1, range6.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range6[bisect_default(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    const i = range6.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_) {
    return arguments.length ? (range6 = Array.from(_), rescale()) : range6.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range6).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  let x0 = 0, x1 = 1, n = 1, domain = [0.5], range6 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range6[bisect_default(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    let i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range6 = Array.from(_)).length - 1, rescale()) : range6.slice();
  };
  scale.invertExtent = function(y2) {
    const i = range6.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range6).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  let domain = [0.5], range6 = [0, 1], unknown, n = 1;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range6[bisect_default(domain, x2, 0, n)] : unknown;
  }
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range6.length - 1), scale) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range6 = Array.from(_), n = Math.min(domain.length, range6.length - 1), scale) : range6.slice();
  };
  scale.invertExtent = function(y2) {
    const i = range6.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range6).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
const t02 = /* @__PURE__ */ new Date();
const t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start, stop, step) => {
    const range6 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range6;
    let previous;
    do
      range6.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range6;
  };
  interval.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
const millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
const milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
const seconds = second.range;

// node_modules/d3-time/src/minute.js
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
const timeMinutes = timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
const utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
const timeHours = timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
const utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
const timeDays = timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
const utcDays = utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
const unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
const timeSundays = timeSunday.range;
const timeMondays = timeMonday.range;
const timeTuesdays = timeTuesday.range;
const timeWednesdays = timeWednesday.range;
const timeThursdays = timeThursday.range;
const timeFridays = timeFriday.range;
const timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
const utcSundays = utcSunday.range;
const utcMondays = utcMonday.range;
const utcTuesdays = utcTuesday.range;
const utcWednesdays = utcWednesday.range;
const utcThursdays = utcThursday.range;
const utcFridays = utcFriday.range;
const utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
const timeMonths = timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
const utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
const timeYears = timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
const utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse3 = stop < start;
    if (reverse3) [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    const date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    const date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  const locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  const periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  const formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  const utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  const parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      let string = [], i = -1, j = 0, n = specifier.length, c2, pad3, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c2 = specifier.charAt(++i)]) != null) c2 = specifier.charAt(++i);
          else pad3 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2]) c2 = format2(date2, pad3);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      let d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    let i = 0, n = specifier.length, m = string.length, c2, parse;
    while (i < n) {
      if (j >= m) return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    const n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    const n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    const n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    const n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    const n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      const f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      const p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      const f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      const p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
const numberRe = /^\s*\d+/;
const percentRe = /^%/;
const requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill2, width) {
  const sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length = string.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill2) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  const n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  const n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  const n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  const n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  const n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  const day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad2(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  const day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  const day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  let z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  const dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  const day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  const day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
let locale2;
let timeFormat;
let timeParse;
let utcFormat;
let utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
const isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
const formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  const date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
const parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  const scale = continuous(), invert2 = scale.invert, domain = scale.domain;
  const formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number3)) : domain().map(date);
  };
  scale.ticks = function(interval) {
    const d = domain();
    return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval) {
    const d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice2(d, interval)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  let x0 = 0, x1 = 1, t03, t13, k10, transform, interpolator = identity4, clamp2 = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t03) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t03 = transform(x0 = +x0), t13 = transform(x1 = +x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range6(interpolate2) {
    return function(_) {
      let r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range6(value_default);
  scale.rangeRound = range6(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t03 = t(x0), t13 = t(x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  const scale = linearish(transformer2()(identity4));
  scale.copy = function() {
    return copy2(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  const scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = function() {
    return copy2(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  const scale = symlogish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  const scale = powish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  let domain = [], interpolator = identity4;
  function scale(x2) {
    if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisect_default(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  let x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity4, transform, clamp2 = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t13) * (s2 * x3 < s2 * t13 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t03 = transform(x0 = +x0), t13 = transform(x1 = +x1), t22 = transform(x2 = +x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range6(interpolate2) {
    return function(_) {
      let r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range6(value_default);
  scale.rangeRound = range6(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t03 = t(x0), t13 = t(x1), t22 = t(x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  const scale = linearish(transformer3()(identity4));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  const scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  const scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  const scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/recharts/es6/state/selectors/dataSelectors.js
const selectChartDataWithIndexes = (state) => state.chartData;
const selectChartDataAndAlwaysIgnoreIndexes = createSelector([selectChartDataWithIndexes], (dataState) => {
  const dataEndIndex = dataState.chartData != null ? dataState.chartData.length - 1 : 0;
  return {
    chartData: dataState.chartData,
    computedData: dataState.computedData,
    dataEndIndex,
    dataStartIndex: 0
  };
});
const selectChartDataWithIndexesIfNotInPanorama = (state, _unused1, _unused2, isPanorama) => {
  if (isPanorama) {
    return selectChartDataAndAlwaysIgnoreIndexes(state);
  }
  return selectChartDataWithIndexes(state);
};

// node_modules/recharts/es6/util/isDomainSpecifiedByUser.js
function isWellFormedNumberDomain(v) {
  if (Array.isArray(v) && v.length === 2) {
    const [min3, max3] = v;
    if (isWellBehavedNumber(min3) && isWellBehavedNumber(max3)) {
      return true;
    }
  }
  return false;
}
function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
  if (allowDataOverflow) {
    return providedDomain;
  }
  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];
}
function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
  if (!allowDataOverflow) {
    return void 0;
  }
  if (typeof userDomain === "function") {
    return void 0;
  }
  if (Array.isArray(userDomain) && userDomain.length === 2) {
    const [providedMin, providedMax] = userDomain;
    let finalMin, finalMax;
    if (isWellBehavedNumber(providedMin)) {
      finalMin = providedMin;
    } else if (typeof providedMin === "function") {
      return void 0;
    }
    if (isWellBehavedNumber(providedMax)) {
      finalMax = providedMax;
    } else if (typeof providedMax === "function") {
      return void 0;
    }
    const candidate = [finalMin, finalMax];
    if (isWellFormedNumberDomain(candidate)) {
      return candidate;
    }
  }
  return void 0;
}
function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
  if (!allowDataOverflow && dataDomain == null) {
    return void 0;
  }
  if (typeof userDomain === "function" && dataDomain != null) {
    try {
      const result = userDomain(dataDomain, allowDataOverflow);
      if (isWellFormedNumberDomain(result)) {
        return extendDomain(result, dataDomain, allowDataOverflow);
      }
    } catch (_unused) {
    }
  }
  if (Array.isArray(userDomain) && userDomain.length === 2) {
    const [providedMin, providedMax] = userDomain;
    let finalMin, finalMax;
    if (providedMin === "auto") {
      if (dataDomain != null) {
        finalMin = Math.min(...dataDomain);
      }
    } else if (isNumber(providedMin)) {
      finalMin = providedMin;
    } else if (typeof providedMin === "function") {
      try {
        if (dataDomain != null) {
          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);
        }
      } catch (_unused2) {
      }
    } else if (typeof providedMin === "string" && MIN_VALUE_REG.test(providedMin)) {
      const match = MIN_VALUE_REG.exec(providedMin);
      if (match == null || dataDomain == null) {
        finalMin = void 0;
      } else {
        const value = +match[1];
        finalMin = dataDomain[0] - value;
      }
    } else {
      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];
    }
    if (providedMax === "auto") {
      if (dataDomain != null) {
        finalMax = Math.max(...dataDomain);
      }
    } else if (isNumber(providedMax)) {
      finalMax = providedMax;
    } else if (typeof providedMax === "function") {
      try {
        if (dataDomain != null) {
          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);
        }
      } catch (_unused3) {
      }
    } else if (typeof providedMax === "string" && MAX_VALUE_REG.test(providedMax)) {
      const _match = MAX_VALUE_REG.exec(providedMax);
      if (_match == null || dataDomain == null) {
        finalMax = void 0;
      } else {
        const _value = +_match[1];
        finalMax = dataDomain[1] + _value;
      }
    } else {
      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];
    }
    const candidate = [finalMin, finalMax];
    if (isWellFormedNumberDomain(candidate)) {
      if (dataDomain == null) {
        return candidate;
      }
      return extendDomain(candidate, dataDomain, allowDataOverflow);
    }
  }
  return void 0;
}

// node_modules/decimal.js-light/decimal.mjs
const MAX_DIGITS = 1e9;
const defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
};
var Decimal;
let external = true;
const decimalError = "[DecimalError] ";
const invalidArgument = decimalError + "Invalid argument: ";
const exponentOutOfRange = decimalError + "Exponent out of range: ";
const mathfloor = Math.floor;
const mathpow = Math.pow;
const isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
let ONE;
const BASE = 1e7;
const LOG_BASE = 7;
const MAX_SAFE_INTEGER = 9007199254740991;
const MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE);
const P = {};
P.absoluteValue = P.abs = function() {
  const x2 = new this.constructor(this);
  if (x2.s) x2.s = 1;
  return x2;
};
P.comparedTo = P.cmp = function(y2) {
  let i, j, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s) return x2.s || -y2.s;
  if (x2.e !== y2.e) return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x2.d[i] !== y2.d[i]) return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  let x2 = this, w = x2.d.length - 1, dp = (w - x2.e) * LOG_BASE;
  w = x2.d[w];
  if (w) for (; w % 10 == 0; w /= 10) dp--;
  return dp < 0 ? 0 : dp;
};
P.dividedBy = P.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.idiv = function(y2) {
  const x2 = this, Ctor = x2.constructor;
  return round2(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P.equals = P.eq = function(y2) {
  return !this.cmp(y2);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base) {
  let r, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
  }
  if (x2.s < 1) throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE)) return new Ctor(0);
  external = false;
  r = divide(ln(x2, wpr), ln(base, wpr), wpr);
  external = true;
  return round2(r, pr);
};
P.minus = P.sub = function(y2) {
  const x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract(x2, y2) : add(x2, (y2.s = -y2.s, y2));
};
P.modulo = P.mod = function(y2) {
  let q, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s) throw Error(decimalError + "NaN");
  if (!x2.s) return round2(new Ctor(x2), pr);
  external = false;
  q = divide(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  const x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P.plus = P.add = function(y2) {
  const x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
};
P.precision = P.sd = function(z) {
  let e, sd, w, x2 = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  e = getBase10Exponent(x2) + 1;
  w = x2.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x2.d[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) sd--;
    for (w = x2.d[0]; w >= 10; w /= 10) sd++;
  }
  return z && e > sd ? e : sd;
};
P.squareRoot = P.sqrt = function() {
  let e, n, pr, r, s2, t, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s) return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e = getBase10Exponent(x2);
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n = digitsToString(x2.d);
    if ((n.length + e) % 2 == 0) n += "0";
    s2 = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s2 == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s2.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x2, t, wpr + 2)).times(0.5);
    if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
      n = n.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n == "4999") {
        round2(t, pr + 1, 0);
        if (t.times(t).eq(x2)) {
          r = t;
          break;
        }
      } else if (n != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round2(r, pr);
};
P.times = P.mul = function(y2) {
  let carry, e, i, k2, r, rL, t, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s) return new Ctor(0);
  y2.s *= x2.s;
  e = x2.e + y2.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t = r[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r[k2--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k2] = (r[k2] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y2.d = r;
  y2.e = e;
  return external ? round2(y2, Ctor.precision) : y2;
};
P.toDecimalPlaces = P.todp = function(dp, rm) {
  let x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0) return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return round2(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P.toExponential = function(dp, rm) {
  let str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round2(new Ctor(x2), dp + 1, rm);
    str = toString(x2, true, dp + 1);
  }
  return str;
};
P.toFixed = function(dp, rm) {
  let str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) return toString(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  y2 = round2(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P.toInteger = P.toint = function() {
  const x2 = this, Ctor = x2.constructor;
  return round2(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(y2) {
  let e, k2, pr, r, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
  if (!y2.s) return new Ctor(ONE);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1) throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE)) return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE)) return round2(x2, pr);
  e = y2.e;
  k2 = y2.d.length - 1;
  yIsInt = e >= k2;
  sign2 = x2.s;
  if (!yIsInt) {
    if (sign2 < 0) throw Error(decimalError + "NaN");
  } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = new Ctor(ONE);
    e = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k2 % 2) {
        r = r.times(x2);
        truncate(r.d, e);
      }
      k2 = mathfloor(k2 / 2);
      if (k2 === 0) break;
      x2 = x2.times(x2);
      truncate(x2.d, e);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE).div(r) : round2(r, pr);
  }
  sign2 = sign2 < 0 && y2.d[Math.max(e, k2)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r = y2.times(ln(x2, pr + guard));
  external = true;
  r = exp(r);
  r.s = sign2;
  return r;
};
P.toPrecision = function(sd, rm) {
  let e, str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    e = getBase10Exponent(x2);
    str = toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x2 = round2(new Ctor(x2), sd, rm);
    e = getBase10Exponent(x2);
    str = toString(x2, sd <= e || e <= Ctor.toExpNeg, sd);
  }
  return str;
};
P.toSignificantDigits = P.tosd = function(sd, rm) {
  const x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return round2(new Ctor(x2), sd, rm);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  const x2 = this, e = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString(x2, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};
function add(x2, y2) {
  let carry, d, e, i, k2, len, xd, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s) y2 = new Ctor(x2);
    return external ? round2(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  k2 = x2.e;
  e = y2.e;
  xd = xd.slice();
  i = k2 - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y2.d = xd;
  y2.e = e;
  return external ? round2(y2, pr) : y2;
}
function checkInt32(i, min3, max3) {
  if (i !== ~~i || i < min3 || i > max3) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d) {
  let i, k2, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k2 = LOG_BASE - ws.length;
      if (k2) str += getZeroString(k2);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k2 = LOG_BASE - ws.length;
    if (k2) str += getZeroString(k2);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x2, k2) {
    let temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry) x2.unshift(carry);
    return x2;
  }
  function compare(a2, b, aL, bL) {
    let i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a2[i] != b[i]) {
          r = a2[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a2, b, aL) {
    let i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b[aL] ? 1 : 0;
      a2[aL] = i * BASE + a2[aL] - b[aL];
    }
    for (; !a2[0] && a2.length > 1; ) a2.shift();
  }
  return function(x2, y2, pr, dp) {
    let cmp, e, i, k2, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!x2.s) return new Ctor(x2);
    if (!y2.s) throw Error(decimalError + "Division by zero");
    e = x2.e - y2.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
    if (yd[i] > (xd[i] || 0)) --e;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k2 = 0;
      yd = yd[0];
      sd++;
      for (; (i < xL || k2) && sd--; i++) {
        t = k2 * BASE + (xd[i] || 0);
        qd[i] = t / yd | 0;
        k2 = t % yd | 0;
      }
    } else {
      k2 = BASE / (yd[0] + 1) | 0;
      if (k2 > 1) {
        yd = multiplyInteger(yd, k2);
        xd = multiplyInteger(xd, k2);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; ) rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2) ++yd0;
      do {
        k2 = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
          k2 = rem0 / yd0 | 0;
          if (k2 > 1) {
            if (k2 >= BASE) k2 = BASE - 1;
            prod = multiplyInteger(yd, k2);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k2--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k2 == 0) cmp = k2 = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k2++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k2++;
          rem = [0];
        }
        qd[i++] = k2;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0]) qd.shift();
    q.e = e;
    return round2(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
}();
function exp(x2, sd) {
  let denominator, guard, pow2, sum4, t, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s) return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum4 = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = round2(pow2.times(x2), wpr);
    denominator = denominator.times(++i);
    t = sum4.plus(divide(pow2, denominator, wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum4.d).slice(0, wpr)) {
      while (k2--) sum4 = round2(sum4.times(sum4), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum4, pr)) : sum4;
    }
    sum4 = t;
  }
}
function getBase10Exponent(x2) {
  let e = x2.e * LOG_BASE, w = x2.d[0];
  for (; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round2(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k2) {
  let zs = "";
  for (; k2--; ) zs += "0";
  return zs;
}
function ln(y2, sd) {
  let c2, c0, denominator, e, numerator, sum4, t, wpr, x2, n = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1) throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE)) return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x3.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  e = getBase10Exponent(x3);
  if (Math.abs(e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n++;
    }
    e = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? (external = true, round2(x3, pr)) : x3;
  }
  sum4 = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
  x2 = round2(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round2(numerator.times(x2), wpr);
    t = sum4.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum4.d).slice(0, wpr)) {
      sum4 = sum4.times(2);
      if (e !== 0) sum4 = sum4.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum4 = divide(sum4, new Ctor(n), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum4, pr)) : sum4;
    }
    sum4 = t;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  let e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; ) ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e = e - i - 1;
    x2.e = mathfloor(e / LOG_BASE);
    x2.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E)) throw Error(exponentOutOfRange + e);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round2(x2, sd, rm) {
  let i, j, k2, n, rd, doRound, w, xdi, xd = x2.d;
  for (n = 1, k2 = xd[0]; k2 >= 10; k2 /= 10) n++;
  i = sd - n;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k2 = xd.length;
    if (xdi >= k2) return x2;
    w = k2 = xd[xdi];
    for (n = 1; k2 >= 10; k2 /= 10) n++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n;
  }
  if (rm !== void 0) {
    k2 = mathpow(10, n - j - 1);
    rd = w / k2 % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k2;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k2 = getBase10Exponent(x2);
      xd.length = 1;
      sd = sd - k2 - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i == 0) {
    xd.length = xdi;
    k2 = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k2 = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k2 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k2) == BASE) {
          xd[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd[xdi] += k2;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k2 = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; ) xd.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract(x2, y2) {
  let d, e, i, j, k2, len, xd, xe, xLTy, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s) y2.s = -y2.s;
    else y2 = new Ctor(x2);
    return external ? round2(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  e = y2.e;
  xe = x2.e;
  xd = xd.slice();
  k2 = xe - e;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k2; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(0);
  y2.d = xd;
  y2.e = e;
  return external ? round2(y2, pr) : y2;
}
function toString(x2, isExp, sd) {
  let k2, e = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k2 = sd - len) > 0) str += getZeroString(k2);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k2 = sd - e - 1) > 0) str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e + 1) < len) str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k2);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone2(obj) {
  let i, p, ps;
  function Decimal2(value) {
    const x2 = this;
    if (!(x2 instanceof Decimal2)) return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value)) parseDecimal(x2, value);
    else throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone2;
  Decimal2.config = Decimal2.set = config;
  if (obj === void 0) obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  let i, p, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if ((v = obj[p = "LN10"]) !== void 0) {
    if (v == Math.LN10) this[p] = new this(v);
    else throw Error(invalidArgument + p + ": " + v);
  }
  return this;
}
var Decimal = clone2(defaults);
ONE = new Decimal(1);
const decimal_default = Decimal;

// node_modules/recharts/es6/util/scale/util/utils.js
const identity6 = (i) => i;
const PLACE_HOLDER = {
  "@@functional/placeholder": true
};
const isPlaceHolder = (val) => val === PLACE_HOLDER;
const curry0 = (fn) => function _curried() {
  if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
    return _curried;
  }
  return fn(...arguments);
};
const curryN = (n, fn) => {
  if (n === 1) {
    return fn;
  }
  return curry0(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
    if (argsLength >= n) {
      return fn(...args);
    }
    return curryN(n - argsLength, curry0(function() {
      for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        restArgs[_key2] = arguments[_key2];
      }
      const newArgs = args.map((arg) => isPlaceHolder(arg) ? restArgs.shift() : arg);
      return fn(...newArgs, ...restArgs);
    }));
  });
};
const curry2 = (fn) => curryN(fn.length, fn);
const range3 = (begin, end) => {
  const arr = [];
  for (let i = begin; i < end; ++i) {
    arr[i - begin] = i;
  }
  return arr;
};
const map4 = curry2((fn, arr) => {
  if (Array.isArray(arr)) {
    return arr.map(fn);
  }
  return Object.keys(arr).map((key) => arr[key]).map(fn);
});
const compose2 = function compose3() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (!args.length) {
    return identity6;
  }
  const fns = args.reverse();
  const firstFn = fns[0];
  const tailsFn = fns.slice(1);
  return function() {
    return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
  };
};
const reverse2 = (arr) => {
  if (Array.isArray(arr)) {
    return arr.reverse();
  }
  return arr.split("").reverse().join("");
};
const memoize2 = (fn) => {
  let lastArgs = null;
  let lastResult2 = null;
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    if (lastArgs && args.every((val, i) => {
      let _lastArgs;
      return val === ((_lastArgs = lastArgs) === null || _lastArgs === void 0 ? void 0 : _lastArgs[i]);
    })) {
      return lastResult2;
    }
    lastArgs = args;
    lastResult2 = fn(...args);
    return lastResult2;
  };
};

// node_modules/recharts/es6/util/scale/util/arithmetic.js
function getDigitCount(value) {
  let result;
  if (value === 0) {
    result = 1;
  } else {
    result = Math.floor(new decimal_default(value).abs().log(10).toNumber()) + 1;
  }
  return result;
}
function rangeStep(start, end, step) {
  let num = new decimal_default(start);
  let i = 0;
  const result = [];
  while (num.lt(end) && i < 1e5) {
    result.push(num.toNumber());
    num = num.add(step);
    i++;
  }
  return result;
}
const interpolateNumber2 = curry2((a2, b, t) => {
  const newA = +a2;
  const newB = +b;
  return newA + t * (newB - newA);
});
const uninterpolateNumber = curry2((a2, b, x2) => {
  let diff = b - +a2;
  diff = diff || Infinity;
  return (x2 - a2) / diff;
});
const uninterpolateTruncation = curry2((a2, b, x2) => {
  let diff = b - +a2;
  diff = diff || Infinity;
  return Math.max(0, Math.min(1, (x2 - a2) / diff));
});

// node_modules/recharts/es6/util/scale/getNiceTickValues.js
const getValidInterval = (_ref2) => {
  const [min3, max3] = _ref2;
  let [validMin, validMax] = [min3, max3];
  if (min3 > max3) {
    [validMin, validMax] = [max3, min3];
  }
  return [validMin, validMax];
};
const getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
  if (roughStep.lte(0)) {
    return new decimal_default(0);
  }
  const digitCount = getDigitCount(roughStep.toNumber());
  const digitCountValue = new decimal_default(10).pow(digitCount);
  const stepRatio = roughStep.div(digitCountValue);
  const stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
  const amendStepRatio = new decimal_default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
  const formatStep = amendStepRatio.mul(digitCountValue);
  return allowDecimals ? new decimal_default(formatStep.toNumber()) : new decimal_default(Math.ceil(formatStep.toNumber()));
};
const getTickOfSingleValue = (value, tickCount, allowDecimals) => {
  let step = new decimal_default(1);
  let middle = new decimal_default(value);
  if (!middle.isint() && allowDecimals) {
    const absVal = Math.abs(value);
    if (absVal < 1) {
      step = new decimal_default(10).pow(getDigitCount(value) - 1);
      middle = new decimal_default(Math.floor(middle.div(step).toNumber())).mul(step);
    } else if (absVal > 1) {
      middle = new decimal_default(Math.floor(value));
    }
  } else if (value === 0) {
    middle = new decimal_default(Math.floor((tickCount - 1) / 2));
  } else if (!allowDecimals) {
    middle = new decimal_default(Math.floor(value));
  }
  const middleIndex = Math.floor((tickCount - 1) / 2);
  const fn = compose2(map4((n) => middle.add(new decimal_default(n - middleIndex).mul(step)).toNumber()), range3);
  return fn(0, tickCount);
};
const _calculateStep = function calculateStep(min3, max3, tickCount, allowDecimals) {
  const correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((max3 - min3) / (tickCount - 1))) {
    return {
      step: new decimal_default(0),
      tickMin: new decimal_default(0),
      tickMax: new decimal_default(0)
    };
  }
  const step = getFormatStep(new decimal_default(max3).sub(min3).div(tickCount - 1), allowDecimals, correctionFactor);
  let middle;
  if (min3 <= 0 && max3 >= 0) {
    middle = new decimal_default(0);
  } else {
    middle = new decimal_default(min3).add(max3).div(2);
    middle = middle.sub(new decimal_default(middle).mod(step));
  }
  let belowCount = Math.ceil(middle.sub(min3).div(step).toNumber());
  let upCount = Math.ceil(new decimal_default(max3).sub(middle).div(step).toNumber());
  const scaleCount = belowCount + upCount + 1;
  if (scaleCount > tickCount) {
    return _calculateStep(min3, max3, tickCount, allowDecimals, correctionFactor + 1);
  }
  if (scaleCount < tickCount) {
    upCount = max3 > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max3 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }
  return {
    step,
    tickMin: middle.sub(new decimal_default(belowCount).mul(step)),
    tickMax: middle.add(new decimal_default(upCount).mul(step))
  };
};
function getNiceTickValuesFn(_ref2) {
  const [min3, max3] = _ref2;
  const tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
  const allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const count2 = Math.max(tickCount, 2);
  const [cormin, cormax] = getValidInterval([min3, max3]);
  if (cormin === -Infinity || cormax === Infinity) {
    const _values = cormax === Infinity ? [cormin, ...range3(0, tickCount - 1).map(() => Infinity)] : [...range3(0, tickCount - 1).map(() => -Infinity), cormax];
    return min3 > max3 ? reverse2(_values) : _values;
  }
  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
  }
  const {
    step,
    tickMin,
    tickMax
  } = _calculateStep(cormin, cormax, count2, allowDecimals, 0);
  const values = rangeStep(tickMin, tickMax.add(new decimal_default(0.1).mul(step)), step);
  return min3 > max3 ? reverse2(values) : values;
}
function getTickValuesFixedDomainFn(_ref3, tickCount) {
  const [min3, max3] = _ref3;
  const allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const [cormin, cormax] = getValidInterval([min3, max3]);
  if (cormin === -Infinity || cormax === Infinity) {
    return [min3, max3];
  }
  if (cormin === cormax) {
    return [cormin];
  }
  const count2 = Math.max(tickCount, 2);
  const step = getFormatStep(new decimal_default(cormax).sub(cormin).div(count2 - 1), allowDecimals, 0);
  let values = [...rangeStep(new decimal_default(cormin), new decimal_default(cormax), step), cormax];
  if (allowDecimals === false) {
    values = values.map((value) => Math.round(value));
  }
  return min3 > max3 ? reverse2(values) : values;
}
const getNiceTickValues = memoize2(getNiceTickValuesFn);
const getTickValuesFixedDomain = memoize2(getTickValuesFixedDomainFn);

// node_modules/recharts/es6/state/selectors/rootPropsSelectors.js
const selectRootMaxBarSize = (state) => state.rootProps.maxBarSize;
const selectBarGap = (state) => state.rootProps.barGap;
const selectBarCategoryGap = (state) => state.rootProps.barCategoryGap;
const selectRootBarSize = (state) => state.rootProps.barSize;
const selectStackOffsetType = (state) => state.rootProps.stackOffset;
const selectChartName = (state) => state.options.chartName;
const selectSyncId = (state) => state.rootProps.syncId;
const selectSyncMethod = (state) => state.rootProps.syncMethod;
const selectEventEmitter = (state) => state.options.eventEmitter;

// node_modules/recharts/es6/polar/defaultPolarAngleAxisProps.js
const defaultPolarAngleAxisProps = {
  allowDuplicatedCategory: true,
  // if I set this to false then Tooltip synchronisation stops working in Radar, wtf
  angleAxisId: 0,
  axisLine: true,
  cx: 0,
  cy: 0,
  orientation: "outer",
  reversed: false,
  scale: "auto",
  tick: true,
  tickLine: true,
  tickSize: 8,
  type: "category"
};

// node_modules/recharts/es6/polar/defaultPolarRadiusAxisProps.js
const defaultPolarRadiusAxisProps = {
  allowDataOverflow: false,
  allowDuplicatedCategory: true,
  angle: 0,
  axisLine: true,
  cx: 0,
  cy: 0,
  orientation: "right",
  radiusAxisId: 0,
  scale: "auto",
  stroke: "#ccc",
  tick: true,
  tickCount: 5,
  type: "number"
};

// node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js
const combineAxisRangeWithReverse = (axisSettings, axisRange) => {
  if (!axisSettings || !axisRange) {
    return void 0;
  }
  if (axisSettings !== null && axisSettings !== void 0 && axisSettings.reversed) {
    return [axisRange[1], axisRange[0]];
  }
  return axisRange;
};

// node_modules/recharts/es6/state/selectors/polarAxisSelectors.js
const implicitAngleAxis = {
  allowDataOverflow: false,
  allowDecimals: false,
  allowDuplicatedCategory: false,
  // defaultPolarAngleAxisProps.allowDuplicatedCategory has it set to true but the actual axis rendering ignores the prop because reasons,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarAngleAxisProps.angleAxisId,
  includeHidden: false,
  name: void 0,
  reversed: defaultPolarAngleAxisProps.reversed,
  scale: defaultPolarAngleAxisProps.scale,
  tick: defaultPolarAngleAxisProps.tick,
  tickCount: void 0,
  ticks: void 0,
  type: defaultPolarAngleAxisProps.type,
  unit: void 0
};
const implicitRadiusAxis = {
  allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarRadiusAxisProps.radiusAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarRadiusAxisProps.scale,
  tick: defaultPolarRadiusAxisProps.tick,
  tickCount: defaultPolarRadiusAxisProps.tickCount,
  ticks: void 0,
  type: defaultPolarRadiusAxisProps.type,
  unit: void 0
};
const implicitRadialBarAngleAxis = {
  allowDataOverflow: false,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarAngleAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarAngleAxisProps.angleAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarAngleAxisProps.scale,
  tick: defaultPolarAngleAxisProps.tick,
  tickCount: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0
};
const implicitRadialBarRadiusAxis = {
  allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
  allowDecimals: false,
  allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
  dataKey: void 0,
  domain: void 0,
  id: defaultPolarRadiusAxisProps.radiusAxisId,
  includeHidden: false,
  name: void 0,
  reversed: false,
  scale: defaultPolarRadiusAxisProps.scale,
  tick: defaultPolarRadiusAxisProps.tick,
  tickCount: defaultPolarRadiusAxisProps.tickCount,
  ticks: void 0,
  type: "category",
  unit: void 0
};
const selectAngleAxis = (state, angleAxisId) => {
  if (state.polarAxis.angleAxis[angleAxisId] != null) {
    return state.polarAxis.angleAxis[angleAxisId];
  }
  if (state.layout.layoutType === "radial") {
    return implicitRadialBarAngleAxis;
  }
  return implicitAngleAxis;
};
const selectRadiusAxis = (state, radiusAxisId) => {
  if (state.polarAxis.radiusAxis[radiusAxisId] != null) {
    return state.polarAxis.radiusAxis[radiusAxisId];
  }
  if (state.layout.layoutType === "radial") {
    return implicitRadialBarRadiusAxis;
  }
  return implicitRadiusAxis;
};
const selectPolarOptions = (state) => state.polarOptions;
const selectMaxRadius = createSelector([selectChartWidth, selectChartHeight, selectChartOffsetInternal], getMaxRadius);
const selectInnerRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
  if (polarChartOptions == null) {
    return void 0;
  }
  return getPercentValue(polarChartOptions.innerRadius, maxRadius, 0);
});
const selectOuterRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
  if (polarChartOptions == null) {
    return void 0;
  }
  return getPercentValue(polarChartOptions.outerRadius, maxRadius, maxRadius * 0.8);
});
const combineAngleAxisRange = (polarOptions) => {
  if (polarOptions == null) {
    return [0, 0];
  }
  const {
    startAngle,
    endAngle
  } = polarOptions;
  return [startAngle, endAngle];
};
const selectAngleAxisRange = createSelector([selectPolarOptions], combineAngleAxisRange);
const selectAngleAxisRangeWithReversed = createSelector([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse);
const selectRadiusAxisRange = createSelector([selectMaxRadius, selectInnerRadius, selectOuterRadius], (maxRadius, innerRadius, outerRadius) => {
  if (maxRadius == null || innerRadius == null || outerRadius == null) {
    return void 0;
  }
  return [innerRadius, outerRadius];
});
const selectRadiusAxisRangeWithReversed = createSelector([selectRadiusAxis, selectRadiusAxisRange], combineAxisRangeWithReverse);
const selectPolarViewBox = createSelector([selectChartLayout, selectPolarOptions, selectInnerRadius, selectOuterRadius, selectChartWidth, selectChartHeight], (layout, polarOptions, innerRadius, outerRadius, width, height) => {
  if (layout !== "centric" && layout !== "radial" || polarOptions == null || innerRadius == null || outerRadius == null) {
    return void 0;
  }
  const {
    cx,
    cy,
    startAngle,
    endAngle
  } = polarOptions;
  return {
    cx: getPercentValue(cx, width, width / 2),
    cy: getPercentValue(cy, height, height / 2),
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise: false
    // this property look useful, why not use it?
  };
});

// node_modules/recharts/es6/state/selectors/pickAxisType.js
const pickAxisType = (_state, axisType) => axisType;

// node_modules/recharts/es6/state/selectors/pickAxisId.js
const pickAxisId = (_state, _axisType, axisId) => axisId;

// node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js
function getStackSeriesIdentifier(graphicalItem) {
  return graphicalItem === null || graphicalItem === void 0 ? void 0 : graphicalItem.id;
}

// node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js
const selectTooltipAxisType = (state) => {
  const layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return "xAxis";
  }
  if (layout === "vertical") {
    return "yAxis";
  }
  if (layout === "centric") {
    return "angleAxis";
  }
  return "radiusAxis";
};

// node_modules/recharts/es6/state/selectors/selectTooltipAxisId.js
const selectTooltipAxisId = (state) => state.tooltip.settings.axisId;

// node_modules/recharts/es6/state/selectors/selectTooltipAxis.js
const selectTooltipAxis = (state) => {
  const axisType = selectTooltipAxisType(state);
  const axisId = selectTooltipAxisId(state);
  return selectAxisSettings(state, axisType, axisId);
};
const selectTooltipAxisDataKey = createSelector([selectTooltipAxis], (axis) => axis === null || axis === void 0 ? void 0 : axis.dataKey);

// node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js
function combineDisplayedStackedData(stackedGraphicalItems, _ref2, tooltipAxisSettings) {
  const {
    chartData = []
  } = _ref2;
  const {
    allowDuplicatedCategory,
    dataKey: tooltipDataKey
  } = tooltipAxisSettings;
  const knownItemsByDataKey = /* @__PURE__ */ new Map();
  stackedGraphicalItems.forEach((item) => {
    let _item$data;
    const resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;
    if (resolvedData == null || resolvedData.length === 0) {
      return;
    }
    const stackIdentifier = getStackSeriesIdentifier(item);
    resolvedData.forEach((entry, index2) => {
      const tooltipValue = tooltipDataKey == null || allowDuplicatedCategory ? index2 : String(getValueByDataKey(entry, tooltipDataKey, null));
      const numericValue = getValueByDataKey(entry, item.dataKey, 0);
      let curr;
      if (knownItemsByDataKey.has(tooltipValue)) {
        curr = knownItemsByDataKey.get(tooltipValue);
      } else {
        curr = {};
      }
      Object.assign(curr, {
        [stackIdentifier]: numericValue
      });
      knownItemsByDataKey.set(tooltipValue, curr);
    });
  });
  return Array.from(knownItemsByDataKey.values());
}

// node_modules/recharts/es6/state/types/StackedGraphicalItem.js
function isStacked(graphicalItem) {
  return graphicalItem.stackId != null && graphicalItem.dataKey != null;
}

// node_modules/recharts/es6/state/selectors/axisSelectors.js
function ownKeys15(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread15(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys15(Object(t), true).forEach(function(r2) {
      _defineProperty15(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys15(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty15(e, r, t) {
  return (r = _toPropertyKey15(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey15(t) {
  const i = _toPrimitive15(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive15(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const defaultNumericDomain = [0, "auto"];
const implicitXAxis = {
  allowDataOverflow: false,
  allowDecimals: true,
  allowDuplicatedCategory: true,
  angle: 0,
  dataKey: void 0,
  domain: void 0,
  height: 30,
  hide: true,
  id: 0,
  includeHidden: false,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: false,
  name: void 0,
  orientation: "bottom",
  padding: {
    left: 0,
    right: 0
  },
  reversed: false,
  scale: "auto",
  tick: true,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "category",
  unit: void 0
};
const selectXAxisSettingsNoDefaults = (state, axisId) => {
  return state.cartesianAxis.xAxis[axisId];
};
const selectXAxisSettings = (state, axisId) => {
  const axis = selectXAxisSettingsNoDefaults(state, axisId);
  if (axis == null) {
    return implicitXAxis;
  }
  return axis;
};
const implicitYAxis = {
  allowDataOverflow: false,
  allowDecimals: true,
  allowDuplicatedCategory: true,
  angle: 0,
  dataKey: void 0,
  domain: defaultNumericDomain,
  hide: true,
  id: 0,
  includeHidden: false,
  interval: "preserveEnd",
  minTickGap: 5,
  mirror: false,
  name: void 0,
  orientation: "left",
  padding: {
    top: 0,
    bottom: 0
  },
  reversed: false,
  scale: "auto",
  tick: true,
  tickCount: 5,
  tickFormatter: void 0,
  ticks: void 0,
  type: "number",
  unit: void 0,
  width: DEFAULT_Y_AXIS_WIDTH
};
const selectYAxisSettingsNoDefaults = (state, axisId) => {
  return state.cartesianAxis.yAxis[axisId];
};
const selectYAxisSettings = (state, axisId) => {
  const axis = selectYAxisSettingsNoDefaults(state, axisId);
  if (axis == null) {
    return implicitYAxis;
  }
  return axis;
};
const implicitZAxis = {
  domain: [0, "auto"],
  includeHidden: false,
  reversed: false,
  allowDataOverflow: false,
  allowDuplicatedCategory: false,
  dataKey: void 0,
  id: 0,
  name: "",
  range: [64, 64],
  scale: "auto",
  type: "number",
  unit: ""
};
const selectZAxisSettings = (state, axisId) => {
  const axis = state.cartesianAxis.zAxis[axisId];
  if (axis == null) {
    return implicitZAxis;
  }
  return axis;
};
const selectBaseAxis = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    case "zAxis": {
      return selectZAxisSettings(state, axisId);
    }
    case "angleAxis": {
      return selectAngleAxis(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxis(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
const selectCartesianAxisSettings = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
var selectAxisSettings = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSettings(state, axisId);
    }
    case "yAxis": {
      return selectYAxisSettings(state, axisId);
    }
    case "angleAxis": {
      return selectAngleAxis(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxis(state, axisId);
    }
    default:
      throw new Error("Unexpected axis type: ".concat(axisType));
  }
};
const selectHasBar = (state) => state.graphicalItems.cartesianItems.some((item) => item.type === "bar") || state.graphicalItems.polarItems.some((item) => item.type === "radialBar");
function itemAxisPredicate(axisType, axisId) {
  return (item) => {
    switch (axisType) {
      case "xAxis":
        return "xAxisId" in item && item.xAxisId === axisId;
      case "yAxis":
        return "yAxisId" in item && item.yAxisId === axisId;
      case "zAxis":
        return "zAxisId" in item && item.zAxisId === axisId;
      case "angleAxis":
        return "angleAxisId" in item && item.angleAxisId === axisId;
      case "radiusAxis":
        return "radiusAxisId" in item && item.radiusAxisId === axisId;
      default:
        return false;
    }
  };
}
const selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems;
const selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
const combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter((item) => {
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {
    return true;
  }
  return !item.hide;
});
const selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);
const selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], (cartesianItems) => {
  return cartesianItems.filter((item) => item.type === "area" || item.type === "bar").filter(isStacked);
});
const filterGraphicalNotStackedItems = (cartesianItems) => cartesianItems.filter((item) => !("stackId" in item) || item.stackId === void 0);
const selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);
const combineGraphicalItemsData = (cartesianItems) => cartesianItems.map((item) => item.data).filter(Boolean).flat(1);
const selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData);
const combineDisplayedData = (graphicalItemsData, _ref2) => {
  const {
    chartData = [],
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (graphicalItemsData.length > 0) {
    return graphicalItemsData;
  }
  return chartData.slice(dataStartIndex, dataEndIndex + 1);
};
const selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);
const combineAppliedValues = (data, axisSettings, items) => {
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    return data.map((item) => ({
      value: getValueByDataKey(item, axisSettings.dataKey)
    }));
  }
  if (items.length > 0) {
    return items.map((item) => item.dataKey).flatMap((dataKey) => data.map((entry) => ({
      value: getValueByDataKey(entry, dataKey)
    })));
  }
  return data.map((entry) => ({
    value: entry
  }));
};
const selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);
function isErrorBarRelevantForAxisType(axisType, errorBar) {
  switch (axisType) {
    case "xAxis":
      return errorBar.direction === "x";
    case "yAxis":
      return errorBar.direction === "y";
    default:
      return false;
  }
}
function onlyAllowNumbers(data) {
  return data.filter((v) => isNumOrStr(v) || v instanceof Date).map(Number).filter((n) => isNan(n) === false);
}
function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {
  if (!relevantErrorBars || typeof appliedValue !== "number" || isNan(appliedValue)) {
    return [];
  }
  if (!relevantErrorBars.length) {
    return [];
  }
  return onlyAllowNumbers(relevantErrorBars.flatMap((eb) => {
    const errorValue = getValueByDataKey(entry, eb.dataKey);
    let lowBound, highBound;
    if (Array.isArray(errorValue)) {
      [lowBound, highBound] = errorValue;
    } else {
      lowBound = highBound = errorValue;
    }
    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {
      return void 0;
    }
    return [appliedValue - lowBound, appliedValue + highBound];
  }));
}
const selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanorama, selectTooltipAxis], combineDisplayedStackedData);
const combineStackGroups = (displayedData, items, stackOffsetType) => {
  const initialItemsGroups = {};
  const itemsGroup = items.reduce((acc, item) => {
    if (item.stackId == null) {
      return acc;
    }
    if (acc[item.stackId] == null) {
      acc[item.stackId] = [];
    }
    acc[item.stackId].push(item);
    return acc;
  }, initialItemsGroups);
  return Object.fromEntries(Object.entries(itemsGroup).map((_ref2) => {
    const [stackId, graphicalItems] = _ref2;
    const dataKeys = graphicalItems.map(getStackSeriesIdentifier);
    return [stackId, {
      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that
      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),
      graphicalItems
    }];
  }));
};
const selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType], combineStackGroups);
const combineDomainOfStackGroups = (stackGroups, _ref3, axisType) => {
  const {
    dataStartIndex,
    dataEndIndex
  } = _ref3;
  if (axisType === "zAxis") {
    return void 0;
  }
  const domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);
  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {
    return void 0;
  }
  return domainOfStackGroups;
};
const selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType], combineDomainOfStackGroups);
const combineAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {
  if (items.length > 0) {
    return data.flatMap((entry) => {
      return items.flatMap((item) => {
        let _errorBars$item$id, _axisSettings$dataKey;
        const relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter((errorBar) => isErrorBarRelevantForAxisType(axisType, errorBar));
        const valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
        return {
          value: valueByDataKey,
          errorDomain: getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars)
        };
      });
    }).filter(Boolean);
  }
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    return data.map((item) => ({
      value: getValueByDataKey(item, axisSettings.dataKey),
      errorDomain: []
    }));
  }
  return data.map((entry) => ({
    value: entry,
    errorDomain: []
  }));
};
const selectAllErrorBarSettings = (state) => state.errorBars;
const combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {
  return cartesianItemsSettings.flatMap((item) => {
    return allErrorBarSettings[item.id];
  }).filter(Boolean).filter((e) => {
    return isErrorBarRelevantForAxisType(axisType, e);
  });
};
const selectErrorBarsSettingsExceptStacked = createSelector([selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
const selectAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineAppliedNumericalValuesIncludingErrorValues);
function onlyAllowNumbersAndStringsAndDates(item) {
  const {
    value
  } = item;
  if (isNumOrStr(value) || value instanceof Date) {
    return value;
  }
  return void 0;
}
const computeNumericalDomain = (dataWithErrorDomains) => {
  const allDataSquished = dataWithErrorDomains.flatMap((d) => [d.value, d.errorDomain]).flat(1);
  const onlyNumbers = onlyAllowNumbers(allDataSquished);
  if (onlyNumbers.length === 0) {
    return void 0;
  }
  return [Math.min(...onlyNumbers), Math.max(...onlyNumbers)];
};
const computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {
  const categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter((v) => v != null);
  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {
    return (0, import_range3.default)(0, allDataSquished.length);
  }
  if (axisSettings.allowDuplicatedCategory) {
    return categoricalDomain;
  }
  return Array.from(new Set(categoricalDomain));
};
const getDomainDefinition = (axisSettings) => {
  let _axisSettings$domain;
  if (axisSettings == null || !("domain" in axisSettings)) {
    return defaultNumericDomain;
  }
  if (axisSettings.domain != null) {
    return axisSettings.domain;
  }
  if (axisSettings.ticks != null) {
    if (axisSettings.type === "number") {
      const allValues = onlyAllowNumbers(axisSettings.ticks);
      return [Math.min(...allValues), Math.max(...allValues)];
    }
    if (axisSettings.type === "category") {
      return axisSettings.ticks.map(String);
    }
  }
  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;
};
const mergeDomains = function mergeDomains2() {
  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {
    domains[_key] = arguments[_key];
  }
  const allDomains = domains.filter(Boolean);
  if (allDomains.length === 0) {
    return void 0;
  }
  const allValues = allDomains.flat();
  const min3 = Math.min(...allValues);
  const max3 = Math.max(...allValues);
  return [min3, max3];
};
const selectReferenceDots = (state) => state.referenceElements.dots;
const filterReferenceElements = (elements, axisType, axisId) => {
  return elements.filter((el) => el.ifOverflow === "extendDomain").filter((el) => {
    if (axisType === "xAxis") {
      return el.xAxisId === axisId;
    }
    return el.yAxisId === axisId;
  });
};
const selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);
const selectReferenceAreas = (state) => state.referenceElements.areas;
const selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);
const selectReferenceLines = (state) => state.referenceElements.lines;
const selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);
const combineDotsDomain = (dots, axisType) => {
  const allCoords = onlyAllowNumbers(dots.map((dot) => axisType === "xAxis" ? dot.x : dot.y));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
const selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);
const combineAreasDomain = (areas, axisType) => {
  const allCoords = onlyAllowNumbers(areas.flatMap((area) => [axisType === "xAxis" ? area.x1 : area.y1, axisType === "xAxis" ? area.x2 : area.y2]));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
const selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);
const combineLinesDomain = (lines, axisType) => {
  const allCoords = onlyAllowNumbers(lines.map((line) => axisType === "xAxis" ? line.x : line.y));
  if (allCoords.length === 0) {
    return void 0;
  }
  return [Math.min(...allCoords), Math.max(...allCoords)];
};
const selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);
const selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {
  return mergeDomains(dotsDomain, areasDomain, linesDomain);
});
const selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);
const combineNumericalDomain = (axisSettings, domainDefinition, domainOfStackGroups, allDataWithErrorDomains, referenceElementsDomain, layout, axisType) => {
  const domainFromUserPreference = numericalDomainSpecifiedWithoutRequiringData(domainDefinition, axisSettings.allowDataOverflow);
  if (domainFromUserPreference != null) {
    return domainFromUserPreference;
  }
  const shouldIncludeDomainOfStackGroups = layout === "vertical" && axisType === "xAxis" || layout === "horizontal" && axisType === "yAxis";
  const mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains)) : mergeDomains(referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains));
  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);
};
const selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainOfStackGroups, selectAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain);
const expandDomain = [0, 1];
const combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {
  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === void 0) {
    return void 0;
  }
  const {
    dataKey,
    type
  } = axisSettings;
  const isCategorical = isCategoricalAxis(layout, axisType);
  if (isCategorical && dataKey == null) {
    return (0, import_range3.default)(0, displayedData.length);
  }
  if (type === "category") {
    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);
  }
  if (stackOffsetType === "expand") {
    return expandDomain;
  }
  return numericalDomain;
};
const selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);
const combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
  if (axisConfig == null) {
    return void 0;
  }
  const {
    scale,
    type
  } = axisConfig;
  if (scale === "auto") {
    if (layout === "radial" && axisType === "radiusAxis") {
      return "band";
    }
    if (layout === "radial" && axisType === "angleAxis") {
      return "linear";
    }
    if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
      return "point";
    }
    if (type === "category") {
      return "band";
    }
    return "linear";
  }
  if (typeof scale === "string") {
    const name = "scale".concat(upperFirst(scale));
    return name in d3_scale_exports ? name : "point";
  }
  return void 0;
};
const selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);
function getD3ScaleFromType(realScaleType) {
  if (realScaleType == null) {
    return void 0;
  }
  if (realScaleType in d3_scale_exports) {
    return d3_scale_exports[realScaleType]();
  }
  const name = "scale".concat(upperFirst(realScaleType));
  if (name in d3_scale_exports) {
    return d3_scale_exports[name]();
  }
  return void 0;
}
function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
  if (axisDomain == null || axisRange == null) {
    return void 0;
  }
  if (typeof axis.scale === "function") {
    return axis.scale.copy().domain(axisDomain).range(axisRange);
  }
  const d3ScaleFunction = getD3ScaleFromType(realScaleType);
  if (d3ScaleFunction == null) {
    return void 0;
  }
  const scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
  checkDomainOfScale(scale);
  return scale;
}
const combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
  const domainDefinition = getDomainDefinition(axisSettings);
  if (realScaleType !== "auto" && realScaleType !== "linear") {
    return void 0;
  }
  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === "auto" || domainDefinition[1] === "auto") && isWellFormedNumberDomain(axisDomain)) {
    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
  }
  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === "number" && isWellFormedNumberDomain(axisDomain)) {
    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
  }
  return void 0;
};
const selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);
const combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {
  if (
    /*
     * Angle axis for some reason uses nice ticks when rendering axis tick labels,
     * but doesn't use nice ticks for extending domain like all the other axes do.
     * Not really sure why? Is there a good reason,
     * or is it just because someone added support for nice ticks to the other axes and forgot this one?
     */
    axisType !== "angleAxis" && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === "number" && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0
  ) {
    const minFromDomain = domain[0];
    const minFromTicks = niceTicks[0];
    const maxFromDomain = domain[1];
    const maxFromTicks = niceTicks[niceTicks.length - 1];
    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
  }
  return domain;
};
const selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);
const selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {
  if (!axisSettings || axisSettings.type !== "number") {
    return void 0;
  }
  let smallestDistanceBetweenValues = Infinity;
  const sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map((d) => d.value))).sort((a2, b) => a2 - b);
  if (sortedValues.length < 2) {
    return Infinity;
  }
  const diff = sortedValues[sortedValues.length - 1] - sortedValues[0];
  if (diff === 0) {
    return Infinity;
  }
  for (let i = 0; i < sortedValues.length - 1; i++) {
    const distance = sortedValues[i + 1] - sortedValues[i];
    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
  }
  return smallestDistanceBetweenValues / diff;
});
const selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
  if (!isWellBehavedNumber(smallestDistanceInPercent)) {
    return 0;
  }
  const rangeWidth = layout === "vertical" ? offset.height : offset.width;
  if (padding === "gap") {
    return smallestDistanceInPercent * rangeWidth / 2;
  }
  if (padding === "no-gap") {
    const gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);
    const halfBand = smallestDistanceInPercent * rangeWidth / 2;
    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;
  }
  return 0;
});
const selectCalculatedXAxisPadding = (state, axisId) => {
  const xAxisSettings = selectXAxisSettings(state, axisId);
  if (xAxisSettings == null || typeof xAxisSettings.padding !== "string") {
    return 0;
  }
  return selectCalculatedPadding(state, "xAxis", axisId, xAxisSettings.padding);
};
const selectCalculatedYAxisPadding = (state, axisId) => {
  const yAxisSettings = selectYAxisSettings(state, axisId);
  if (yAxisSettings == null || typeof yAxisSettings.padding !== "string") {
    return 0;
  }
  return selectCalculatedPadding(state, "yAxis", axisId, yAxisSettings.padding);
};
const selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {
  let _padding$left, _padding$right;
  if (xAxisSettings == null) {
    return {
      left: 0,
      right: 0
    };
  }
  const {
    padding
  } = xAxisSettings;
  if (typeof padding === "string") {
    return {
      left: calculated,
      right: calculated
    };
  }
  return {
    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,
    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated
  };
});
const selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {
  let _padding$top, _padding$bottom;
  if (yAxisSettings == null) {
    return {
      top: 0,
      bottom: 0
    };
  }
  const {
    padding
  } = yAxisSettings;
  if (typeof padding === "string") {
    return {
      top: calculated,
      bottom: calculated
    };
  }
  return {
    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,
    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated
  };
});
const combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {
  const {
    padding: brushPadding
  } = _ref4;
  if (isPanorama) {
    return [brushPadding.left, brushDimensions.width - brushPadding.right];
  }
  return [offset.left + padding.left, offset.left + offset.width - padding.right];
});
const combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
  const {
    padding: brushPadding
  } = _ref5;
  if (isPanorama) {
    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];
  }
  if (layout === "horizontal") {
    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];
  }
  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];
});
const selectAxisRange = (state, axisType, axisId, isPanorama) => {
  let _selectZAxisSettings;
  switch (axisType) {
    case "xAxis":
      return combineXAxisRange(state, axisId, isPanorama);
    case "yAxis":
      return combineYAxisRange(state, axisId, isPanorama);
    case "zAxis":
      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;
    case "angleAxis":
      return selectAngleAxisRange(state);
    case "radiusAxis":
      return selectRadiusAxisRange(state, axisId);
    default:
      return void 0;
  }
};
const selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);
const selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);
const selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);
function compareIds(a2, b) {
  if (a2.id < b.id) {
    return -1;
  }
  if (a2.id > b.id) {
    return 1;
  }
  return 0;
}
const pickAxisOrientation = (_state, orientation) => orientation;
const pickMirror = (_state, _orientation, mirror) => mirror;
const selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
const selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
const getXAxisSize = (offset, axisSettings) => {
  return {
    width: offset.width,
    height: axisSettings.height
  };
};
const getYAxisSize = (offset, axisSettings) => {
  const width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
  return {
    width,
    height: offset.height
  };
};
const selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);
const combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {
  switch (orientation) {
    case "top":
      return offset.top;
    case "bottom":
      return chartHeight - offset.bottom;
    default:
      return 0;
  }
};
const combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {
  switch (orientation) {
    case "left":
      return offset.left;
    case "right":
      return chartWidth - offset.right;
    default:
      return 0;
  }
};
const selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {
  const steps = {};
  let position2;
  allAxesWithSameOffsetType.forEach((axis) => {
    const axisSize = getXAxisSize(offset, axis);
    if (position2 == null) {
      position2 = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);
    }
    const needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
    steps[axis.id] = position2 - Number(needSpace) * axisSize.height;
    position2 += (needSpace ? -1 : 1) * axisSize.height;
  });
  return steps;
});
const selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {
  const steps = {};
  let position2;
  allAxesWithSameOffsetType.forEach((axis) => {
    const axisSize = getYAxisSize(offset, axis);
    if (position2 == null) {
      position2 = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);
    }
    const needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
    steps[axis.id] = position2 - Number(needSpace) * axisSize.width;
    position2 += (needSpace ? -1 : 1) * axisSize.width;
  });
  return steps;
});
const selectXAxisOffsetSteps = (state, axisId) => {
  const axisSettings = selectXAxisSettings(state, axisId);
  if (axisSettings == null) {
    return void 0;
  }
  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
const selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
  if (axisSettings == null) {
    return void 0;
  }
  const stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
  if (stepOfThisAxis == null) {
    return {
      x: offset.left,
      y: 0
    };
  }
  return {
    x: offset.left,
    y: stepOfThisAxis
  };
});
const selectYAxisOffsetSteps = (state, axisId) => {
  const axisSettings = selectYAxisSettings(state, axisId);
  if (axisSettings == null) {
    return void 0;
  }
  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
const selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {
  if (axisSettings == null) {
    return void 0;
  }
  const stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
  if (stepOfThisAxis == null) {
    return {
      x: 0,
      y: offset.top
    };
  }
  return {
    x: stepOfThisAxis,
    y: offset.top
  };
});
const selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {
  const width = typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;
  return {
    width,
    height: offset.height
  };
});
const selectCartesianAxisSize = (state, axisType, axisId) => {
  switch (axisType) {
    case "xAxis": {
      return selectXAxisSize(state, axisId).width;
    }
    case "yAxis": {
      return selectYAxisSize(state, axisId).height;
    }
    default: {
      return void 0;
    }
  }
};
const combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
  if (axis == null) {
    return void 0;
  }
  const {
    allowDuplicatedCategory,
    type,
    dataKey
  } = axis;
  const isCategorical = isCategoricalAxis(chartLayout, axisType);
  const allData = appliedValues.map((av) => av.value);
  if (dataKey && isCategorical && type === "category" && allowDuplicatedCategory && hasDuplicate(allData)) {
    return allData;
  }
  return void 0;
};
const selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);
const combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
  if (axis == null || axis.dataKey == null) {
    return void 0;
  }
  const {
    type,
    scale
  } = axis;
  const isCategorical = isCategoricalAxis(layout, axisType);
  if (isCategorical && (type === "number" || scale !== "auto")) {
    return appliedValues.map((d) => d.value);
  }
  return void 0;
};
const selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
const selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {
  if (axis == null) {
    return null;
  }
  const isCategorical = isCategoricalAxis(layout, axisType);
  return {
    angle: axis.angle,
    interval: axis.interval,
    minTickGap: axis.minTickGap,
    orientation: axis.orientation,
    tick: axis.tick,
    tickCount: axis.tickCount,
    tickFormatter: axis.tickFormatter,
    ticks: axis.ticks,
    type: axis.type,
    unit: axis.unit,
    axisType,
    categoricalDomain,
    duplicateDomain,
    isCategorical,
    niceTicks,
    range: axisRange,
    realScaleType,
    scale
  };
});
const combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  const isCategorical = isCategoricalAxis(layout, axisType);
  const {
    type,
    ticks: ticks2,
    tickCount
  } = axis;
  const offsetForBand = realScaleType === "scaleBand" && typeof scale.bandwidth === "function" ? scale.bandwidth() / 2 : 2;
  let offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
  const ticksOrNiceTicks = ticks2 || niceTicks;
  if (ticksOrNiceTicks) {
    const result = ticksOrNiceTicks.map((entry, index2) => {
      const scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        index: index2,
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale(scaleContent) + offset,
        value: entry,
        offset
      };
    });
    return result.filter((row) => !isNan(row.coordinate));
  }
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index: index2,
      offset
    }));
  }
  if (scale.ticks) {
    return scale.ticks(tickCount).map((entry) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset
    }));
  }
  return scale.domain().map((entry, index2) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index: index2,
    offset
  }));
};
const selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);
const combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {
    return void 0;
  }
  const isCategorical = isCategoricalAxis(layout, axisType);
  const {
    tickCount
  } = axis;
  let offset = 0;
  offset = axisType === "angleAxis" && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index: index2,
      offset
    }));
  }
  if (scale.ticks) {
    return scale.ticks(tickCount).map((entry) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      offset
    }));
  }
  return scale.domain().map((entry, index2) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index: index2,
    offset
  }));
};
const selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);
const selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread15(_objectSpread15({}, axis), {}, {
    scale
  });
});
const selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);
const selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread15(_objectSpread15({}, axis), {}, {
    scale
  });
});
const selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {
  switch (layout) {
    case "horizontal": {
      return allXAxes.some((axis) => axis.reversed) ? "right-to-left" : "left-to-right";
    }
    case "vertical": {
      return allYAxes.some((axis) => axis.reversed) ? "bottom-to-top" : "top-to-bottom";
    }
    case "centric":
    case "radial": {
      return "left-to-right";
    }
    default: {
      return void 0;
    }
  }
});

// node_modules/recharts/es6/state/selectors/selectTooltipEventType.js
const selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType;
const selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
  if (shared == null) {
    return defaultTooltipEventType;
  }
  const eventType = shared ? "axis" : "item";
  if (validateTooltipEventTypes == null) {
    return defaultTooltipEventType;
  }
  return validateTooltipEventTypes.includes(eventType) ? eventType : defaultTooltipEventType;
}
function selectTooltipEventType(state, shared) {
  const defaultTooltipEventType = selectDefaultTooltipEventType(state);
  const validateTooltipEventTypes = selectValidateTooltipEventTypes(state);
  return combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes);
}
function useTooltipEventType(shared) {
  return useAppSelector((state) => selectTooltipEventType(state, shared));
}

// node_modules/recharts/es6/state/selectors/combiners/combineActiveLabel.js
const combineActiveLabel = (tooltipTicks, activeIndex) => {
  let _tooltipTicks$n;
  const n = Number(activeIndex);
  if (isNan(n) || activeIndex == null) {
    return void 0;
  }
  return n >= 0 ? tooltipTicks === null || tooltipTicks === void 0 || (_tooltipTicks$n = tooltipTicks[n]) === null || _tooltipTicks$n === void 0 ? void 0 : _tooltipTicks$n.value : void 0;
};

// node_modules/recharts/es6/state/selectors/selectTooltipSettings.js
const selectTooltipSettings = (state) => state.tooltip.settings;

// node_modules/recharts/es6/state/tooltipSlice.js
const noInteraction = {
  active: false,
  index: null,
  dataKey: void 0,
  coordinate: void 0
};
const initialState3 = {
  itemInteraction: {
    click: noInteraction,
    hover: noInteraction
  },
  axisInteraction: {
    click: noInteraction,
    hover: noInteraction
  },
  keyboardInteraction: noInteraction,
  syncInteraction: {
    active: false,
    index: null,
    dataKey: void 0,
    label: void 0,
    coordinate: void 0
  },
  tooltipItemPayloads: [],
  settings: {
    shared: void 0,
    trigger: "hover",
    axisId: 0,
    active: false,
    defaultIndex: void 0
  }
};
const tooltipSlice = createSlice({
  name: "tooltip",
  initialState: initialState3,
  reducers: {
    addTooltipEntrySettings(state, action) {
      state.tooltipItemPayloads.push(castDraft(action.payload));
    },
    removeTooltipEntrySettings(state, action) {
      const index2 = current(state).tooltipItemPayloads.indexOf(castDraft(action.payload));
      if (index2 > -1) {
        state.tooltipItemPayloads.splice(index2, 1);
      }
    },
    setTooltipSettingsState(state, action) {
      state.settings = action.payload;
    },
    setActiveMouseOverItemIndex(state, action) {
      state.syncInteraction.active = false;
      state.keyboardInteraction.active = false;
      state.itemInteraction.hover.active = true;
      state.itemInteraction.hover.index = action.payload.activeIndex;
      state.itemInteraction.hover.dataKey = action.payload.activeDataKey;
      state.itemInteraction.hover.coordinate = action.payload.activeCoordinate;
    },
    mouseLeaveChart(state) {
      state.itemInteraction.hover.active = false;
      state.axisInteraction.hover.active = false;
    },
    mouseLeaveItem(state) {
      state.itemInteraction.hover.active = false;
    },
    setActiveClickItemIndex(state, action) {
      state.syncInteraction.active = false;
      state.itemInteraction.click.active = true;
      state.keyboardInteraction.active = false;
      state.itemInteraction.click.index = action.payload.activeIndex;
      state.itemInteraction.click.dataKey = action.payload.activeDataKey;
      state.itemInteraction.click.coordinate = action.payload.activeCoordinate;
    },
    setMouseOverAxisIndex(state, action) {
      state.syncInteraction.active = false;
      state.axisInteraction.hover.active = true;
      state.keyboardInteraction.active = false;
      state.axisInteraction.hover.index = action.payload.activeIndex;
      state.axisInteraction.hover.dataKey = action.payload.activeDataKey;
      state.axisInteraction.hover.coordinate = action.payload.activeCoordinate;
    },
    setMouseClickAxisIndex(state, action) {
      state.syncInteraction.active = false;
      state.keyboardInteraction.active = false;
      state.axisInteraction.click.active = true;
      state.axisInteraction.click.index = action.payload.activeIndex;
      state.axisInteraction.click.dataKey = action.payload.activeDataKey;
      state.axisInteraction.click.coordinate = action.payload.activeCoordinate;
    },
    setSyncInteraction(state, action) {
      state.syncInteraction = action.payload;
    },
    setKeyboardInteraction(state, action) {
      state.keyboardInteraction.active = action.payload.active;
      state.keyboardInteraction.index = action.payload.activeIndex;
      state.keyboardInteraction.coordinate = action.payload.activeCoordinate;
      state.keyboardInteraction.dataKey = action.payload.activeDataKey;
    }
  }
});
const {
  addTooltipEntrySettings,
  removeTooltipEntrySettings,
  setTooltipSettingsState,
  setActiveMouseOverItemIndex,
  mouseLeaveItem,
  mouseLeaveChart,
  setActiveClickItemIndex,
  setMouseOverAxisIndex,
  setMouseClickAxisIndex,
  setSyncInteraction,
  setKeyboardInteraction
} = tooltipSlice.actions;
const tooltipReducer = tooltipSlice.reducer;

// node_modules/recharts/es6/state/selectors/combiners/combineTooltipInteractionState.js
function ownKeys16(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread16(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys16(Object(t), true).forEach(function(r2) {
      _defineProperty16(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys16(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty16(e, r, t) {
  return (r = _toPropertyKey16(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey16(t) {
  const i = _toPrimitive16(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive16(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger) {
  if (tooltipEventType === "axis") {
    if (trigger === "click") {
      return tooltipState.axisInteraction.click;
    }
    return tooltipState.axisInteraction.hover;
  }
  if (trigger === "click") {
    return tooltipState.itemInteraction.click;
  }
  return tooltipState.itemInteraction.hover;
}
function hasBeenActivePreviously(tooltipInteractionState) {
  return tooltipInteractionState.index != null;
}
const combineTooltipInteractionState = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
  if (tooltipEventType == null) {
    return noInteraction;
  }
  const appropriateMouseInteraction = chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger);
  if (appropriateMouseInteraction == null) {
    return noInteraction;
  }
  if (appropriateMouseInteraction.active) {
    return appropriateMouseInteraction;
  }
  if (tooltipState.keyboardInteraction.active) {
    return tooltipState.keyboardInteraction;
  }
  if (tooltipState.syncInteraction.active && tooltipState.syncInteraction.index != null) {
    return tooltipState.syncInteraction;
  }
  const activeFromProps = tooltipState.settings.active === true;
  if (hasBeenActivePreviously(appropriateMouseInteraction)) {
    if (activeFromProps) {
      return _objectSpread16(_objectSpread16({}, appropriateMouseInteraction), {}, {
        active: true
      });
    }
  } else if (defaultIndex != null) {
    return {
      active: true,
      coordinate: void 0,
      dataKey: void 0,
      index: defaultIndex
    };
  }
  return _objectSpread16(_objectSpread16({}, noInteraction), {}, {
    coordinate: appropriateMouseInteraction.coordinate
  });
};

// node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js
const combineActiveTooltipIndex = (tooltipInteraction, chartData) => {
  const desiredIndex = tooltipInteraction === null || tooltipInteraction === void 0 ? void 0 : tooltipInteraction.index;
  if (desiredIndex == null) {
    return null;
  }
  const indexAsNumber = Number(desiredIndex);
  if (!isWellBehavedNumber(indexAsNumber)) {
    return desiredIndex;
  }
  const lowerLimit = 0;
  let upperLimit = Infinity;
  if (chartData.length > 0) {
    upperLimit = chartData.length - 1;
  }
  return String(Math.max(lowerLimit, Math.min(indexAsNumber, upperLimit)));
};

// node_modules/recharts/es6/state/selectors/combiners/combineCoordinateForDefaultIndex.js
const combineCoordinateForDefaultIndex = (width, height, layout, offset, tooltipTicks, defaultIndex, tooltipConfigurations, tooltipPayloadSearcher) => {
  if (defaultIndex == null || tooltipPayloadSearcher == null) {
    return void 0;
  }
  const firstConfiguration = tooltipConfigurations[0];
  const maybePosition = firstConfiguration == null ? void 0 : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
  if (maybePosition != null) {
    return maybePosition;
  }
  const tick = tooltipTicks === null || tooltipTicks === void 0 ? void 0 : tooltipTicks[Number(defaultIndex)];
  if (!tick) {
    return void 0;
  }
  switch (layout) {
    case "horizontal": {
      return {
        x: tick.coordinate,
        y: (offset.top + height) / 2
      };
    }
    default: {
      return {
        x: (offset.left + width) / 2,
        y: tick.coordinate
      };
    }
  }
};

// node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayloadConfigurations.js
const combineTooltipPayloadConfigurations = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
  if (tooltipEventType === "axis") {
    return tooltipState.tooltipItemPayloads;
  }
  if (tooltipState.tooltipItemPayloads.length === 0) {
    return [];
  }
  let filterByDataKey;
  if (trigger === "hover") {
    filterByDataKey = tooltipState.itemInteraction.hover.dataKey;
  } else {
    filterByDataKey = tooltipState.itemInteraction.click.dataKey;
  }
  if (filterByDataKey == null && defaultIndex != null) {
    return [tooltipState.tooltipItemPayloads[0]];
  }
  return tooltipState.tooltipItemPayloads.filter((tpc) => {
    let _tpc$settings;
    return ((_tpc$settings = tpc.settings) === null || _tpc$settings === void 0 ? void 0 : _tpc$settings.dataKey) === filterByDataKey;
  });
};

// node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js
const selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;

// node_modules/recharts/es6/state/selectors/selectTooltipState.js
const selectTooltipState = (state) => state.tooltip;

// node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayload.js
function ownKeys17(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread17(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys17(Object(t), true).forEach(function(r2) {
      _defineProperty17(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys17(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty17(e, r, t) {
  return (r = _toPropertyKey17(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey17(t) {
  const i = _toPrimitive17(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive17(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
  if (dataDefinedOnItem != null) {
    return dataDefinedOnItem;
  }
  return dataDefinedOnChart;
}
const combineTooltipPayload = (tooltipPayloadConfigurations, activeIndex, chartDataState, tooltipAxisDataKey, activeLabel, tooltipPayloadSearcher, tooltipEventType) => {
  if (activeIndex == null || tooltipPayloadSearcher == null) {
    return void 0;
  }
  const {
    chartData,
    computedData,
    dataStartIndex,
    dataEndIndex
  } = chartDataState;
  const init = [];
  return tooltipPayloadConfigurations.reduce((agg, _ref2) => {
    let _settings$dataKey;
    const {
      dataDefinedOnItem,
      settings
    } = _ref2;
    const finalData = selectFinalData(dataDefinedOnItem, chartData);
    const sliced = Array.isArray(finalData) ? getSliced(finalData, dataStartIndex, dataEndIndex) : finalData;
    const finalDataKey = (_settings$dataKey = settings === null || settings === void 0 ? void 0 : settings.dataKey) !== null && _settings$dataKey !== void 0 ? _settings$dataKey : tooltipAxisDataKey;
    const finalNameKey = settings === null || settings === void 0 ? void 0 : settings.nameKey;
    let tooltipPayload;
    if (tooltipAxisDataKey && Array.isArray(sliced) && /*
     * findEntryInArray won't work for Scatter because Scatter provides an array of arrays
     * as tooltip payloads and findEntryInArray is not prepared to handle that.
     * Sad but also ScatterChart only allows 'item' tooltipEventType
     * and also this is only a problem if there are multiple Scatters and each has its own data array
     * so let's fix that some other time.
     */
    !Array.isArray(sliced[0]) && /*
     * If the tooltipEventType is 'axis', we should search for the dataKey in the sliced data
     * because thanks to allowDuplicatedCategory=false, the order of elements in the array
     * no longer matches the order of elements in the original data
     * and so we need to search by the active dataKey + label rather than by index.
     *
     * The same happens if multiple graphical items are present in the chart
     * and each of them has its own data array. Those arrays get concatenated
     * and again the tooltip index no longer matches the original data.
     *
     * On the other hand the tooltipEventType 'item' should always search by index
     * because we get the index from interacting over the individual elements
     * which is always accurate, irrespective of the allowDuplicatedCategory setting.
     */
    tooltipEventType === "axis") {
      tooltipPayload = findEntryInArray(sliced, tooltipAxisDataKey, activeLabel);
    } else {
      tooltipPayload = tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey);
    }
    if (Array.isArray(tooltipPayload)) {
      tooltipPayload.forEach((item) => {
        const newSettings = _objectSpread17(_objectSpread17({}, settings), {}, {
          name: item.name,
          unit: item.unit,
          // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
          color: void 0,
          // color and fill are erased to keep 100% the identical behaviour to recharts 2.x - but there's nothing stopping us from returning them here. It's technically a breaking change.
          fill: void 0
        });
        agg.push(getTooltipEntry({
          tooltipEntrySettings: newSettings,
          dataKey: item.dataKey,
          payload: item.payload,
          // @ts-expect-error getValueByDataKey does not validate the output type
          value: getValueByDataKey(item.payload, item.dataKey),
          name: item.name
        }));
      });
    } else {
      let _getValueByDataKey;
      agg.push(getTooltipEntry({
        tooltipEntrySettings: settings,
        dataKey: finalDataKey,
        payload: tooltipPayload,
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: getValueByDataKey(tooltipPayload, finalDataKey),
        // @ts-expect-error getValueByDataKey does not validate the output type
        name: (_getValueByDataKey = getValueByDataKey(tooltipPayload, finalNameKey)) !== null && _getValueByDataKey !== void 0 ? _getValueByDataKey : settings === null || settings === void 0 ? void 0 : settings.name
      }));
    }
    return agg;
  }, init);
};

// node_modules/recharts/es6/state/selectors/tooltipSelectors.js
const selectTooltipAxisRealScaleType = createSelector([selectTooltipAxis, selectChartLayout, selectHasBar, selectChartName, selectTooltipAxisType], combineRealScaleType);
const selectAllUnfilteredGraphicalItems = createSelector([(state) => state.graphicalItems.cartesianItems, (state) => state.graphicalItems.polarItems], (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]);
const selectTooltipAxisPredicate = createSelector([selectTooltipAxisType, selectTooltipAxisId], itemAxisPredicate);
const selectAllGraphicalItemsSettings = createSelector([selectAllUnfilteredGraphicalItems, selectTooltipAxis, selectTooltipAxisPredicate], combineGraphicalItemsSettings);
const selectAllStackedGraphicalItemsSettings = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
const selectTooltipGraphicalItemsData = createSelector([selectAllGraphicalItemsSettings], combineGraphicalItemsData);
const selectTooltipDisplayedData = createSelector([selectTooltipGraphicalItemsData, selectChartDataWithIndexes], combineDisplayedData);
const selectTooltipStackedData = createSelector([selectAllStackedGraphicalItemsSettings, selectChartDataWithIndexes, selectTooltipAxis], combineDisplayedStackedData);
const selectAllTooltipAppliedValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectAllGraphicalItemsSettings], combineAppliedValues);
const selectTooltipAxisDomainDefinition = createSelector([selectTooltipAxis], getDomainDefinition);
const selectAllStackedGraphicalItems = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
const selectTooltipStackGroups = createSelector([selectTooltipStackedData, selectAllStackedGraphicalItems, selectStackOffsetType], combineStackGroups);
const selectTooltipDomainOfStackGroups = createSelector([selectTooltipStackGroups, selectChartDataWithIndexes, selectTooltipAxisType], combineDomainOfStackGroups);
const selectTooltipItemsSettingsExceptStacked = createSelector([selectAllGraphicalItemsSettings], filterGraphicalNotStackedItems);
const selectTooltipAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectTooltipDisplayedData, selectTooltipAxis, selectTooltipItemsSettingsExceptStacked, selectAllErrorBarSettings, selectTooltipAxisType], combineAppliedNumericalValuesIncludingErrorValues);
const selectReferenceDotsByTooltipAxis = createSelector([selectReferenceDots, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
const selectTooltipReferenceDotsDomain = createSelector([selectReferenceDotsByTooltipAxis, selectTooltipAxisType], combineDotsDomain);
const selectReferenceAreasByTooltipAxis = createSelector([selectReferenceAreas, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
const selectTooltipReferenceAreasDomain = createSelector([selectReferenceAreasByTooltipAxis, selectTooltipAxisType], combineAreasDomain);
const selectReferenceLinesByTooltipAxis = createSelector([selectReferenceLines, selectTooltipAxisType, selectTooltipAxisId], filterReferenceElements);
const selectTooltipReferenceLinesDomain = createSelector([selectReferenceLinesByTooltipAxis, selectTooltipAxisType], combineLinesDomain);
const selectTooltipReferenceElementsDomain = createSelector([selectTooltipReferenceDotsDomain, selectTooltipReferenceLinesDomain, selectTooltipReferenceAreasDomain], mergeDomains);
const selectTooltipNumericalDomain = createSelector([selectTooltipAxis, selectTooltipAxisDomainDefinition, selectTooltipDomainOfStackGroups, selectTooltipAllAppliedNumericalValuesIncludingErrorValues, selectTooltipReferenceElementsDomain, selectChartLayout, selectTooltipAxisType], combineNumericalDomain);
const selectTooltipAxisDomain = createSelector([selectTooltipAxis, selectChartLayout, selectTooltipDisplayedData, selectAllTooltipAppliedValues, selectStackOffsetType, selectTooltipAxisType, selectTooltipNumericalDomain], combineAxisDomain);
const selectTooltipNiceTicks = createSelector([selectTooltipAxisDomain, selectTooltipAxis, selectTooltipAxisRealScaleType], combineNiceTicks);
const selectTooltipAxisDomainIncludingNiceTicks = createSelector([selectTooltipAxis, selectTooltipAxisDomain, selectTooltipNiceTicks, selectTooltipAxisType], combineAxisDomainWithNiceTicks);
const selectTooltipAxisRange = (state) => {
  const axisType = selectTooltipAxisType(state);
  const axisId = selectTooltipAxisId(state);
  const isPanorama = false;
  return selectAxisRange(state, axisType, axisId, isPanorama);
};
const selectTooltipAxisRangeWithReverse = createSelector([selectTooltipAxis, selectTooltipAxisRange], combineAxisRangeWithReverse);
const selectTooltipAxisScale = createSelector([selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisDomainIncludingNiceTicks, selectTooltipAxisRangeWithReverse], combineScaleFunction);
const selectTooltipDuplicateDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineDuplicateDomain);
const selectTooltipCategoricalDomain = createSelector([selectChartLayout, selectAllTooltipAppliedValues, selectTooltipAxis, selectTooltipAxisType], combineCategoricalDomain);
const combineTicksOfTooltipAxis = (layout, axis, realScaleType, scale, range6, duplicateDomain, categoricalDomain, axisType) => {
  if (!axis) {
    return void 0;
  }
  const {
    type
  } = axis;
  const isCategorical = isCategoricalAxis(layout, axisType);
  if (!scale) {
    return void 0;
  }
  const offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
  let offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset = axisType === "angleAxis" && range6 != null && (range6 === null || range6 === void 0 ? void 0 : range6.length) >= 2 ? mathSign(range6[0] - range6[1]) * 2 * offset : offset;
  if (isCategorical && categoricalDomain) {
    return categoricalDomain.map((entry, index2) => ({
      coordinate: scale(entry) + offset,
      value: entry,
      index: index2,
      offset
    }));
  }
  return scale.domain().map((entry, index2) => ({
    coordinate: scale(entry) + offset,
    value: duplicateDomain ? duplicateDomain[entry] : entry,
    index: index2,
    offset
  }));
};
const selectTooltipAxisTicks = createSelector([selectChartLayout, selectTooltipAxis, selectTooltipAxisRealScaleType, selectTooltipAxisScale, selectTooltipAxisRange, selectTooltipDuplicateDomain, selectTooltipCategoricalDomain, selectTooltipAxisType], combineTicksOfTooltipAxis);
const selectTooltipEventType2 = createSelector([selectDefaultTooltipEventType, selectValidateTooltipEventTypes, selectTooltipSettings], (defaultTooltipEventType, validateTooltipEventType, settings) => combineTooltipEventType(settings.shared, defaultTooltipEventType, validateTooltipEventType));
const selectTooltipTrigger = (state) => state.tooltip.settings.trigger;
const selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex;
const selectTooltipInteractionState = createSelector([selectTooltipState, selectTooltipEventType2, selectTooltipTrigger, selectDefaultIndex], combineTooltipInteractionState);
const selectActiveTooltipIndex = createSelector([selectTooltipInteractionState, selectTooltipDisplayedData], combineActiveTooltipIndex);
const selectActiveLabel = createSelector([selectTooltipAxisTicks, selectActiveTooltipIndex], combineActiveLabel);
const selectActiveTooltipDataKey = createSelector([selectTooltipInteractionState], (tooltipInteraction) => {
  if (!tooltipInteraction) {
    return void 0;
  }
  return tooltipInteraction.dataKey;
});
const selectTooltipPayloadConfigurations = createSelector([selectTooltipState, selectTooltipEventType2, selectTooltipTrigger, selectDefaultIndex], combineTooltipPayloadConfigurations);
const selectTooltipCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, selectDefaultIndex, selectTooltipPayloadConfigurations, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
const selectActiveTooltipCoordinate = createSelector([selectTooltipInteractionState, selectTooltipCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
  if (tooltipInteractionState !== null && tooltipInteractionState !== void 0 && tooltipInteractionState.coordinate) {
    return tooltipInteractionState.coordinate;
  }
  return defaultIndexCoordinate;
});
const selectIsTooltipActive = createSelector([selectTooltipInteractionState], (tooltipInteractionState) => tooltipInteractionState.active);
const selectActiveTooltipPayload = createSelector([selectTooltipPayloadConfigurations, selectActiveTooltipIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel, selectTooltipPayloadSearcher, selectTooltipEventType2], combineTooltipPayload);
const selectActiveTooltipDataPoints = createSelector([selectActiveTooltipPayload], (payload) => {
  if (payload == null) {
    return void 0;
  }
  const dataPoints = payload.map((p) => p.payload).filter((p) => p != null);
  return Array.from(new Set(dataPoints));
});

// node_modules/recharts/es6/context/useTooltipAxis.js
function ownKeys18(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread18(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys18(Object(t), true).forEach(function(r2) {
      _defineProperty18(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys18(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty18(e, r, t) {
  return (r = _toPropertyKey18(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey18(t) {
  const i = _toPrimitive18(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive18(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const useTooltipAxis = () => useAppSelector(selectTooltipAxis);
const useTooltipAxisBandSize = () => {
  const tooltipAxis = useTooltipAxis();
  const tooltipTicks = useAppSelector(selectTooltipAxisTicks);
  const tooltipAxisScale = useAppSelector(selectTooltipAxisScale);
  return getBandSizeOfAxis(_objectSpread18(_objectSpread18({}, tooltipAxis), {}, {
    scale: tooltipAxisScale
  }), tooltipTicks);
};

// node_modules/recharts/es6/state/selectors/selectors.js
const import_sortBy5 = __toESM(require_sortBy2());
const useChartName = () => {
  return useAppSelector(selectChartName);
};
const pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType;
const pickTrigger = (_state, _tooltipEventType, trigger) => trigger;
const pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex;
const selectOrderedTooltipTicks = createSelector(selectTooltipAxisTicks, (ticks2) => (0, import_sortBy5.default)(ticks2, (o) => o.coordinate));
const selectTooltipInteractionState2 = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipInteractionState);
const selectActiveIndex = createSelector([selectTooltipInteractionState2, selectTooltipDisplayedData], combineActiveTooltipIndex);
const selectTooltipDataKey = (state, tooltipEventType, trigger) => {
  if (tooltipEventType == null) {
    return void 0;
  }
  const tooltipState = selectTooltipState(state);
  if (tooltipEventType === "axis") {
    if (trigger === "hover") {
      return tooltipState.axisInteraction.hover.dataKey;
    }
    return tooltipState.axisInteraction.click.dataKey;
  }
  if (trigger === "hover") {
    return tooltipState.itemInteraction.hover.dataKey;
  }
  return tooltipState.itemInteraction.click.dataKey;
};
const selectTooltipPayloadConfigurations2 = createSelector([selectTooltipState, pickTooltipEventType, pickTrigger, pickDefaultIndex], combineTooltipPayloadConfigurations);
const selectCoordinateForDefaultIndex = createSelector([selectChartWidth, selectChartHeight, selectChartLayout, selectChartOffsetInternal, selectTooltipAxisTicks, pickDefaultIndex, selectTooltipPayloadConfigurations2, selectTooltipPayloadSearcher], combineCoordinateForDefaultIndex);
const selectActiveCoordinate = createSelector([selectTooltipInteractionState2, selectCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
  let _tooltipInteractionSt;
  return (_tooltipInteractionSt = tooltipInteractionState.coordinate) !== null && _tooltipInteractionSt !== void 0 ? _tooltipInteractionSt : defaultIndexCoordinate;
});
const selectActiveLabel2 = createSelector(selectTooltipAxisTicks, selectActiveIndex, combineActiveLabel);
const selectTooltipPayload = createSelector([selectTooltipPayloadConfigurations2, selectActiveIndex, selectChartDataWithIndexes, selectTooltipAxisDataKey, selectActiveLabel2, selectTooltipPayloadSearcher, pickTooltipEventType], combineTooltipPayload);
const selectIsTooltipActive2 = createSelector([selectTooltipInteractionState2], (tooltipInteractionState) => {
  return {
    isActive: tooltipInteractionState.active,
    activeIndex: tooltipInteractionState.index
  };
});
const combineActiveProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
  if (!chartEvent || !layout || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) {
    return void 0;
  }
  const rangeObj = inRange(chartEvent.chartX, chartEvent.chartY, layout, polarViewBox, offset);
  if (!rangeObj) {
    return void 0;
  }
  const pos = calculateTooltipPos(rangeObj, layout);
  const activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
  const activeCoordinate = getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj);
  return {
    activeIndex: String(activeIndex),
    activeCoordinate
  };
};

// node_modules/recharts/es6/component/Cursor.js
function _extends11() {
  return _extends11 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends11.apply(null, arguments);
}
function ownKeys19(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread19(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys19(Object(t), true).forEach(function(r2) {
      _defineProperty19(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys19(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty19(e, r, t) {
  return (r = _toPropertyKey19(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey19(t) {
  const i = _toPrimitive19(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive19(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function CursorInternal(props) {
  const {
    coordinate,
    payload,
    index: index2,
    offset,
    tooltipAxisBandSize,
    layout,
    cursor,
    tooltipEventType,
    chartName
  } = props;
  const activeCoordinate = coordinate;
  const activePayload = payload;
  const activeTooltipIndex = index2;
  if (!cursor || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
    return null;
  }
  let restProps, cursorComp;
  if (chartName === "ScatterChart") {
    restProps = activeCoordinate;
    cursorComp = Cross;
  } else if (chartName === "BarChart") {
    restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
    cursorComp = Rectangle;
  } else if (layout === "radial") {
    const {
      cx,
      cy,
      radius,
      startAngle,
      endAngle
    } = getRadialCursorPoints(activeCoordinate);
    restProps = {
      cx,
      cy,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    };
    cursorComp = Sector;
  } else {
    restProps = {
      points: getCursorPoints(layout, activeCoordinate, offset)
    };
    cursorComp = Curve;
  }
  const extraClassName = typeof cursor === "object" && "className" in cursor ? cursor.className : void 0;
  const cursorProps = _objectSpread19(_objectSpread19(_objectSpread19(_objectSpread19({
    stroke: "#ccc",
    pointerEvents: "none"
  }, offset), restProps), filterProps(cursor, false)), {}, {
    payload: activePayload,
    payloadIndex: activeTooltipIndex,
    className: clsx("recharts-tooltip-cursor", extraClassName)
  });
  return (0, import_react18.isValidElement)(cursor) ? (0, import_react18.cloneElement)(cursor, cursorProps) : (0, import_react18.createElement)(cursorComp, cursorProps);
}
function Cursor(props) {
  const tooltipAxisBandSize = useTooltipAxisBandSize();
  const offset = useOffsetInternal();
  const layout = useChartLayout();
  const chartName = useChartName();
  return React13.createElement(CursorInternal, _extends11({}, props, {
    coordinate: props.coordinate,
    index: props.index,
    payload: props.payload,
    offset,
    layout,
    tooltipAxisBandSize,
    chartName
  }));
}

// node_modules/recharts/es6/context/tooltipPortalContext.js
const import_react19 = __toESM(require_react());
const TooltipPortalContext = (0, import_react19.createContext)(null);
const useTooltipPortal = () => (0, import_react19.useContext)(TooltipPortalContext);

// node_modules/recharts/es6/synchronisation/useChartSynchronisation.js
const import_react20 = __toESM(require_react());

// node_modules/eventemitter3/index.mjs
const import_index = __toESM(require_eventemitter3(), 1);
const eventemitter3_default = import_index.default;

// node_modules/recharts/es6/util/Events.js
const eventCenter = new eventemitter3_default();
const TOOLTIP_SYNC_EVENT = "recharts.syncEvent.tooltip";
const BRUSH_SYNC_EVENT = "recharts.syncEvent.brush";

// node_modules/recharts/es6/state/optionsSlice.js
function arrayTooltipSearcher(data, strIndex) {
  if (!strIndex) return void 0;
  const numIndex = Number.parseInt(strIndex, 10);
  if (isNan(numIndex)) {
    return void 0;
  }
  return data === null || data === void 0 ? void 0 : data[numIndex];
}
const initialState4 = {
  chartName: "",
  tooltipPayloadSearcher: void 0,
  eventEmitter: void 0,
  defaultTooltipEventType: "axis"
};
const optionsSlice = createSlice({
  name: "options",
  initialState: initialState4,
  reducers: {
    createEventEmitter: (state) => {
      if (state.eventEmitter == null) {
        state.eventEmitter = Symbol("rechartsEventEmitter");
      }
    }
  }
});
const optionsReducer = optionsSlice.reducer;
const {
  createEventEmitter
} = optionsSlice.actions;

// node_modules/recharts/es6/synchronisation/syncSelectors.js
function selectSynchronisedTooltipState(state) {
  return state.tooltip.syncInteraction;
}

// node_modules/recharts/es6/state/chartDataSlice.js
const initialChartDataState = {
  chartData: void 0,
  computedData: void 0,
  dataStartIndex: 0,
  dataEndIndex: 0
};
const chartDataSlice = createSlice({
  name: "chartData",
  initialState: initialChartDataState,
  reducers: {
    setChartData(state, action) {
      state.chartData = action.payload;
      if (action.payload == null) {
        state.dataStartIndex = 0;
        state.dataEndIndex = 0;
        return;
      }
      if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) {
        state.dataEndIndex = action.payload.length - 1;
      }
    },
    setComputedData(state, action) {
      state.computedData = action.payload;
    },
    setDataStartEndIndexes(state, action) {
      const {
        startIndex,
        endIndex
      } = action.payload;
      if (startIndex != null) {
        state.dataStartIndex = startIndex;
      }
      if (endIndex != null) {
        state.dataEndIndex = endIndex;
      }
    }
  }
});
const {
  setChartData,
  setDataStartEndIndexes,
  setComputedData
} = chartDataSlice.actions;
const chartDataReducer = chartDataSlice.reducer;

// node_modules/recharts/es6/synchronisation/useChartSynchronisation.js
const _excluded6 = ["x", "y"];
function ownKeys20(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread20(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys20(Object(t), true).forEach(function(r2) {
      _defineProperty20(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys20(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty20(e, r, t) {
  return (r = _toPropertyKey20(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey20(t) {
  const i = _toPrimitive20(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive20(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties6(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose6(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose6(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const noop4 = () => {
};
function useTooltipSyncEventsListener() {
  const mySyncId = useAppSelector(selectSyncId);
  const myEventEmitter = useAppSelector(selectEventEmitter);
  const dispatch = useAppDispatch();
  const syncMethod = useAppSelector(selectSyncMethod);
  const tooltipTicks = useAppSelector(selectTooltipAxisTicks);
  const layout = useChartLayout();
  const viewBox = useViewBox();
  const className = useAppSelector((state) => state.rootProps.className);
  (0, import_react20.useEffect)(() => {
    if (mySyncId == null) {
      return noop4;
    }
    const listener2 = (incomingSyncId, action, emitter) => {
      if (myEventEmitter === emitter) {
        return;
      }
      if (mySyncId !== incomingSyncId) {
        return;
      }
      if (syncMethod === "index") {
        let _action$payload;
        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate) {
          const _action$payload$coord = action.payload.coordinate, {
            x: _x,
            y: _y
          } = _action$payload$coord, otherCoordinateProps = _objectWithoutProperties6(_action$payload$coord, _excluded6);
          const boundedCoordinate = _objectSpread20(_objectSpread20(_objectSpread20({}, otherCoordinateProps), typeof _x === "number" && {
            x: Math.max(viewBox.x, Math.min(_x, viewBox.x + viewBox.width))
          }), typeof _y === "number" && {
            y: Math.max(viewBox.y, Math.min(_y, viewBox.y + viewBox.height))
          });
          const boundedAction = _objectSpread20(_objectSpread20({}, action), {}, {
            payload: _objectSpread20(_objectSpread20({}, action.payload), {}, {
              coordinate: boundedCoordinate
            })
          });
          dispatch(boundedAction);
        } else {
          dispatch(action);
        }
        return;
      }
      if (tooltipTicks == null) {
        return;
      }
      let activeTick;
      if (typeof syncMethod === "function") {
        const syncMethodParam = {
          activeTooltipIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
          isTooltipActive: action.payload.active,
          activeIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
          activeLabel: action.payload.label,
          activeDataKey: action.payload.dataKey,
          activeCoordinate: action.payload.coordinate
        };
        const activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
        activeTick = tooltipTicks[activeTooltipIndex];
      } else if (syncMethod === "value") {
        activeTick = tooltipTicks.find((tick) => String(tick.value) === action.payload.label);
      }
      const {
        coordinate
      } = action.payload;
      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {
        dispatch(setSyncInteraction({
          active: false,
          coordinate: void 0,
          dataKey: void 0,
          index: null,
          label: void 0
        }));
        return;
      }
      const {
        x: x2,
        y: y2
      } = coordinate;
      const validateChartX = Math.min(x2, viewBox.x + viewBox.width);
      const validateChartY = Math.min(y2, viewBox.y + viewBox.height);
      const activeCoordinate = {
        x: layout === "horizontal" ? activeTick.coordinate : validateChartX,
        y: layout === "horizontal" ? validateChartY : activeTick.coordinate
      };
      const syncAction = setSyncInteraction({
        active: action.payload.active,
        coordinate: activeCoordinate,
        dataKey: action.payload.dataKey,
        index: String(activeTick.index),
        label: action.payload.label
      });
      dispatch(syncAction);
    };
    eventCenter.on(TOOLTIP_SYNC_EVENT, listener2);
    return () => {
      eventCenter.off(TOOLTIP_SYNC_EVENT, listener2);
    };
  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);
}
function useBrushSyncEventsListener() {
  const mySyncId = useAppSelector(selectSyncId);
  const myEventEmitter = useAppSelector(selectEventEmitter);
  const dispatch = useAppDispatch();
  (0, import_react20.useEffect)(() => {
    if (mySyncId == null) {
      return noop4;
    }
    const listener2 = (incomingSyncId, action, emitter) => {
      if (myEventEmitter === emitter) {
        return;
      }
      if (mySyncId === incomingSyncId) {
        dispatch(setDataStartEndIndexes(action));
      }
    };
    eventCenter.on(BRUSH_SYNC_EVENT, listener2);
    return () => {
      eventCenter.off(BRUSH_SYNC_EVENT, listener2);
    };
  }, [dispatch, myEventEmitter, mySyncId]);
}
function useSynchronisedEventsFromOtherCharts() {
  const dispatch = useAppDispatch();
  (0, import_react20.useEffect)(() => {
    dispatch(createEventEmitter());
  }, [dispatch]);
  useTooltipSyncEventsListener();
  useBrushSyncEventsListener();
}
function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {
  const activeDataKey = useAppSelector((state) => selectTooltipDataKey(state, tooltipEventType, trigger));
  const eventEmitterSymbol = useAppSelector(selectEventEmitter);
  const syncId = useAppSelector(selectSyncId);
  const syncMethod = useAppSelector(selectSyncMethod);
  const tooltipState = useAppSelector(selectSynchronisedTooltipState);
  const isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;
  (0, import_react20.useEffect)(() => {
    if (isReceivingSynchronisation) {
      return;
    }
    if (syncId == null) {
      return;
    }
    if (eventEmitterSymbol == null) {
      return;
    }
    const syncAction = setSyncInteraction({
      active: isTooltipActive,
      coordinate: activeCoordinate,
      dataKey: activeDataKey,
      index: activeIndex,
      label: typeof activeLabel === "number" ? String(activeLabel) : activeLabel
    });
    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive]);
}
function useBrushChartSynchronisation() {
  const syncId = useAppSelector(selectSyncId);
  const eventEmitterSymbol = useAppSelector(selectEventEmitter);
  const brushStartIndex = useAppSelector((state) => state.chartData.dataStartIndex);
  const brushEndIndex = useAppSelector((state) => state.chartData.dataEndIndex);
  (0, import_react20.useEffect)(() => {
    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {
      return;
    }
    const syncAction = {
      startIndex: brushStartIndex,
      endIndex: brushEndIndex
    };
    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);
}

// node_modules/recharts/es6/component/Tooltip.js
function ownKeys21(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread21(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys21(Object(t), true).forEach(function(r2) {
      _defineProperty21(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys21(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty21(e, r, t) {
  return (r = _toPropertyKey21(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey21(t) {
  const i = _toPrimitive21(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive21(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function defaultUniqBy2(entry) {
  return entry.dataKey;
}
function renderContent(content, props) {
  if (React14.isValidElement(content)) {
    return React14.cloneElement(content, props);
  }
  if (typeof content === "function") {
    return React14.createElement(content, props);
  }
  return React14.createElement(DefaultTooltipContent, props);
}
const emptyPayload = [];
const defaultTooltipProps = {
  allowEscapeViewBox: {
    x: false,
    y: false
  },
  animationDuration: 400,
  animationEasing: "ease",
  axisId: 0,
  contentStyle: {},
  cursor: true,
  filterNull: true,
  isAnimationActive: !Global.isSsr,
  itemSorter: "name",
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: false,
    y: false
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: false,
  wrapperStyle: {}
};
function Tooltip(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultTooltipProps);
  const {
    active: activeFromProps,
    allowEscapeViewBox,
    animationDuration,
    animationEasing,
    content,
    filterNull,
    isAnimationActive,
    offset,
    payloadUniqBy,
    position: position2,
    reverseDirection,
    useTranslate3d,
    wrapperStyle,
    cursor,
    shared,
    trigger,
    defaultIndex,
    portal: portalFromProps,
    axisId
  } = props;
  const dispatch = useAppDispatch();
  const defaultIndexAsString = typeof defaultIndex === "number" ? String(defaultIndex) : defaultIndex;
  (0, import_react21.useEffect)(() => {
    dispatch(setTooltipSettingsState({
      shared,
      trigger,
      axisId,
      active: activeFromProps,
      defaultIndex: defaultIndexAsString
    }));
  }, [dispatch, shared, trigger, axisId, activeFromProps, defaultIndexAsString]);
  const viewBox = useViewBox();
  const accessibilityLayer = useAccessibilityLayer();
  const tooltipEventType = useTooltipEventType(shared);
  const {
    activeIndex,
    isActive
  } = useAppSelector((state) => selectIsTooltipActive2(state, tooltipEventType, trigger, defaultIndexAsString));
  const payloadFromRedux = useAppSelector((state) => selectTooltipPayload(state, tooltipEventType, trigger, defaultIndexAsString));
  const labelFromRedux = useAppSelector((state) => selectActiveLabel2(state, tooltipEventType, trigger, defaultIndexAsString));
  const coordinate = useAppSelector((state) => selectActiveCoordinate(state, tooltipEventType, trigger, defaultIndexAsString));
  const payload = payloadFromRedux;
  const tooltipPortalFromContext = useTooltipPortal();
  const finalIsActive = activeFromProps !== null && activeFromProps !== void 0 ? activeFromProps : isActive;
  const [lastBoundingBox, updateBoundingBox] = useElementOffset([payload, finalIsActive]);
  const finalLabel = tooltipEventType === "axis" ? labelFromRedux : void 0;
  useTooltipChartSynchronisation(tooltipEventType, trigger, coordinate, finalLabel, activeIndex, finalIsActive);
  const tooltipPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : tooltipPortalFromContext;
  if (tooltipPortal == null) {
    return null;
  }
  let finalPayload = payload !== null && payload !== void 0 ? payload : emptyPayload;
  if (!finalIsActive) {
    finalPayload = emptyPayload;
  }
  if (filterNull && finalPayload.length) {
    finalPayload = getUniqPayload(payload.filter((entry) => entry.value != null && (entry.hide !== true || props.includeHidden)), payloadUniqBy, defaultUniqBy2);
  }
  const hasPayload = finalPayload.length > 0;
  const tooltipElement = React14.createElement(TooltipBoundingBox, {
    allowEscapeViewBox,
    animationDuration,
    animationEasing,
    isAnimationActive,
    active: finalIsActive,
    coordinate,
    hasPayload,
    offset,
    position: position2,
    reverseDirection,
    useTranslate3d,
    viewBox,
    wrapperStyle,
    lastBoundingBox,
    innerRef: updateBoundingBox,
    hasPortalFromProps: Boolean(portalFromProps)
  }, renderContent(content, _objectSpread21(_objectSpread21({}, props), {}, {
    // @ts-expect-error renderContent method expects the payload to be mutable, TODO make it immutable
    payload: finalPayload,
    label: finalLabel,
    active: finalIsActive,
    coordinate,
    accessibilityLayer
  })));
  return React14.createElement(React14.Fragment, null, (0, import_react_dom2.createPortal)(tooltipElement, tooltipPortal), finalIsActive && React14.createElement(Cursor, {
    cursor,
    tooltipEventType,
    coordinate,
    payload,
    index: activeIndex
  }));
}

// node_modules/recharts/es6/component/ResponsiveContainer.js
const React15 = __toESM(require_react());
const import_react22 = __toESM(require_react());
const import_throttle2 = __toESM(require_throttle2());

// node_modules/recharts/es6/util/LogUtils.js
const isDev = true;
const warn = function warn2(condition, format2) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  if (isDev && typeof console !== "undefined" && console.warn) {
    if (format2 === void 0) {
      console.warn("LogUtils requires an error message argument");
    }
    if (!condition) {
      if (format2 === void 0) {
        console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        let argIndex = 0;
        console.warn(format2.replace(/%s/g, () => args[argIndex++]));
      }
    }
  }
};

// node_modules/recharts/es6/component/ResponsiveContainer.js
function ownKeys22(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread22(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys22(Object(t), true).forEach(function(r2) {
      _defineProperty22(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys22(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty22(e, r, t) {
  return (r = _toPropertyKey22(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey22(t) {
  const i = _toPrimitive22(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive22(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const ResponsiveContainer = (0, import_react22.forwardRef)((_ref2, ref) => {
  const {
    aspect,
    initialDimension = {
      width: -1,
      height: -1
    },
    width = "100%",
    height = "100%",
    /*
     * default min-width to 0 if not specified - 'auto' causes issues with flexbox
     * https://github.com/recharts/recharts/issues/172
     */
    minWidth = 0,
    minHeight,
    maxHeight,
    children,
    debounce: debounce2 = 0,
    id,
    className,
    onResize,
    style = {}
  } = _ref2;
  const containerRef = (0, import_react22.useRef)(null);
  const onResizeRef = (0, import_react22.useRef)();
  onResizeRef.current = onResize;
  (0, import_react22.useImperativeHandle)(ref, () => containerRef.current);
  const [sizes, setSizes] = (0, import_react22.useState)({
    containerWidth: initialDimension.width,
    containerHeight: initialDimension.height
  });
  const setContainerSize = (0, import_react22.useCallback)((newWidth, newHeight) => {
    setSizes((prevState) => {
      const roundedWidth = Math.round(newWidth);
      const roundedHeight = Math.round(newHeight);
      if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) {
        return prevState;
      }
      return {
        containerWidth: roundedWidth,
        containerHeight: roundedHeight
      };
    });
  }, []);
  (0, import_react22.useEffect)(() => {
    let callback = (entries) => {
      let _onResizeRef$current;
      const {
        width: containerWidth2,
        height: containerHeight2
      } = entries[0].contentRect;
      setContainerSize(containerWidth2, containerHeight2);
      (_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth2, containerHeight2);
    };
    if (debounce2 > 0) {
      callback = (0, import_throttle2.default)(callback, debounce2, {
        trailing: true,
        leading: false
      });
    }
    const observer = new ResizeObserver(callback);
    const {
      width: containerWidth,
      height: containerHeight
    } = containerRef.current.getBoundingClientRect();
    setContainerSize(containerWidth, containerHeight);
    observer.observe(containerRef.current);
    return () => {
      observer.disconnect();
    };
  }, [setContainerSize, debounce2]);
  const chartContent = (0, import_react22.useMemo)(() => {
    const {
      containerWidth,
      containerHeight
    } = sizes;
    if (containerWidth < 0 || containerHeight < 0) {
      return null;
    }
    warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
    warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
    let calculatedWidth = isPercent(width) ? containerWidth : width;
    let calculatedHeight = isPercent(height) ? containerHeight : height;
    if (aspect && aspect > 0) {
      if (calculatedWidth) {
        calculatedHeight = calculatedWidth / aspect;
      } else if (calculatedHeight) {
        calculatedWidth = calculatedHeight * aspect;
      }
      if (maxHeight && calculatedHeight > maxHeight) {
        calculatedHeight = maxHeight;
      }
    }
    warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
    return React15.Children.map(children, (child) => {
      return (0, import_react22.cloneElement)(child, {
        width: calculatedWidth,
        height: calculatedHeight,
        // calculate the actual size and override it.
        style: _objectSpread22({
          width: calculatedWidth,
          height: calculatedHeight
        }, child.props.style)
      });
    });
  }, [aspect, children, height, maxHeight, minHeight, minWidth, sizes, width]);
  return React15.createElement("div", {
    id: id ? "".concat(id) : void 0,
    className: clsx("recharts-responsive-container", className),
    style: _objectSpread22(_objectSpread22({}, style), {}, {
      width,
      height,
      minWidth,
      minHeight,
      maxHeight
    }),
    ref: containerRef
  }, React15.createElement("div", {
    style: {
      width: 0,
      height: 0,
      overflow: "visible"
    }
  }, chartContent));
});

// node_modules/recharts/es6/component/Cell.js
const Cell = (_props) => null;
Cell.displayName = "Cell";

// node_modules/recharts/es6/component/Text.js
const React16 = __toESM(require_react());
const import_react23 = __toESM(require_react());

// node_modules/recharts/es6/util/LRUCache.js
function _defineProperty23(e, r, t) {
  return (r = _toPropertyKey23(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey23(t) {
  const i = _toPrimitive23(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive23(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const LRUCache = class {
  constructor(maxSize) {
    _defineProperty23(this, "cache", /* @__PURE__ */ new Map());
    this.maxSize = maxSize;
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
};

// node_modules/recharts/es6/util/DOMUtils.js
function ownKeys23(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread23(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys23(Object(t), true).forEach(function(r2) {
      _defineProperty24(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys23(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty24(e, r, t) {
  return (r = _toPropertyKey24(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey24(t) {
  const i = _toPrimitive24(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive24(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const defaultConfig = {
  cacheSize: 2e3,
  enableCache: true
};
const currentConfig = _objectSpread23({}, defaultConfig);
const stringCache = new LRUCache(currentConfig.cacheSize);
const SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
const MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function createCacheKey(text, style) {
  const fontSize = style.fontSize || "";
  const fontFamily = style.fontFamily || "";
  const fontWeight = style.fontWeight || "";
  const fontStyle = style.fontStyle || "";
  const letterSpacing = style.letterSpacing || "";
  const textTransform = style.textTransform || "";
  return "".concat(text, "|").concat(fontSize, "|").concat(fontFamily, "|").concat(fontWeight, "|").concat(fontStyle, "|").concat(letterSpacing, "|").concat(textTransform);
}
const measureTextWithDOM = (text, style) => {
  try {
    let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (!measurementSpan) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    Object.assign(measurementSpan.style, SPAN_STYLE, style);
    measurementSpan.textContent = "".concat(text);
    const rect = measurementSpan.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height
    };
  } catch (_unused) {
    return {
      width: 0,
      height: 0
    };
  }
};
const getStringSize = function getStringSize2(text) {
  const style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (text === void 0 || text === null || Global.isSsr) {
    return {
      width: 0,
      height: 0
    };
  }
  if (!currentConfig.enableCache) {
    return measureTextWithDOM(text, style);
  }
  const cacheKey = createCacheKey(text, style);
  const cachedResult = stringCache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }
  const result = measureTextWithDOM(text, style);
  stringCache.set(cacheKey, result);
  return result;
};

// node_modules/recharts/es6/util/ReduceCSSCalc.js
const MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
const ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
const CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
const NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
const CONVERSION_RATES = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
};
const FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
const STR_NAN = "NaN";
function convertToPx(value, unit2) {
  return value * CONVERSION_RATES[unit2];
}
const DecimalCSS = class _DecimalCSS {
  static parse(str) {
    let _NUM_SPLIT_REGEX$exec;
    const [, numStr, unit2] = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [];
    return new _DecimalCSS(parseFloat(numStr), unit2 !== null && unit2 !== void 0 ? unit2 : "");
  }
  constructor(num, unit2) {
    this.num = num;
    this.unit = unit2;
    this.num = num;
    this.unit = unit2;
    if (isNan(num)) {
      this.unit = "";
    }
    if (unit2 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit2)) {
      this.num = NaN;
      this.unit = "";
    }
    if (FIXED_CSS_LENGTH_UNITS.includes(unit2)) {
      this.num = convertToPx(num, unit2);
      this.unit = "px";
    }
  }
  add(other) {
    if (this.unit !== other.unit) {
      return new _DecimalCSS(NaN, "");
    }
    return new _DecimalCSS(this.num + other.num, this.unit);
  }
  subtract(other) {
    if (this.unit !== other.unit) {
      return new _DecimalCSS(NaN, "");
    }
    return new _DecimalCSS(this.num - other.num, this.unit);
  }
  multiply(other) {
    if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
      return new _DecimalCSS(NaN, "");
    }
    return new _DecimalCSS(this.num * other.num, this.unit || other.unit);
  }
  divide(other) {
    if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) {
      return new _DecimalCSS(NaN, "");
    }
    return new _DecimalCSS(this.num / other.num, this.unit || other.unit);
  }
  toString() {
    return "".concat(this.num).concat(this.unit);
  }
  isNaN() {
    return isNan(this.num);
  }
};
function calculateArithmetic(expr) {
  if (expr.includes(STR_NAN)) {
    return STR_NAN;
  }
  let newExpr = expr;
  while (newExpr.includes("*") || newExpr.includes("/")) {
    var _MULTIPLY_OR_DIVIDE_R;
    const [, leftOperand, operator, rightOperand] = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [];
    const lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
    const rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
    const result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
    if (result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
  }
  while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
    var _ADD_OR_SUBTRACT_REGE;
    const [, _leftOperand, _operator, _rightOperand] = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [];
    const _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
    const _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
    const _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
    if (_result.isNaN()) {
      return STR_NAN;
    }
    newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
  }
  return newExpr;
}
const PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
  let newExpr = expr;
  let match;
  while ((match = PARENTHESES_REGEX.exec(newExpr)) != null) {
    const [, parentheticalExpression] = match;
    newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
  }
  return newExpr;
}
function evaluateExpression(expression) {
  let newExpr = expression.replace(/\s+/g, "");
  newExpr = calculateParentheses(newExpr);
  newExpr = calculateArithmetic(newExpr);
  return newExpr;
}
function safeEvaluateExpression(expression) {
  try {
    return evaluateExpression(expression);
  } catch (_unused) {
    return STR_NAN;
  }
}
function reduceCSSCalc(expression) {
  const result = safeEvaluateExpression(expression.slice(5, -1));
  if (result === STR_NAN) {
    return "";
  }
  return result;
}

// node_modules/recharts/es6/component/Text.js
const _excluded7 = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"];
const _excluded22 = ["dx", "dy", "angle", "className", "breakAll"];
function _extends12() {
  return _extends12 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends12.apply(null, arguments);
}
function _objectWithoutProperties7(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose7(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose7(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
const calculateWordWidths = (_ref2) => {
  const {
    children,
    breakAll,
    style
  } = _ref2;
  try {
    let words2 = [];
    if (!isNullish(children)) {
      if (breakAll) {
        words2 = children.toString().split("");
      } else {
        words2 = children.toString().split(BREAKING_SPACES);
      }
    }
    const wordsWithComputedWidth = words2.map((word) => ({
      word,
      width: getStringSize(word, style).width
    }));
    const spaceWidth = breakAll ? 0 : getStringSize("", style).width;
    return {
      wordsWithComputedWidth,
      spaceWidth
    };
  } catch (_unused) {
    return null;
  }
};
const calculateWordsByLines = (_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
  const {
    maxLines,
    children,
    style,
    breakAll
  } = _ref2;
  const shouldLimitLines = isNumber(maxLines);
  const text = children;
  const calculate = function calculate2() {
    const words2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return words2.reduce((result2, _ref3) => {
      const {
        word,
        width
      } = _ref3;
      const currentLine = result2[result2.length - 1];
      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        const newLine = {
          words: [word],
          width
        };
        result2.push(newLine);
      }
      return result2;
    }, []);
  };
  const originalResult = calculate(initialWordsWithComputedWith);
  const findLongestLine = (words2) => words2.reduce((a2, b) => a2.width > b.width ? a2 : b);
  if (!shouldLimitLines || scaleToFit) {
    return originalResult;
  }
  const overflows = originalResult.length > maxLines || findLongestLine(originalResult).width > Number(lineWidth);
  if (!overflows) {
    return originalResult;
  }
  const suffix = "";
  const checkOverflow = (index2) => {
    const tempText = text.slice(0, index2);
    const words2 = calculateWordWidths({
      breakAll,
      style,
      children: tempText + suffix
    }).wordsWithComputedWidth;
    const result2 = calculate(words2);
    const doesOverflow = result2.length > maxLines || findLongestLine(result2).width > Number(lineWidth);
    return [doesOverflow, result2];
  };
  let start = 0;
  let end = text.length - 1;
  let iterations = 0;
  let trimmedResult;
  while (start <= end && iterations <= text.length - 1) {
    const middle = Math.floor((start + end) / 2);
    const prev = middle - 1;
    const [doesPrevOverflow, result] = checkOverflow(prev);
    const [doesMiddleOverflow] = checkOverflow(middle);
    if (!doesPrevOverflow && !doesMiddleOverflow) {
      start = middle + 1;
    }
    if (doesPrevOverflow && doesMiddleOverflow) {
      end = middle - 1;
    }
    if (!doesPrevOverflow && doesMiddleOverflow) {
      trimmedResult = result;
      break;
    }
    iterations++;
  }
  return trimmedResult || originalResult;
};
const getWordsWithoutCalculate = (children) => {
  const words2 = !isNullish(children) ? children.toString().split(BREAKING_SPACES) : [];
  return [{
    words: words2
  }];
};
const getWordsByLines = (_ref4) => {
  const {
    width,
    scaleToFit,
    children,
    style,
    breakAll,
    maxLines
  } = _ref4;
  if ((width || scaleToFit) && !Global.isSsr) {
    let wordsWithComputedWidth, spaceWidth;
    const wordWidths = calculateWordWidths({
      breakAll,
      children,
      style
    });
    if (wordWidths) {
      const {
        wordsWithComputedWidth: wcw,
        spaceWidth: sw
      } = wordWidths;
      wordsWithComputedWidth = wcw;
      spaceWidth = sw;
    } else {
      return getWordsWithoutCalculate(children);
    }
    return calculateWordsByLines({
      breakAll,
      children,
      maxLines,
      style
    }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
  }
  return getWordsWithoutCalculate(children);
};
const DEFAULT_FILL = "#808080";
const Text = (0, import_react23.forwardRef)((_ref5, ref) => {
  let {
    x: propsX = 0,
    y: propsY = 0,
    lineHeight = "1em",
    // Magic number from d3
    capHeight = "0.71em",
    scaleToFit = false,
    textAnchor = "start",
    // Maintain compat with existing charts / default SVG behavior
    verticalAnchor = "end",
    fill: fill2 = DEFAULT_FILL
  } = _ref5, props = _objectWithoutProperties7(_ref5, _excluded7);
  const wordsByLines = (0, import_react23.useMemo)(() => {
    return getWordsByLines({
      breakAll: props.breakAll,
      children: props.children,
      maxLines: props.maxLines,
      scaleToFit,
      style: props.style,
      width: props.width
    });
  }, [props.breakAll, props.children, props.maxLines, scaleToFit, props.style, props.width]);
  let {
    dx,
    dy,
    angle,
    className,
    breakAll
  } = props, textProps = _objectWithoutProperties7(props, _excluded22);
  if (!isNumOrStr(propsX) || !isNumOrStr(propsY) || wordsByLines.length === 0) {
    return null;
  }
  const x2 = propsX + (isNumber(dx) ? dx : 0);
  const y2 = propsY + (isNumber(dy) ? dy : 0);
  let startDy;
  switch (verticalAnchor) {
    case "start":
      startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
      break;
    case "middle":
      startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
      break;
    default:
      startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
      break;
  }
  const transforms = [];
  if (scaleToFit) {
    const lineWidth = wordsByLines[0].width;
    const {
      width
    } = props;
    transforms.push("scale(".concat(isNumber(width) ? width / lineWidth : 1, ")"));
  }
  if (angle) {
    transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
  }
  if (transforms.length) {
    textProps.transform = transforms.join(" ");
  }
  return React16.createElement("text", _extends12({}, filterProps(textProps, true), {
    ref,
    x: x2,
    y: y2,
    className: clsx("recharts-text", className),
    textAnchor,
    fill: fill2.includes("url") ? DEFAULT_FILL : fill2
  }), wordsByLines.map((line, index2) => {
    const words2 = line.words.join(breakAll ? "" : " ");
    return (
      // duplicate words will cause duplicate keys
      // eslint-disable-next-line react/no-array-index-key
      React16.createElement("tspan", {
        x: x2,
        dy: index2 === 0 ? startDy : lineHeight,
        key: "".concat(words2, "-").concat(index2)
      }, words2)
    );
  }));
});
Text.displayName = "Text";

// node_modules/recharts/es6/component/Label.js
const React17 = __toESM(require_react());
const import_react24 = __toESM(require_react());
const _excluded8 = ["labelRef"];
function _objectWithoutProperties8(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose8(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose8(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys24(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread24(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys24(Object(t), true).forEach(function(r2) {
      _defineProperty25(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys24(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty25(e, r, t) {
  return (r = _toPropertyKey25(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey25(t) {
  const i = _toPrimitive25(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive25(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends13() {
  return _extends13 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends13.apply(null, arguments);
}
const CartesianLabelContext = (0, import_react24.createContext)(null);
const CartesianLabelContextProvider = (_ref2) => {
  const {
    x: x2,
    y: y2,
    width,
    height,
    children
  } = _ref2;
  const viewBox = (0, import_react24.useMemo)(() => ({
    x: x2,
    y: y2,
    width,
    height
  }), [x2, y2, width, height]);
  return React17.createElement(CartesianLabelContext.Provider, {
    value: viewBox
  }, children);
};
const useCartesianLabelContext = () => {
  const labelChildContext = (0, import_react24.useContext)(CartesianLabelContext);
  const chartContext = useViewBox();
  return labelChildContext || chartContext;
};
const PolarLabelContext = (0, import_react24.createContext)(null);
const PolarLabelContextProvider = (_ref2) => {
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise,
    children
  } = _ref2;
  const viewBox = (0, import_react24.useMemo)(() => ({
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise
  }), [cx, cy, innerRadius, outerRadius, startAngle, endAngle, clockWise]);
  return React17.createElement(PolarLabelContext.Provider, {
    value: viewBox
  }, children);
};
const usePolarLabelContext = () => {
  const labelChildContext = (0, import_react24.useContext)(PolarLabelContext);
  const chartContext = useAppSelector(selectPolarViewBox);
  return labelChildContext || chartContext;
};
const getLabel = (props) => {
  const {
    value,
    formatter
  } = props;
  const label = isNullish(props.children) ? value : props.children;
  if (typeof formatter === "function") {
    return formatter(label);
  }
  return label;
};
const isLabelContentAFunction = (content) => {
  return content != null && typeof content === "function";
};
const getDeltaAngle2 = (startAngle, endAngle) => {
  const sign2 = mathSign(endAngle - startAngle);
  const deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
const renderRadialLabel = (labelProps, position2, label, attrs, viewBox) => {
  const {
    offset,
    className
  } = labelProps;
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle,
    clockWise
  } = viewBox;
  const radius = (innerRadius + outerRadius) / 2;
  const deltaAngle = getDeltaAngle2(startAngle, endAngle);
  const sign2 = deltaAngle >= 0 ? 1 : -1;
  let labelAngle, direction;
  switch (position2) {
    case "insideStart":
      labelAngle = startAngle + sign2 * offset;
      direction = clockWise;
      break;
    case "insideEnd":
      labelAngle = endAngle - sign2 * offset;
      direction = !clockWise;
      break;
    case "end":
      labelAngle = endAngle + sign2 * offset;
      direction = clockWise;
      break;
    default:
      throw new Error("Unsupported position ".concat(position2));
  }
  direction = deltaAngle <= 0 ? direction : !direction;
  const startPoint = polarToCartesian(cx, cy, radius, labelAngle);
  const endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
  const path2 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
  const id = isNullish(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
  return React17.createElement("text", _extends13({}, attrs, {
    dominantBaseline: "central",
    className: clsx("recharts-radial-bar-label", className)
  }), React17.createElement("defs", null, React17.createElement("path", {
    id,
    d: path2
  })), React17.createElement("textPath", {
    xlinkHref: "#".concat(id)
  }, label));
};
const getAttrsOfPolarLabel = (viewBox, offset, position2) => {
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    startAngle,
    endAngle
  } = viewBox;
  const midAngle = (startAngle + endAngle) / 2;
  if (position2 === "outside") {
    const {
      x: _x,
      y: _y
    } = polarToCartesian(cx, cy, outerRadius + offset, midAngle);
    return {
      x: _x,
      y: _y,
      textAnchor: _x >= cx ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (position2 === "center") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  }
  if (position2 === "centerTop") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  }
  if (position2 === "centerBottom") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  }
  const r = (innerRadius + outerRadius) / 2;
  const {
    x: x2,
    y: y2
  } = polarToCartesian(cx, cy, r, midAngle);
  return {
    x: x2,
    y: y2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
};
const isPolar = (viewBox) => "cx" in viewBox && isNumber(viewBox.cx);
const getAttrsOfCartesianLabel = (props, viewBox) => {
  const {
    parentViewBox: parentViewBoxFromProps,
    offset,
    position: position2
  } = props;
  let parentViewBox;
  if (parentViewBoxFromProps != null && !isPolar(parentViewBoxFromProps)) {
    parentViewBox = parentViewBoxFromProps;
  }
  const {
    x: x2,
    y: y2,
    width,
    height
  } = viewBox;
  const verticalSign = height >= 0 ? 1 : -1;
  const verticalOffset = verticalSign * offset;
  const verticalEnd = verticalSign > 0 ? "end" : "start";
  const verticalStart = verticalSign > 0 ? "start" : "end";
  const horizontalSign = width >= 0 ? 1 : -1;
  const horizontalOffset = horizontalSign * offset;
  const horizontalEnd = horizontalSign > 0 ? "end" : "start";
  const horizontalStart = horizontalSign > 0 ? "start" : "end";
  if (position2 === "top") {
    const attrs = {
      x: x2 + width / 2,
      y: y2 - verticalSign * offset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    };
    return _objectSpread24(_objectSpread24({}, attrs), parentViewBox ? {
      height: Math.max(y2 - parentViewBox.y, 0),
      width
    } : {});
  }
  if (position2 === "bottom") {
    const _attrs = {
      x: x2 + width / 2,
      y: y2 + height + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    };
    return _objectSpread24(_objectSpread24({}, _attrs), parentViewBox ? {
      height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
      width
    } : {});
  }
  if (position2 === "left") {
    const _attrs2 = {
      x: x2 - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    };
    return _objectSpread24(_objectSpread24({}, _attrs2), parentViewBox ? {
      width: Math.max(_attrs2.x - parentViewBox.x, 0),
      height
    } : {});
  }
  if (position2 === "right") {
    const _attrs3 = {
      x: x2 + width + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    };
    return _objectSpread24(_objectSpread24({}, _attrs3), parentViewBox ? {
      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
      height
    } : {});
  }
  const sizeAttrs = parentViewBox ? {
    width,
    height
  } : {};
  if (position2 === "insideLeft") {
    return _objectSpread24({
      x: x2 + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position2 === "insideRight") {
    return _objectSpread24({
      x: x2 + width - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position2 === "insideTop") {
    return _objectSpread24({
      x: x2 + width / 2,
      y: y2 + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position2 === "insideBottom") {
    return _objectSpread24({
      x: x2 + width / 2,
      y: y2 + height - verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position2 === "insideTopLeft") {
    return _objectSpread24({
      x: x2 + horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position2 === "insideTopRight") {
    return _objectSpread24({
      x: x2 + width - horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position2 === "insideBottomLeft") {
    return _objectSpread24({
      x: x2 + horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position2 === "insideBottomRight") {
    return _objectSpread24({
      x: x2 + width - horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (!!position2 && typeof position2 === "object" && (isNumber(position2.x) || isPercent(position2.x)) && (isNumber(position2.y) || isPercent(position2.y))) {
    return _objectSpread24({
      x: x2 + getPercentValue(position2.x, width),
      y: y2 + getPercentValue(position2.y, height),
      textAnchor: "end",
      verticalAnchor: "end"
    }, sizeAttrs);
  }
  return _objectSpread24({
    x: x2 + width / 2,
    y: y2 + height / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, sizeAttrs);
};
const defaultLabelProps = {
  offset: 5
};
function Label(outerProps) {
  const props = resolveDefaultProps(outerProps, defaultLabelProps);
  const {
    viewBox: viewBoxFromProps,
    position: position2,
    value,
    children,
    content,
    className = "",
    textBreakAll,
    labelRef
  } = props;
  const polarViewBox = usePolarLabelContext();
  const cartesianViewBox = useCartesianLabelContext();
  const resolvedViewBox = position2 === "center" ? cartesianViewBox : polarViewBox !== null && polarViewBox !== void 0 ? polarViewBox : cartesianViewBox;
  const viewBox = viewBoxFromProps || resolvedViewBox;
  if (!viewBox || isNullish(value) && isNullish(children) && !(0, import_react24.isValidElement)(content) && typeof content !== "function") {
    return null;
  }
  const propsWithViewBox = _objectSpread24(_objectSpread24({}, props), {}, {
    viewBox
  });
  if ((0, import_react24.isValidElement)(content)) {
    let {
      labelRef: _
    } = propsWithViewBox, propsWithoutLabelRef = _objectWithoutProperties8(propsWithViewBox, _excluded8);
    return (0, import_react24.cloneElement)(content, propsWithoutLabelRef);
  }
  let label;
  if (typeof content === "function") {
    label = (0, import_react24.createElement)(content, propsWithViewBox);
    if ((0, import_react24.isValidElement)(label)) {
      return label;
    }
  } else {
    label = getLabel(props);
  }
  const isPolarLabel = isPolar(viewBox);
  const attrs = filterProps(props, true);
  if (isPolarLabel && (position2 === "insideStart" || position2 === "insideEnd" || position2 === "end")) {
    return renderRadialLabel(props, position2, label, attrs, viewBox);
  }
  const positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(viewBox, props.offset, props.position) : getAttrsOfCartesianLabel(props, viewBox);
  return React17.createElement(Text, _extends13({
    ref: labelRef,
    className: clsx("recharts-label", className)
  }, attrs, positionAttrs, {
    breakAll: textBreakAll
  }), label);
}
Label.displayName = "Label";
const parseLabel = (label, viewBox, labelRef) => {
  if (!label) {
    return null;
  }
  const commonProps = {
    viewBox,
    labelRef
  };
  if (label === true) {
    return React17.createElement(Label, _extends13({
      key: "label-implicit"
    }, commonProps));
  }
  if (isNumOrStr(label)) {
    return React17.createElement(Label, _extends13({
      key: "label-implicit",
      value: label
    }, commonProps));
  }
  if ((0, import_react24.isValidElement)(label)) {
    if (label.type === Label) {
      return (0, import_react24.cloneElement)(label, _objectSpread24({
        key: "label-implicit"
      }, commonProps));
    }
    return React17.createElement(Label, _extends13({
      key: "label-implicit",
      content: label
    }, commonProps));
  }
  if (isLabelContentAFunction(label)) {
    return React17.createElement(Label, _extends13({
      key: "label-implicit",
      content: label
    }, commonProps));
  }
  if (label && typeof label === "object") {
    return React17.createElement(Label, _extends13({}, label, {
      key: "label-implicit"
    }, commonProps));
  }
  return null;
};
function CartesianLabelFromLabelProp(_ref3) {
  const {
    label
  } = _ref3;
  const viewBox = useCartesianLabelContext();
  return parseLabel(label, viewBox) || null;
}
function PolarLabelFromLabelProp(_ref4) {
  const {
    label
  } = _ref4;
  const viewBox = usePolarLabelContext();
  return parseLabel(label, viewBox) || null;
}

// node_modules/recharts/es6/component/LabelList.js
const React18 = __toESM(require_react());
const import_react25 = __toESM(require_react());
const import_last2 = __toESM(require_last3());
const _excluded9 = ["valueAccessor"];
const _excluded23 = ["dataKey", "clockWise", "id", "textBreakAll"];
function _extends14() {
  return _extends14 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends14.apply(null, arguments);
}
function _objectWithoutProperties9(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose9(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose9(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const defaultAccessor = (entry) => Array.isArray(entry.value) ? (0, import_last2.default)(entry.value) : entry.value;
const CartesianLabelListContext = (0, import_react25.createContext)(void 0);
const CartesianLabelListContextProvider = CartesianLabelListContext.Provider;
const PolarLabelListContext = (0, import_react25.createContext)(void 0);
const PolarLabelListContextProvider = PolarLabelListContext.Provider;
function useCartesianLabelListContext() {
  return (0, import_react25.useContext)(CartesianLabelListContext);
}
function usePolarLabelListContext() {
  return (0, import_react25.useContext)(PolarLabelListContext);
}
function LabelList(_ref2) {
  let {
    valueAccessor = defaultAccessor
  } = _ref2, restProps = _objectWithoutProperties9(_ref2, _excluded9);
  let {
    dataKey,
    clockWise,
    id,
    textBreakAll
  } = restProps, others = _objectWithoutProperties9(restProps, _excluded23);
  const cartesianData = useCartesianLabelListContext();
  const polarData = usePolarLabelListContext();
  const data = cartesianData || polarData;
  if (!data || !data.length) {
    return null;
  }
  return React18.createElement(Layer, {
    className: "recharts-label-list"
  }, data.map((entry, index2) => {
    let _restProps$fill;
    const value = isNullish(dataKey) ? valueAccessor(entry, index2) : getValueByDataKey(entry && entry.payload, dataKey);
    const idProps = isNullish(id) ? {} : {
      id: "".concat(id, "-").concat(index2)
    };
    return React18.createElement(Label, _extends14({}, filterProps(entry, true), others, idProps, {
      /*
       * Prefer to use the explicit fill from LabelList props.
       * Only in an absence of that, fall back to the fill of the entry.
       * The entry fill can be quite difficult to see especially in Bar, Pie, RadialBar in inside positions.
       * On the other hand it's quite convenient in Scatter, Line, or when the position is outside the Bar, Pie filled shapes.
       */
      fill: (_restProps$fill = restProps.fill) !== null && _restProps$fill !== void 0 ? _restProps$fill : entry.fill,
      parentViewBox: entry.parentViewBox,
      value,
      textBreakAll,
      viewBox: entry.viewBox,
      key: "label-".concat(index2),
      index: index2
    }));
  }));
}
LabelList.displayName = "LabelList";
function LabelListFromLabelProp(_ref2) {
  const {
    label
  } = _ref2;
  if (!label) {
    return null;
  }
  if (label === true) {
    return React18.createElement(LabelList, {
      key: "labelList-implicit"
    });
  }
  if (React18.isValidElement(label) || isLabelContentAFunction(label)) {
    return React18.createElement(LabelList, {
      key: "labelList-implicit",
      content: label
    });
  }
  if (typeof label === "object") {
    return React18.createElement(LabelList, _extends14({
      key: "labelList-implicit"
    }, label, {
      type: String(label.type)
    }));
  }
  return null;
}

// node_modules/recharts/es6/component/Customized.js
const React19 = __toESM(require_react());
const import_react26 = __toESM(require_react());
const _excluded10 = ["component"];
function _objectWithoutProperties10(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose10(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose10(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function Customized(_ref2) {
  let {
    component
  } = _ref2, props = _objectWithoutProperties10(_ref2, _excluded10);
  let child;
  if ((0, import_react26.isValidElement)(component)) {
    child = (0, import_react26.cloneElement)(component, props);
  } else if (typeof component === "function") {
    child = (0, import_react26.createElement)(component, props);
  } else {
    warn(false, "Customized's props `component` must be React.element or Function, but got %s.", typeof component);
  }
  return React19.createElement(Layer, {
    className: "recharts-customized-wrapper"
  }, child);
}
Customized.displayName = "Customized";

// node_modules/recharts/es6/shape/Polygon.js
const React20 = __toESM(require_react());
const _excluded11 = ["points", "className", "baseLinePoints", "connectNulls"];
function _extends15() {
  return _extends15 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends15.apply(null, arguments);
}
function _objectWithoutProperties11(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose11(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose11(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const isValidatePoint = (point6) => {
  return point6 && point6.x === +point6.x && point6.y === +point6.y;
};
const getParsedPoints = function getParsedPoints2() {
  const points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let segmentPoints = [[]];
  points.forEach((entry) => {
    if (isValidatePoint(entry)) {
      segmentPoints[segmentPoints.length - 1].push(entry);
    } else if (segmentPoints[segmentPoints.length - 1].length > 0) {
      segmentPoints.push([]);
    }
  });
  if (isValidatePoint(points[0])) {
    segmentPoints[segmentPoints.length - 1].push(points[0]);
  }
  if (segmentPoints[segmentPoints.length - 1].length <= 0) {
    segmentPoints = segmentPoints.slice(0, -1);
  }
  return segmentPoints;
};
const getSinglePolygonPath = (points, connectNulls) => {
  let segmentPoints = getParsedPoints(points);
  if (connectNulls) {
    segmentPoints = [segmentPoints.reduce((res, segPoints) => {
      return [...res, ...segPoints];
    }, [])];
  }
  const polygonPath = segmentPoints.map((segPoints) => {
    return segPoints.reduce((path2, point6, index2) => {
      return "".concat(path2).concat(index2 === 0 ? "M" : "L").concat(point6.x, ",").concat(point6.y);
    }, "");
  }).join("");
  return segmentPoints.length === 1 ? "".concat(polygonPath, "Z") : polygonPath;
};
const getRanglePath = (points, baseLinePoints, connectNulls) => {
  const outerPath = getSinglePolygonPath(points, connectNulls);
  return "".concat(outerPath.slice(-1) === "Z" ? outerPath.slice(0, -1) : outerPath, "L").concat(getSinglePolygonPath(Array.from(baseLinePoints).reverse(), connectNulls).slice(1));
};
const Polygon = (props) => {
  let {
    points,
    className,
    baseLinePoints,
    connectNulls
  } = props, others = _objectWithoutProperties11(props, _excluded11);
  if (!points || !points.length) {
    return null;
  }
  const layerClass = clsx("recharts-polygon", className);
  if (baseLinePoints && baseLinePoints.length) {
    const hasStroke = others.stroke && others.stroke !== "none";
    const rangePath = getRanglePath(points, baseLinePoints, connectNulls);
    return React20.createElement("g", {
      className: layerClass
    }, React20.createElement("path", _extends15({}, filterProps(others, true), {
      fill: rangePath.slice(-1) === "Z" ? others.fill : "none",
      stroke: "none",
      d: rangePath
    })), hasStroke ? React20.createElement("path", _extends15({}, filterProps(others, true), {
      fill: "none",
      d: getSinglePolygonPath(points, connectNulls)
    })) : null, hasStroke ? React20.createElement("path", _extends15({}, filterProps(others, true), {
      fill: "none",
      d: getSinglePolygonPath(baseLinePoints, connectNulls)
    })) : null);
  }
  const singlePath = getSinglePolygonPath(points, connectNulls);
  return React20.createElement("path", _extends15({}, filterProps(others, true), {
    fill: singlePath.slice(-1) === "Z" ? others.fill : "none",
    className: layerClass,
    d: singlePath
  }));
};

// node_modules/recharts/es6/shape/Dot.js
const React21 = __toESM(require_react());
function _extends16() {
  return _extends16 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends16.apply(null, arguments);
}
const Dot = (props) => {
  const {
    cx,
    cy,
    r,
    className
  } = props;
  const layerClass = clsx("recharts-dot", className);
  if (cx === +cx && cy === +cy && r === +r) {
    return React21.createElement("circle", _extends16({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
      className: layerClass,
      cx,
      cy,
      r
    }));
  }
  return null;
};

// node_modules/recharts/es6/polar/PolarGrid.js
const React22 = __toESM(require_react());

// node_modules/recharts/es6/state/selectors/polarSelectors.js
const selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems;
const selectAxisPredicate2 = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
const selectPolarItemsSettings = createSelector([selectUnfilteredPolarItems, selectBaseAxis, selectAxisPredicate2], combineGraphicalItemsSettings);
const selectPolarGraphicalItemsData = createSelector([selectPolarItemsSettings], combineGraphicalItemsData);
const selectPolarDisplayedData = createSelector([selectPolarGraphicalItemsData, selectChartDataAndAlwaysIgnoreIndexes], combineDisplayedData);
const selectPolarAppliedValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], combineAppliedValues);
const selectAllPolarAppliedNumericalValues = createSelector([selectPolarDisplayedData, selectBaseAxis, selectPolarItemsSettings], (data, axisSettings, items) => {
  if (items.length > 0) {
    return data.flatMap((entry) => {
      return items.flatMap((item) => {
        let _axisSettings$dataKey;
        const valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
        return {
          value: valueByDataKey,
          errorDomain: []
          // polar charts do not have error bars
        };
      });
    }).filter(Boolean);
  }
  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {
    return data.map((item) => ({
      value: getValueByDataKey(item, axisSettings.dataKey),
      errorDomain: []
    }));
  }
  return data.map((entry) => ({
    value: entry,
    errorDomain: []
  }));
});
const unsupportedInPolarChart = () => void 0;
const selectPolarNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, unsupportedInPolarChart, selectAllPolarAppliedNumericalValues, unsupportedInPolarChart, selectChartLayout, pickAxisType], combineNumericalDomain);
const selectPolarAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectPolarDisplayedData, selectPolarAppliedValues, selectStackOffsetType, pickAxisType, selectPolarNumericalDomain], combineAxisDomain);
const selectPolarNiceTicks = createSelector([selectPolarAxisDomain, selectBaseAxis, selectRealScaleType], combineNiceTicks);
const selectPolarAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectPolarAxisDomain, selectPolarNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);

// node_modules/recharts/es6/state/selectors/polarScaleSelectors.js
const selectPolarAxis = (state, axisType, axisId) => {
  switch (axisType) {
    case "angleAxis": {
      return selectAngleAxis(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxis(state, axisId);
    }
    default: {
      throw new Error("Unexpected axis type: ".concat(axisType));
    }
  }
};
const selectPolarAxisRangeWithReversed = (state, axisType, axisId) => {
  switch (axisType) {
    case "angleAxis": {
      return selectAngleAxisRangeWithReversed(state, axisId);
    }
    case "radiusAxis": {
      return selectRadiusAxisRangeWithReversed(state, axisId);
    }
    default: {
      throw new Error("Unexpected axis type: ".concat(axisType));
    }
  }
};
const selectPolarAxisScale = createSelector([selectPolarAxis, selectRealScaleType, selectPolarAxisDomainIncludingNiceTicks, selectPolarAxisRangeWithReversed], combineScaleFunction);
const selectPolarCategoricalDomain = createSelector([selectChartLayout, selectPolarAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);
const selectPolarAxisTicks = createSelector([selectChartLayout, selectPolarAxis, selectRealScaleType, selectPolarAxisScale, selectPolarNiceTicks, selectPolarAxisRangeWithReversed, selectDuplicateDomain, selectPolarCategoricalDomain, pickAxisType], combineAxisTicks);
const selectPolarGraphicalItemAxisTicks = createSelector([selectChartLayout, selectPolarAxis, selectPolarAxisScale, selectPolarAxisRangeWithReversed, selectDuplicateDomain, selectPolarCategoricalDomain, pickAxisType], combineGraphicalItemTicks);

// node_modules/recharts/es6/state/selectors/polarGridSelectors.js
const selectAngleAxisTicks = (state, anglexisId) => selectPolarAxisTicks(state, "angleAxis", anglexisId, false);
const selectPolarGridAngles = createSelector([selectAngleAxisTicks], (ticks2) => {
  if (!ticks2) {
    return void 0;
  }
  return ticks2.map((tick) => tick.coordinate);
});
const selectRadiusAxisTicks = (state, radiusAxisId) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false);
const selectPolarGridRadii = createSelector([selectRadiusAxisTicks], (ticks2) => {
  if (!ticks2) {
    return void 0;
  }
  return ticks2.map((tick) => tick.coordinate);
});

// node_modules/recharts/es6/polar/PolarGrid.js
const _excluded12 = ["gridType", "radialLines", "angleAxisId", "radiusAxisId", "cx", "cy", "innerRadius", "outerRadius"];
function _objectWithoutProperties12(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose12(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose12(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends17() {
  return _extends17 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends17.apply(null, arguments);
}
function ownKeys25(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread25(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys25(Object(t), true).forEach(function(r2) {
      _defineProperty26(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty26(e, r, t) {
  return (r = _toPropertyKey26(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey26(t) {
  const i = _toPrimitive26(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive26(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const getPolygonPath = (radius, cx, cy, polarAngles) => {
  let path2 = "";
  polarAngles.forEach((angle, i) => {
    const point6 = polarToCartesian(cx, cy, radius, angle);
    if (i) {
      path2 += "L ".concat(point6.x, ",").concat(point6.y);
    } else {
      path2 += "M ".concat(point6.x, ",").concat(point6.y);
    }
  });
  path2 += "Z";
  return path2;
};
const PolarAngles = (props) => {
  const {
    cx,
    cy,
    innerRadius,
    outerRadius,
    polarAngles,
    radialLines
  } = props;
  if (!polarAngles || !polarAngles.length || !radialLines) {
    return null;
  }
  const polarAnglesProps = _objectSpread25({
    stroke: "#ccc"
  }, svgPropertiesNoEvents(props));
  return React22.createElement("g", {
    className: "recharts-polar-grid-angle"
  }, polarAngles.map((entry) => {
    const start = polarToCartesian(cx, cy, innerRadius, entry);
    const end = polarToCartesian(cx, cy, outerRadius, entry);
    return React22.createElement("line", _extends17({}, polarAnglesProps, {
      key: "line-".concat(entry),
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y
    }));
  }));
};
const ConcentricCircle = (props) => {
  const {
    cx,
    cy,
    radius
  } = props;
  const concentricCircleProps = _objectSpread25({
    stroke: "#ccc",
    fill: "none"
  }, svgPropertiesNoEvents(props));
  return (
    // @ts-expect-error wrong SVG element type
    React22.createElement("circle", _extends17({}, concentricCircleProps, {
      className: clsx("recharts-polar-grid-concentric-circle", props.className),
      cx,
      cy,
      r: radius
    }))
  );
};
const ConcentricPolygon = (props) => {
  const {
    radius
  } = props;
  const concentricPolygonProps = _objectSpread25({
    stroke: "#ccc",
    fill: "none"
  }, svgPropertiesNoEvents(props));
  return React22.createElement("path", _extends17({}, concentricPolygonProps, {
    className: clsx("recharts-polar-grid-concentric-polygon", props.className),
    d: getPolygonPath(radius, props.cx, props.cy, props.polarAngles)
  }));
};
const ConcentricGridPath = (props) => {
  const {
    polarRadius,
    gridType
  } = props;
  if (!polarRadius || !polarRadius.length) {
    return null;
  }
  const maxPolarRadius = Math.max(...polarRadius);
  const renderBackground = props.fill && props.fill !== "none";
  return React22.createElement("g", {
    className: "recharts-polar-grid-concentric"
  }, renderBackground && gridType === "circle" && React22.createElement(ConcentricCircle, _extends17({}, props, {
    radius: maxPolarRadius
  })), renderBackground && gridType !== "circle" && React22.createElement(ConcentricPolygon, _extends17({}, props, {
    radius: maxPolarRadius
  })), polarRadius.map((entry, i) => {
    const key = i;
    if (gridType === "circle") {
      return React22.createElement(ConcentricCircle, _extends17({
        key
      }, props, {
        fill: "none",
        radius: entry
      }));
    }
    return React22.createElement(ConcentricPolygon, _extends17({
      key
    }, props, {
      fill: "none",
      radius: entry
    }));
  }));
};
const PolarGrid = (_ref2) => {
  let _ref22, _polarViewBox$cx, _ref3, _polarViewBox$cy, _ref4, _polarViewBox$innerRa, _ref5, _polarViewBox$outerRa;
  let {
    gridType = "polygon",
    radialLines = true,
    angleAxisId = 0,
    radiusAxisId = 0,
    cx: cxFromOutside,
    cy: cyFromOutside,
    innerRadius: innerRadiusFromOutside,
    outerRadius: outerRadiusFromOutside
  } = _ref2, inputs = _objectWithoutProperties12(_ref2, _excluded12);
  const polarViewBox = useAppSelector(selectPolarViewBox);
  const props = _objectSpread25({
    cx: (_ref22 = (_polarViewBox$cx = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cx) !== null && _polarViewBox$cx !== void 0 ? _polarViewBox$cx : cxFromOutside) !== null && _ref22 !== void 0 ? _ref22 : 0,
    cy: (_ref3 = (_polarViewBox$cy = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cy) !== null && _polarViewBox$cy !== void 0 ? _polarViewBox$cy : cyFromOutside) !== null && _ref3 !== void 0 ? _ref3 : 0,
    innerRadius: (_ref4 = (_polarViewBox$innerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.innerRadius) !== null && _polarViewBox$innerRa !== void 0 ? _polarViewBox$innerRa : innerRadiusFromOutside) !== null && _ref4 !== void 0 ? _ref4 : 0,
    outerRadius: (_ref5 = (_polarViewBox$outerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.outerRadius) !== null && _polarViewBox$outerRa !== void 0 ? _polarViewBox$outerRa : outerRadiusFromOutside) !== null && _ref5 !== void 0 ? _ref5 : 0
  }, inputs);
  const {
    polarAngles: polarAnglesInput,
    polarRadius: polarRadiusInput,
    outerRadius
  } = props;
  const polarAnglesFromRedux = useAppSelector((state) => selectPolarGridAngles(state, angleAxisId));
  const polarRadiiFromRedux = useAppSelector((state) => selectPolarGridRadii(state, radiusAxisId));
  const polarAngles = Array.isArray(polarAnglesInput) ? polarAnglesInput : polarAnglesFromRedux;
  const polarRadius = Array.isArray(polarRadiusInput) ? polarRadiusInput : polarRadiiFromRedux;
  if (outerRadius <= 0 || polarAngles == null || polarRadius == null) {
    return null;
  }
  return React22.createElement("g", {
    className: "recharts-polar-grid"
  }, React22.createElement(ConcentricGridPath, _extends17({
    gridType,
    radialLines
  }, props, {
    polarAngles,
    polarRadius
  })), React22.createElement(PolarAngles, _extends17({
    gridType,
    radialLines
  }, props, {
    polarAngles,
    polarRadius
  })));
};
PolarGrid.displayName = "PolarGrid";

// node_modules/recharts/es6/polar/PolarRadiusAxis.js
const React23 = __toESM(require_react());
const import_react27 = __toESM(require_react());
const import_maxBy2 = __toESM(require_maxBy3());
const import_minBy2 = __toESM(require_minBy3());

// node_modules/recharts/es6/state/polarAxisSlice.js
const initialState5 = {
  radiusAxis: {},
  angleAxis: {}
};
const polarAxisSlice = createSlice({
  name: "polarAxis",
  initialState: initialState5,
  reducers: {
    addRadiusAxis(state, action) {
      state.radiusAxis[action.payload.id] = castDraft(action.payload);
    },
    removeRadiusAxis(state, action) {
      delete state.radiusAxis[action.payload.id];
    },
    addAngleAxis(state, action) {
      state.angleAxis[action.payload.id] = castDraft(action.payload);
    },
    removeAngleAxis(state, action) {
      delete state.angleAxis[action.payload.id];
    }
  }
});
const {
  addRadiusAxis,
  removeRadiusAxis,
  addAngleAxis,
  removeAngleAxis
} = polarAxisSlice.actions;
const polarAxisReducer = polarAxisSlice.reducer;

// node_modules/recharts/es6/polar/PolarRadiusAxis.js
const _excluded13 = ["cx", "cy", "angle", "axisLine"];
const _excluded24 = ["angle", "tickFormatter", "stroke", "tick"];
function _extends18() {
  return _extends18 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends18.apply(null, arguments);
}
function ownKeys26(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread26(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys26(Object(t), true).forEach(function(r2) {
      _defineProperty27(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys26(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty27(e, r, t) {
  return (r = _toPropertyKey27(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey27(t) {
  const i = _toPrimitive27(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive27(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties13(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose13(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose13(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const AXIS_TYPE = "radiusAxis";
function SetRadiusAxisSettings(settings) {
  const dispatch = useAppDispatch();
  (0, import_react27.useEffect)(() => {
    dispatch(addRadiusAxis(settings));
    return () => {
      dispatch(removeRadiusAxis(settings));
    };
  });
  return null;
}
const getTickValueCoord = (_ref2, angle, cx, cy) => {
  const {
    coordinate
  } = _ref2;
  return polarToCartesian(cx, cy, coordinate, angle);
};
const getTickTextAnchor = (orientation) => {
  let textAnchor;
  switch (orientation) {
    case "left":
      textAnchor = "end";
      break;
    case "right":
      textAnchor = "start";
      break;
    default:
      textAnchor = "middle";
      break;
  }
  return textAnchor;
};
const getViewBox = (angle, cx, cy, ticks2) => {
  const maxRadiusTick = (0, import_maxBy2.default)(ticks2, (entry) => entry.coordinate || 0);
  const minRadiusTick = (0, import_minBy2.default)(ticks2, (entry) => entry.coordinate || 0);
  return {
    cx,
    cy,
    startAngle: angle,
    endAngle: angle,
    innerRadius: minRadiusTick.coordinate || 0,
    outerRadius: maxRadiusTick.coordinate || 0,
    clockWise: false
  };
};
const renderAxisLine = (props, ticks2) => {
  let {
    cx,
    cy,
    angle,
    axisLine
  } = props, others = _objectWithoutProperties13(props, _excluded13);
  const extent2 = ticks2.reduce((result, entry) => [Math.min(result[0], entry.coordinate), Math.max(result[1], entry.coordinate)], [Infinity, -Infinity]);
  const point0 = polarToCartesian(cx, cy, extent2[0], angle);
  const point1 = polarToCartesian(cx, cy, extent2[1], angle);
  const axisLineProps = _objectSpread26(_objectSpread26(_objectSpread26({}, svgPropertiesNoEvents(others)), {}, {
    fill: "none"
  }, filterProps(axisLine, false)), {}, {
    x1: point0.x,
    y1: point0.y,
    x2: point1.x,
    y2: point1.y
  });
  return React23.createElement("line", _extends18({
    className: "recharts-polar-radius-axis-line"
  }, axisLineProps));
};
const renderTickItem = (option, tickProps, value) => {
  let tickItem;
  if (React23.isValidElement(option)) {
    tickItem = React23.cloneElement(option, tickProps);
  } else if (typeof option === "function") {
    tickItem = option(tickProps);
  } else {
    tickItem = React23.createElement(Text, _extends18({}, tickProps, {
      className: "recharts-polar-radius-axis-tick-value"
    }), value);
  }
  return tickItem;
};
const renderTicks = (props, ticks2) => {
  let {
    angle,
    tickFormatter,
    stroke,
    tick
  } = props, others = _objectWithoutProperties13(props, _excluded24);
  const textAnchor = getTickTextAnchor(props.orientation);
  const axisProps = svgPropertiesNoEvents(others);
  const customTickProps = filterProps(tick, false);
  const items = ticks2.map((entry, i) => {
    const coord = getTickValueCoord(entry, props.angle, props.cx, props.cy);
    const tickProps = _objectSpread26(_objectSpread26(_objectSpread26(_objectSpread26({
      textAnchor,
      transform: "rotate(".concat(90 - angle, ", ").concat(coord.x, ", ").concat(coord.y, ")")
    }, axisProps), {}, {
      stroke: "none",
      fill: stroke
    }, customTickProps), {}, {
      index: i
    }, coord), {}, {
      payload: entry
    });
    return React23.createElement(Layer, _extends18({
      className: clsx("recharts-polar-radius-axis-tick", getTickClassName(tick)),
      key: "tick-".concat(entry.coordinate)
    }, adaptEventsOfChild(props, entry, i)), renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));
  });
  return React23.createElement(Layer, {
    className: "recharts-polar-radius-axis-ticks"
  }, items);
};
const PolarRadiusAxisWrapper = (defaultsAndInputs) => {
  const {
    radiusAxisId
  } = defaultsAndInputs;
  const viewBox = useAppSelector(selectPolarViewBox);
  const scale = useAppSelector((state) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId));
  const ticks2 = useAppSelector((state) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false));
  if (viewBox == null || !ticks2 || !ticks2.length) {
    return null;
  }
  const props = _objectSpread26(_objectSpread26(_objectSpread26({}, defaultsAndInputs), {}, {
    scale
  }, viewBox), {}, {
    radius: viewBox.outerRadius
  });
  const {
    tick,
    axisLine
  } = props;
  return React23.createElement(Layer, {
    className: clsx("recharts-polar-radius-axis", AXIS_TYPE, props.className)
  }, axisLine && renderAxisLine(props, ticks2), tick && renderTicks(props, ticks2), React23.createElement(PolarLabelContextProvider, getViewBox(props.angle, props.cx, props.cy, ticks2), React23.createElement(PolarLabelFromLabelProp, {
    label: props.label
  }), props.children));
};
const PolarRadiusAxis = class extends import_react27.PureComponent {
  render() {
    return React23.createElement(React23.Fragment, null, React23.createElement(SetRadiusAxisSettings, {
      domain: this.props.domain,
      id: this.props.radiusAxisId,
      scale: this.props.scale,
      type: this.props.type,
      dataKey: this.props.dataKey,
      unit: void 0,
      name: this.props.name,
      allowDuplicatedCategory: this.props.allowDuplicatedCategory,
      allowDataOverflow: this.props.allowDataOverflow,
      reversed: this.props.reversed,
      includeHidden: this.props.includeHidden,
      allowDecimals: this.props.allowDecimals,
      tickCount: this.props.tickCount,
      ticks: this.props.ticks,
      tick: this.props.tick
    }), React23.createElement(PolarRadiusAxisWrapper, this.props));
  }
};
_defineProperty27(PolarRadiusAxis, "displayName", "PolarRadiusAxis");
_defineProperty27(PolarRadiusAxis, "axisType", AXIS_TYPE);
_defineProperty27(PolarRadiusAxis, "defaultProps", defaultPolarRadiusAxisProps);

// node_modules/recharts/es6/polar/PolarAngleAxis.js
const React24 = __toESM(require_react());
const import_react28 = __toESM(require_react());
const _excluded14 = ["children"];
function _extends19() {
  return _extends19 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends19.apply(null, arguments);
}
function ownKeys27(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread27(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys27(Object(t), true).forEach(function(r2) {
      _defineProperty28(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys27(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty28(e, r, t) {
  return (r = _toPropertyKey28(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey28(t) {
  const i = _toPrimitive28(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive28(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties14(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose14(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose14(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const eps = 1e-5;
const COS_45 = Math.cos(degreeToRadian(45));
const AXIS_TYPE2 = "angleAxis";
function SetAngleAxisSettings(props) {
  const dispatch = useAppDispatch();
  const settings = (0, import_react28.useMemo)(() => {
    let {
      children
    } = props, rest2 = _objectWithoutProperties14(props, _excluded14);
    return rest2;
  }, [props]);
  const synchronizedSettings = useAppSelector((state) => selectAngleAxis(state, settings.id));
  const settingsAreSynchronized = settings === synchronizedSettings;
  (0, import_react28.useEffect)(() => {
    dispatch(addAngleAxis(settings));
    return () => {
      dispatch(removeAngleAxis(settings));
    };
  }, [dispatch, settings]);
  if (settingsAreSynchronized) {
    return props.children;
  }
  return null;
}
const getTickLineCoord = (data, props) => {
  const {
    cx,
    cy,
    radius,
    orientation,
    tickSize
  } = props;
  const tickLineSize = tickSize || 8;
  const p1 = polarToCartesian(cx, cy, radius, data.coordinate);
  const p2 = polarToCartesian(cx, cy, radius + (orientation === "inner" ? -1 : 1) * tickLineSize, data.coordinate);
  return {
    x1: p1.x,
    y1: p1.y,
    x2: p2.x,
    y2: p2.y
  };
};
const getTickTextAnchor2 = (data, orientation) => {
  const cos2 = Math.cos(degreeToRadian(-data.coordinate));
  if (cos2 > eps) {
    return orientation === "outer" ? "start" : "end";
  }
  if (cos2 < -eps) {
    return orientation === "outer" ? "end" : "start";
  }
  return "middle";
};
const getTickTextVerticalAnchor = (data) => {
  const cos2 = Math.cos(degreeToRadian(-data.coordinate));
  const sin2 = Math.sin(degreeToRadian(-data.coordinate));
  if (Math.abs(cos2) <= COS_45) {
    return sin2 > 0 ? "start" : "end";
  }
  return "middle";
};
const AxisLine = (props) => {
  const {
    cx,
    cy,
    radius,
    axisLineType,
    axisLine,
    ticks: ticks2
  } = props;
  if (!axisLine) {
    return null;
  }
  const axisLineProps = _objectSpread27(_objectSpread27({}, svgPropertiesNoEvents(props)), {}, {
    fill: "none"
  }, filterProps(axisLine, false));
  if (axisLineType === "circle") {
    return React24.createElement(Dot, _extends19({
      className: "recharts-polar-angle-axis-line"
    }, axisLineProps, {
      cx,
      cy,
      r: radius
    }));
  }
  const points = ticks2.map((entry) => polarToCartesian(cx, cy, radius, entry.coordinate));
  return React24.createElement(Polygon, _extends19({
    className: "recharts-polar-angle-axis-line"
  }, axisLineProps, {
    points
  }));
};
const TickItemText = (_ref2) => {
  const {
    tick,
    tickProps,
    value
  } = _ref2;
  if (!tick) {
    return null;
  }
  if (React24.isValidElement(tick)) {
    return React24.cloneElement(tick, tickProps);
  }
  if (typeof tick === "function") {
    return tick(tickProps);
  }
  return React24.createElement(Text, _extends19({}, tickProps, {
    className: "recharts-polar-angle-axis-tick-value"
  }), value);
};
const Ticks = (props) => {
  const {
    tick,
    tickLine,
    tickFormatter,
    stroke,
    ticks: ticks2
  } = props;
  const axisProps = svgPropertiesNoEvents(props);
  const customTickProps = filterProps(tick, false);
  const tickLineProps = _objectSpread27(_objectSpread27({}, axisProps), {}, {
    fill: "none"
  }, filterProps(tickLine, false));
  const items = ticks2.map((entry, i) => {
    const lineCoord = getTickLineCoord(entry, props);
    const textAnchor = getTickTextAnchor2(entry, props.orientation);
    const verticalAnchor = getTickTextVerticalAnchor(entry);
    const tickProps = _objectSpread27(_objectSpread27(_objectSpread27({}, axisProps), {}, {
      textAnchor,
      verticalAnchor,
      stroke: "none",
      fill: stroke
    }, customTickProps), {}, {
      index: i,
      payload: entry,
      x: lineCoord.x2,
      y: lineCoord.y2
    });
    return React24.createElement(Layer, _extends19({
      className: clsx("recharts-polar-angle-axis-tick", getTickClassName(tick)),
      key: "tick-".concat(entry.coordinate)
    }, adaptEventsOfChild(props, entry, i)), tickLine && React24.createElement("line", _extends19({
      className: "recharts-polar-angle-axis-tick-line"
    }, tickLineProps, lineCoord)), React24.createElement(TickItemText, {
      tick,
      tickProps,
      value: tickFormatter ? tickFormatter(entry.value, i) : entry.value
    }));
  });
  return React24.createElement(Layer, {
    className: "recharts-polar-angle-axis-ticks"
  }, items);
};
const PolarAngleAxisWrapper = (defaultsAndInputs) => {
  const {
    angleAxisId
  } = defaultsAndInputs;
  const viewBox = useAppSelector(selectPolarViewBox);
  const scale = useAppSelector((state) => selectPolarAxisScale(state, "angleAxis", angleAxisId));
  const isPanorama = useIsPanorama();
  const ticks2 = useAppSelector((state) => selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama));
  if (viewBox == null || !ticks2 || !ticks2.length) {
    return null;
  }
  const props = _objectSpread27(_objectSpread27(_objectSpread27({}, defaultsAndInputs), {}, {
    scale
  }, viewBox), {}, {
    radius: viewBox.outerRadius
  });
  return React24.createElement(Layer, {
    className: clsx("recharts-polar-angle-axis", AXIS_TYPE2, props.className)
  }, React24.createElement(AxisLine, _extends19({}, props, {
    ticks: ticks2
  })), React24.createElement(Ticks, _extends19({}, props, {
    ticks: ticks2
  })));
};
const PolarAngleAxis = class extends import_react28.PureComponent {
  render() {
    if (this.props.radius <= 0) return null;
    return React24.createElement(SetAngleAxisSettings, {
      id: this.props.angleAxisId,
      scale: this.props.scale,
      type: this.props.type,
      dataKey: this.props.dataKey,
      unit: void 0,
      name: this.props.name,
      allowDuplicatedCategory: false,
      allowDataOverflow: false,
      reversed: this.props.reversed,
      includeHidden: false,
      allowDecimals: this.props.allowDecimals,
      tickCount: this.props.tickCount,
      ticks: this.props.ticks,
      tick: this.props.tick,
      domain: this.props.domain
    }, React24.createElement(PolarAngleAxisWrapper, this.props));
  }
};
_defineProperty28(PolarAngleAxis, "displayName", "PolarAngleAxis");
_defineProperty28(PolarAngleAxis, "axisType", AXIS_TYPE2);
_defineProperty28(PolarAngleAxis, "defaultProps", defaultPolarAngleAxisProps);

// node_modules/recharts/es6/polar/Pie.js
const React29 = __toESM(require_react());
const import_react35 = __toESM(require_react());
const import_get4 = __toESM(require_get2());

// node_modules/recharts/es6/state/selectors/pieSelectors.js
function ownKeys28(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread28(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys28(Object(t), true).forEach(function(r2) {
      _defineProperty29(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys28(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty29(e, r, t) {
  return (r = _toPropertyKey29(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey29(t) {
  const i = _toPrimitive29(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive29(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const pickId = (_state, id) => id;
const selectSynchronisedPieSettings = createSelector([selectUnfilteredPolarItems, pickId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "pie").find((item) => item.id === id));
const emptyArray = [];
const pickCells = (_state, _id, cells) => {
  if ((cells === null || cells === void 0 ? void 0 : cells.length) === 0) {
    return emptyArray;
  }
  return cells;
};
const selectDisplayedData2 = createSelector([selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedPieSettings, pickCells], (_ref2, pieSettings, cells) => {
  const {
    chartData
  } = _ref2;
  if (pieSettings == null) {
    return void 0;
  }
  let displayedData;
  if ((pieSettings === null || pieSettings === void 0 ? void 0 : pieSettings.data) != null && pieSettings.data.length > 0) {
    displayedData = pieSettings.data;
  } else {
    displayedData = chartData;
  }
  if ((!displayedData || !displayedData.length) && cells != null) {
    displayedData = cells.map((cell) => _objectSpread28(_objectSpread28({}, pieSettings.presentationProps), cell.props));
  }
  if (displayedData == null) {
    return void 0;
  }
  return displayedData;
});
const selectPieLegend = createSelector([selectDisplayedData2, selectSynchronisedPieSettings, pickCells], (displayedData, pieSettings, cells) => {
  if (displayedData == null || pieSettings == null) {
    return void 0;
  }
  return displayedData.map((entry, i) => {
    let _cells$i;
    const name = getValueByDataKey(entry, pieSettings.nameKey, pieSettings.name);
    let color2;
    if (cells !== null && cells !== void 0 && (_cells$i = cells[i]) !== null && _cells$i !== void 0 && (_cells$i = _cells$i.props) !== null && _cells$i !== void 0 && _cells$i.fill) {
      color2 = cells[i].props.fill;
    } else if (typeof entry === "object" && entry != null && "fill" in entry) {
      color2 = entry.fill;
    } else {
      color2 = pieSettings.fill;
    }
    return {
      value: getTooltipNameProp(name, pieSettings.dataKey),
      color: color2,
      payload: entry,
      type: pieSettings.legendType
    };
  });
});
const selectPieSectors = createSelector([selectDisplayedData2, selectSynchronisedPieSettings, pickCells, selectChartOffsetInternal], (displayedData, pieSettings, cells, offset) => {
  if (pieSettings == null || displayedData == null) {
    return void 0;
  }
  return computePieSectors({
    offset,
    pieSettings,
    displayedData,
    cells
  });
});

// node_modules/recharts/es6/util/ActiveShapeUtils.js
const React26 = __toESM(require_react());
const import_react30 = __toESM(require_react());
const import_isPlainObject8 = __toESM(require_isPlainObject2());

// node_modules/recharts/es6/shape/Trapezoid.js
const React25 = __toESM(require_react());
const import_react29 = __toESM(require_react());
function ownKeys29(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread29(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys29(Object(t), true).forEach(function(r2) {
      _defineProperty30(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys29(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty30(e, r, t) {
  return (r = _toPropertyKey30(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey30(t) {
  const i = _toPrimitive30(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive30(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends20() {
  return _extends20 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends20.apply(null, arguments);
}
const getTrapezoidPath = (x2, y2, upperWidth, lowerWidth, height) => {
  const widthGap = upperWidth - lowerWidth;
  let path2;
  path2 = "M ".concat(x2, ",").concat(y2);
  path2 += "L ".concat(x2 + upperWidth, ",").concat(y2);
  path2 += "L ".concat(x2 + upperWidth - widthGap / 2, ",").concat(y2 + height);
  path2 += "L ".concat(x2 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y2 + height);
  path2 += "L ".concat(x2, ",").concat(y2, " Z");
  return path2;
};
const defaultProps3 = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
const Trapezoid = (outsideProps) => {
  const trapezoidProps = resolveDefaultProps(outsideProps, defaultProps3);
  const {
    x: x2,
    y: y2,
    upperWidth,
    lowerWidth,
    height,
    className
  } = trapezoidProps;
  const {
    animationEasing,
    animationDuration,
    animationBegin,
    isUpdateAnimationActive
  } = trapezoidProps;
  const pathRef = (0, import_react29.useRef)();
  const [totalLength, setTotalLength] = (0, import_react29.useState)(-1);
  const prevUpperWidthRef = (0, import_react29.useRef)(upperWidth);
  const prevLowerWidthRef = (0, import_react29.useRef)(lowerWidth);
  const prevHeightRef = (0, import_react29.useRef)(height);
  const prevXRef = (0, import_react29.useRef)(x2);
  const prevYRef = (0, import_react29.useRef)(y2);
  const animationId = useAnimationId(outsideProps, "trapezoid-");
  (0, import_react29.useEffect)(() => {
    if (pathRef.current && pathRef.current.getTotalLength) {
      try {
        const pathTotalLength = pathRef.current.getTotalLength();
        if (pathTotalLength) {
          setTotalLength(pathTotalLength);
        }
      } catch (_unused) {
      }
    }
  }, []);
  if (x2 !== +x2 || y2 !== +y2 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) {
    return null;
  }
  const layerClass = clsx("recharts-trapezoid", className);
  if (!isUpdateAnimationActive) {
    return React25.createElement("g", null, React25.createElement("path", _extends20({}, filterProps(trapezoidProps, true), {
      className: layerClass,
      d: getTrapezoidPath(x2, y2, upperWidth, lowerWidth, height)
    })));
  }
  const prevUpperWidth = prevUpperWidthRef.current;
  const prevLowerWidth = prevLowerWidthRef.current;
  const prevHeight = prevHeightRef.current;
  const prevX = prevXRef.current;
  const prevY = prevYRef.current;
  const from2 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
  const to2 = "".concat(totalLength, "px 0px");
  const transition = getTransitionVal(["strokeDasharray"], animationDuration, animationEasing);
  return React25.createElement(JavascriptAnimate, {
    animationId,
    key: animationId,
    canBegin: totalLength > 0,
    duration: animationDuration,
    easing: animationEasing,
    isActive: isUpdateAnimationActive,
    begin: animationBegin
  }, (t) => {
    const currUpperWidth = interpolate(prevUpperWidth, upperWidth, t);
    const currLowerWidth = interpolate(prevLowerWidth, lowerWidth, t);
    const currHeight = interpolate(prevHeight, height, t);
    const currX = interpolate(prevX, x2, t);
    const currY = interpolate(prevY, y2, t);
    if (pathRef.current) {
      prevUpperWidthRef.current = currUpperWidth;
      prevLowerWidthRef.current = currLowerWidth;
      prevHeightRef.current = currHeight;
      prevXRef.current = currX;
      prevYRef.current = currY;
    }
    const animationStyle = t > 0 ? {
      transition,
      strokeDasharray: to2
    } : {
      strokeDasharray: from2
    };
    return React25.createElement("path", _extends20({}, filterProps(trapezoidProps, true), {
      className: layerClass,
      d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
      ref: pathRef,
      style: _objectSpread29(_objectSpread29({}, animationStyle), trapezoidProps.style)
    }));
  });
};

// node_modules/recharts/es6/util/ActiveShapeUtils.js
const _excluded15 = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function _objectWithoutProperties15(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose15(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose15(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys30(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread30(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys30(Object(t), true).forEach(function(r2) {
      _defineProperty31(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys30(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty31(e, r, t) {
  return (r = _toPropertyKey31(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey31(t) {
  const i = _toPrimitive31(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive31(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function defaultPropTransformer(option, props) {
  return _objectSpread30(_objectSpread30({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
  return shapeType === "symbols";
}
function ShapeSelector(_ref2) {
  const {
    shapeType,
    elementProps
  } = _ref2;
  switch (shapeType) {
    case "rectangle":
      return React26.createElement(Rectangle, elementProps);
    case "trapezoid":
      return React26.createElement(Trapezoid, elementProps);
    case "sector":
      return React26.createElement(Sector, elementProps);
    case "symbols":
      if (isSymbolsProps(shapeType, elementProps)) {
        return React26.createElement(Symbols, elementProps);
      }
      break;
    default:
      return null;
  }
}
function getPropsFromShapeOption(option) {
  if ((0, import_react30.isValidElement)(option)) {
    return option.props;
  }
  return option;
}
function Shape(_ref2) {
  let {
    option,
    shapeType,
    propTransformer = defaultPropTransformer,
    activeClassName = "recharts-active-shape",
    isActive
  } = _ref2, props = _objectWithoutProperties15(_ref2, _excluded15);
  let shape;
  if ((0, import_react30.isValidElement)(option)) {
    shape = (0, import_react30.cloneElement)(option, _objectSpread30(_objectSpread30({}, props), getPropsFromShapeOption(option)));
  } else if (typeof option === "function") {
    shape = option(props);
  } else if ((0, import_isPlainObject8.default)(option) && typeof option !== "boolean") {
    const nextProps = propTransformer(option, props);
    shape = React26.createElement(ShapeSelector, {
      shapeType,
      elementProps: nextProps
    });
  } else {
    const elementProps = props;
    shape = React26.createElement(ShapeSelector, {
      shapeType,
      elementProps
    });
  }
  if (isActive) {
    return React26.createElement(Layer, {
      className: activeClassName
    }, shape);
  }
  return shape;
}

// node_modules/recharts/es6/context/tooltipContext.js
const useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey) => {
  const dispatch = useAppDispatch();
  return (data, index2) => (event) => {
    onMouseEnterFromProps === null || onMouseEnterFromProps === void 0 || onMouseEnterFromProps(data, index2, event);
    dispatch(setActiveMouseOverItemIndex({
      activeIndex: String(index2),
      activeDataKey: dataKey,
      activeCoordinate: data.tooltipPosition
    }));
  };
};
const useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
  const dispatch = useAppDispatch();
  return (data, index2) => (event) => {
    onMouseLeaveFromProps === null || onMouseLeaveFromProps === void 0 || onMouseLeaveFromProps(data, index2, event);
    dispatch(mouseLeaveItem());
  };
};
const useMouseClickItemDispatch = (onMouseClickFromProps, dataKey) => {
  const dispatch = useAppDispatch();
  return (data, index2) => (event) => {
    onMouseClickFromProps === null || onMouseClickFromProps === void 0 || onMouseClickFromProps(data, index2, event);
    dispatch(setActiveClickItemIndex({
      activeIndex: String(index2),
      activeDataKey: dataKey,
      activeCoordinate: data.tooltipPosition
    }));
  };
};

// node_modules/recharts/es6/state/SetTooltipEntrySettings.js
const import_react31 = __toESM(require_react());
function SetTooltipEntrySettings(_ref2) {
  const {
    fn,
    args
  } = _ref2;
  const dispatch = useAppDispatch();
  const isPanorama = useIsPanorama();
  (0, import_react31.useEffect)(() => {
    if (isPanorama) {
      return void 0;
    }
    const tooltipEntrySettings = fn(args);
    dispatch(addTooltipEntrySettings(tooltipEntrySettings));
    return () => {
      dispatch(removeTooltipEntrySettings(tooltipEntrySettings));
    };
  }, [fn, args, dispatch, isPanorama]);
  return null;
}

// node_modules/recharts/es6/state/SetLegendPayload.js
const import_react32 = __toESM(require_react());
const noop5 = () => {
};
function SetLegendPayload(_ref2) {
  const {
    legendPayload
  } = _ref2;
  const dispatch = useAppDispatch();
  const isPanorama = useIsPanorama();
  (0, import_react32.useEffect)(() => {
    if (isPanorama) {
      return noop5;
    }
    dispatch(addLegendPayload(legendPayload));
    return () => {
      dispatch(removeLegendPayload(legendPayload));
    };
  }, [dispatch, isPanorama, legendPayload]);
  return null;
}
function SetPolarLegendPayload(_ref2) {
  const {
    legendPayload
  } = _ref2;
  const dispatch = useAppDispatch();
  const layout = useAppSelector(selectChartLayout);
  (0, import_react32.useEffect)(() => {
    if (layout !== "centric" && layout !== "radial") {
      return noop5;
    }
    dispatch(addLegendPayload(legendPayload));
    return () => {
      dispatch(removeLegendPayload(legendPayload));
    };
  }, [dispatch, layout, legendPayload]);
  return null;
}

// node_modules/recharts/es6/context/RegisterGraphicalItemId.js
const React28 = __toESM(require_react());
const import_react33 = __toESM(require_react());

// node_modules/recharts/es6/util/useId.js
const React27 = __toESM(require_react());
let _ref;
const useIdFallback = () => {
  const [id] = React27.useState(() => uniqueId("uid-"));
  return id;
};
const useId = (_ref = React27["useId".toString()]) !== null && _ref !== void 0 ? _ref : useIdFallback;

// node_modules/recharts/es6/util/useUniqueId.js
function useUniqueId(prefix2, customId) {
  const generatedId = useId();
  if (customId) {
    return customId;
  }
  return prefix2 ? "".concat(prefix2, "-").concat(generatedId) : generatedId;
}

// node_modules/recharts/es6/context/RegisterGraphicalItemId.js
const GraphicalItemIdContext = (0, import_react33.createContext)(void 0);
const RegisterGraphicalItemId = (_ref2) => {
  const {
    id,
    type,
    children
  } = _ref2;
  const resolvedId = useUniqueId("recharts-".concat(type), id);
  return React28.createElement(GraphicalItemIdContext.Provider, {
    value: resolvedId
  }, children(resolvedId));
};
function useGraphicalItemId() {
  return (0, import_react33.useContext)(GraphicalItemIdContext);
}

// node_modules/recharts/es6/state/SetGraphicalItem.js
const import_react34 = __toESM(require_react());

// node_modules/recharts/es6/state/graphicalItemsSlice.js
const initialState6 = {
  cartesianItems: [],
  polarItems: []
};
const graphicalItemsSlice = createSlice({
  name: "graphicalItems",
  initialState: initialState6,
  reducers: {
    addCartesianGraphicalItem(state, action) {
      state.cartesianItems.push(castDraft(action.payload));
    },
    replaceCartesianGraphicalItem(state, action) {
      const {
        prev,
        next
      } = action.payload;
      const index2 = current(state).cartesianItems.indexOf(castDraft(prev));
      if (index2 > -1) {
        state.cartesianItems[index2] = castDraft(next);
      }
    },
    removeCartesianGraphicalItem(state, action) {
      const index2 = current(state).cartesianItems.indexOf(castDraft(action.payload));
      if (index2 > -1) {
        state.cartesianItems.splice(index2, 1);
      }
    },
    addPolarGraphicalItem(state, action) {
      state.polarItems.push(castDraft(action.payload));
    },
    removePolarGraphicalItem(state, action) {
      const index2 = current(state).polarItems.indexOf(castDraft(action.payload));
      if (index2 > -1) {
        state.polarItems.splice(index2, 1);
      }
    }
  }
});
const {
  addCartesianGraphicalItem,
  replaceCartesianGraphicalItem,
  removeCartesianGraphicalItem,
  addPolarGraphicalItem,
  removePolarGraphicalItem
} = graphicalItemsSlice.actions;
const graphicalItemsReducer = graphicalItemsSlice.reducer;

// node_modules/recharts/es6/state/SetGraphicalItem.js
function SetCartesianGraphicalItem(props) {
  const dispatch = useAppDispatch();
  const prevPropsRef = (0, import_react34.useRef)(null);
  (0, import_react34.useEffect)(() => {
    if (prevPropsRef.current === null) {
      dispatch(addCartesianGraphicalItem(props));
    } else if (prevPropsRef.current !== props) {
      dispatch(replaceCartesianGraphicalItem({
        prev: prevPropsRef.current,
        next: props
      }));
    }
    prevPropsRef.current = props;
  }, [dispatch, props]);
  (0, import_react34.useEffect)(() => {
    return () => {
      if (prevPropsRef.current) {
        dispatch(removeCartesianGraphicalItem(prevPropsRef.current));
        prevPropsRef.current = null;
      }
    };
  }, [dispatch]);
  return null;
}
function SetPolarGraphicalItem(props) {
  const dispatch = useAppDispatch();
  (0, import_react34.useEffect)(() => {
    dispatch(addPolarGraphicalItem(props));
    return () => {
      dispatch(removePolarGraphicalItem(props));
    };
  }, [dispatch, props]);
  return null;
}

// node_modules/recharts/es6/polar/Pie.js
const _excluded16 = ["onMouseEnter", "onClick", "onMouseLeave"];
const _excluded25 = ["id"];
const _excluded32 = ["id"];
function _objectWithoutProperties16(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose16(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose16(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys31(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread31(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys31(Object(t), true).forEach(function(r2) {
      _defineProperty32(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys31(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty32(e, r, t) {
  return (r = _toPropertyKey32(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey32(t) {
  const i = _toPrimitive32(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive32(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends21() {
  return _extends21 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends21.apply(null, arguments);
}
function SetPiePayloadLegend(props) {
  const cells = (0, import_react35.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
  const legendPayload = useAppSelector((state) => selectPieLegend(state, props.id, cells));
  if (legendPayload == null) {
    return null;
  }
  return React29.createElement(SetPolarLegendPayload, {
    legendPayload
  });
}
function getTooltipEntrySettings(props) {
  const {
    dataKey,
    nameKey,
    sectors,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    tooltipType
  } = props;
  return {
    dataDefinedOnItem: sectors.map((p) => p.tooltipPayload),
    positions: sectors.map((p) => p.tooltipPosition),
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      nameKey,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: tooltipType,
      color: fill2,
      unit: ""
      // why doesn't Pie support unit?
    }
  };
}
const getTextAnchor = (x2, cx) => {
  if (x2 > cx) {
    return "start";
  }
  if (x2 < cx) {
    return "end";
  }
  return "middle";
};
const getOuterRadius = (dataPoint, outerRadius, maxPieRadius) => {
  if (typeof outerRadius === "function") {
    return getPercentValue(outerRadius(dataPoint), maxPieRadius, maxPieRadius * 0.8);
  }
  return getPercentValue(outerRadius, maxPieRadius, maxPieRadius * 0.8);
};
const parseCoordinateOfPie = (pieSettings, offset, dataPoint) => {
  const {
    top,
    left,
    width,
    height
  } = offset;
  const maxPieRadius = getMaxRadius(width, height);
  const cx = left + getPercentValue(pieSettings.cx, width, width / 2);
  const cy = top + getPercentValue(pieSettings.cy, height, height / 2);
  const innerRadius = getPercentValue(pieSettings.innerRadius, maxPieRadius, 0);
  const outerRadius = getOuterRadius(dataPoint, pieSettings.outerRadius, maxPieRadius);
  const maxRadius = pieSettings.maxRadius || Math.sqrt(width * width + height * height) / 2;
  return {
    cx,
    cy,
    innerRadius,
    outerRadius,
    maxRadius
  };
};
const parseDeltaAngle = (startAngle, endAngle) => {
  const sign2 = mathSign(endAngle - startAngle);
  const deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
function getClassNamePropertyIfExists(u) {
  if (u && typeof u === "object" && "className" in u && typeof u.className === "string") {
    return u.className;
  }
  return "";
}
const renderLabelLineItem = (option, props) => {
  if (React29.isValidElement(option)) {
    return React29.cloneElement(option, props);
  }
  if (typeof option === "function") {
    return option(props);
  }
  const className = clsx("recharts-pie-label-line", typeof option !== "boolean" ? option.className : "");
  return React29.createElement(Curve, _extends21({}, props, {
    type: "linear",
    className
  }));
};
const renderLabelItem = (option, props, value) => {
  if (React29.isValidElement(option)) {
    return React29.cloneElement(option, props);
  }
  let label = value;
  if (typeof option === "function") {
    label = option(props);
    if (React29.isValidElement(label)) {
      return label;
    }
  }
  const className = clsx("recharts-pie-label-text", getClassNamePropertyIfExists(option));
  return React29.createElement(Text, _extends21({}, props, {
    alignmentBaseline: "middle",
    className
  }), label);
};
function PieLabels(_ref2) {
  const {
    sectors,
    props,
    showLabels
  } = _ref2;
  const {
    label,
    labelLine,
    dataKey
  } = props;
  if (!showLabels || !label || !sectors) {
    return null;
  }
  const pieProps = svgPropertiesNoEvents(props);
  const customLabelProps = filterProps(label, false);
  const customLabelLineProps = filterProps(labelLine, false);
  const offsetRadius = typeof label === "object" && "offsetRadius" in label && typeof label.offsetRadius === "number" && label.offsetRadius || 20;
  const labels = sectors.map((entry, i) => {
    const midAngle = (entry.startAngle + entry.endAngle) / 2;
    const endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);
    const labelProps = _objectSpread31(_objectSpread31(_objectSpread31(_objectSpread31({}, pieProps), entry), {}, {
      stroke: "none"
    }, customLabelProps), {}, {
      index: i,
      textAnchor: getTextAnchor(endPoint.x, entry.cx)
    }, endPoint);
    const lineProps = _objectSpread31(_objectSpread31(_objectSpread31(_objectSpread31({}, pieProps), entry), {}, {
      fill: "none",
      stroke: entry.fill
    }, customLabelLineProps), {}, {
      index: i,
      points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
      key: "line"
    });
    return (
      // eslint-disable-next-line react/no-array-index-key
      React29.createElement(Layer, {
        key: "label-".concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(entry.midAngle, "-").concat(i)
      }, labelLine && renderLabelLineItem(labelLine, lineProps), renderLabelItem(label, labelProps, getValueByDataKey(entry, dataKey)))
    );
  });
  return React29.createElement(Layer, {
    className: "recharts-pie-labels"
  }, labels);
}
function PieLabelList(_ref2) {
  const {
    sectors,
    props,
    showLabels
  } = _ref2;
  const {
    label
  } = props;
  if (typeof label === "object" && label != null && "position" in label) {
    return React29.createElement(LabelListFromLabelProp, {
      label
    });
  }
  return React29.createElement(PieLabels, {
    sectors,
    props,
    showLabels
  });
}
function PieSectors(props) {
  const {
    sectors,
    activeShape,
    inactiveShape: inactiveShapeProp,
    allOtherPieProps
  } = props;
  const activeIndex = useAppSelector(selectActiveTooltipIndex);
  let {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = allOtherPieProps, restOfAllOtherProps = _objectWithoutProperties16(allOtherPieProps, _excluded16);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherPieProps.dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherPieProps.dataKey);
  if (sectors == null || sectors.length === 0) {
    return null;
  }
  return React29.createElement(React29.Fragment, null, sectors.map((entry, i) => {
    if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;
    const isSectorActive = activeShape && String(i) === activeIndex;
    const inactiveShape = activeIndex ? inactiveShapeProp : null;
    const sectorOptions = isSectorActive ? activeShape : inactiveShape;
    const sectorProps = _objectSpread31(_objectSpread31({}, entry), {}, {
      stroke: entry.stroke,
      tabIndex: -1,
      [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
      [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: allOtherPieProps.dataKey
    });
    return React29.createElement(Layer, _extends21({
      tabIndex: -1,
      className: "recharts-pie-sector"
    }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: onMouseEnterFromContext(entry, i),
      onMouseLeave: onMouseLeaveFromContext(entry, i),
      onClick: onClickFromContext(entry, i),
      key: "sector-".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, "-").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, "-").concat(entry.midAngle, "-").concat(i)
    }), React29.createElement(Shape, _extends21({
      option: sectorOptions,
      isActive: isSectorActive,
      shapeType: "sector"
    }, sectorProps)));
  }));
}
function computePieSectors(_ref3) {
  let _pieSettings$paddingA;
  const {
    pieSettings,
    displayedData,
    cells,
    offset
  } = _ref3;
  const {
    cornerRadius,
    startAngle,
    endAngle,
    dataKey,
    nameKey,
    tooltipType
  } = pieSettings;
  const minAngle = Math.abs(pieSettings.minAngle);
  const deltaAngle = parseDeltaAngle(startAngle, endAngle);
  const absDeltaAngle = Math.abs(deltaAngle);
  const paddingAngle = displayedData.length <= 1 ? 0 : (_pieSettings$paddingA = pieSettings.paddingAngle) !== null && _pieSettings$paddingA !== void 0 ? _pieSettings$paddingA : 0;
  const notZeroItemCount = displayedData.filter((entry) => getValueByDataKey(entry, dataKey, 0) !== 0).length;
  const totalPaddingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;
  const realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPaddingAngle;
  const sum4 = displayedData.reduce((result, entry) => {
    const val = getValueByDataKey(entry, dataKey, 0);
    return result + (isNumber(val) ? val : 0);
  }, 0);
  let sectors;
  if (sum4 > 0) {
    let prev;
    sectors = displayedData.map((entry, i) => {
      const val = getValueByDataKey(entry, dataKey, 0);
      const name = getValueByDataKey(entry, nameKey, i);
      const coordinate = parseCoordinateOfPie(pieSettings, offset, entry);
      const percent = (isNumber(val) ? val : 0) / sum4;
      let tempStartAngle;
      const entryWithCellInfo = _objectSpread31(_objectSpread31({}, entry), cells && cells[i] && cells[i].props);
      if (i) {
        tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);
      } else {
        tempStartAngle = startAngle;
      }
      const tempEndAngle = tempStartAngle + mathSign(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);
      const midAngle = (tempStartAngle + tempEndAngle) / 2;
      const middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
      const tooltipPayload = [{
        name,
        value: val,
        payload: entryWithCellInfo,
        dataKey,
        type: tooltipType
      }];
      const tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
      prev = _objectSpread31(_objectSpread31(_objectSpread31(_objectSpread31({}, pieSettings.presentationProps), {}, {
        percent,
        cornerRadius,
        name,
        tooltipPayload,
        midAngle,
        middleRadius,
        tooltipPosition
      }, entryWithCellInfo), coordinate), {}, {
        value: val,
        startAngle: tempStartAngle,
        endAngle: tempEndAngle,
        payload: entryWithCellInfo,
        paddingAngle: mathSign(deltaAngle) * paddingAngle
      });
      return prev;
    });
  }
  return sectors;
}
function PieLabelListProvider(_ref4) {
  const {
    showLabels,
    sectors,
    children
  } = _ref4;
  const labelListEntries = (0, import_react35.useMemo)(() => {
    if (!showLabels || !sectors) {
      return [];
    }
    return sectors.map((entry) => ({
      value: entry.value,
      payload: entry.payload,
      clockWise: false,
      parentViewBox: void 0,
      viewBox: {
        cx: entry.cx,
        cy: entry.cy,
        innerRadius: entry.innerRadius,
        outerRadius: entry.outerRadius,
        startAngle: entry.startAngle,
        endAngle: entry.endAngle,
        clockWise: false
      },
      fill: entry.fill
    }));
  }, [sectors, showLabels]);
  return React29.createElement(PolarLabelListContextProvider, {
    value: showLabels ? labelListEntries : void 0
  }, children);
}
function SectorsWithAnimation(_ref5) {
  const {
    props,
    previousSectorsRef
  } = _ref5;
  const {
    sectors,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    activeShape,
    inactiveShape,
    onAnimationStart,
    onAnimationEnd
  } = props;
  const animationId = useAnimationId(props, "recharts-pie-");
  const prevSectors = previousSectorsRef.current;
  const [isAnimating, setIsAnimating] = (0, import_react35.useState)(false);
  const handleAnimationEnd = (0, import_react35.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react35.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return React29.createElement(PieLabelListProvider, {
    showLabels: !isAnimating,
    sectors
  }, React29.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationStart: handleAnimationStart,
    onAnimationEnd: handleAnimationEnd,
    key: animationId
  }, (t) => {
    const stepData = [];
    const first = sectors && sectors[0];
    let curAngle = first === null || first === void 0 ? void 0 : first.startAngle;
    sectors === null || sectors === void 0 || sectors.forEach((entry, index2) => {
      const prev = prevSectors && prevSectors[index2];
      const paddingAngle = index2 > 0 ? (0, import_get4.default)(entry, "paddingAngle", 0) : 0;
      if (prev) {
        const angle = interpolate(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle, t);
        const latest2 = _objectSpread31(_objectSpread31({}, entry), {}, {
          startAngle: curAngle + paddingAngle,
          endAngle: curAngle + angle + paddingAngle
        });
        stepData.push(latest2);
        curAngle = latest2.endAngle;
      } else {
        const {
          endAngle,
          startAngle
        } = entry;
        const deltaAngle = interpolate(0, endAngle - startAngle, t);
        const _latest = _objectSpread31(_objectSpread31({}, entry), {}, {
          startAngle: curAngle + paddingAngle,
          endAngle: curAngle + deltaAngle + paddingAngle
        });
        stepData.push(_latest);
        curAngle = _latest.endAngle;
      }
    });
    previousSectorsRef.current = stepData;
    return React29.createElement(Layer, null, React29.createElement(PieSectors, {
      sectors: stepData,
      activeShape,
      inactiveShape,
      allOtherPieProps: props
    }));
  }), React29.createElement(PieLabelList, {
    showLabels: !isAnimating,
    sectors,
    props
  }), props.children);
}
const defaultPieProps = {
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  cx: "50%",
  cy: "50%",
  dataKey: "value",
  endAngle: 360,
  fill: "#808080",
  hide: false,
  innerRadius: 0,
  isAnimationActive: !Global.isSsr,
  labelLine: true,
  legendType: "rect",
  minAngle: 0,
  nameKey: "name",
  outerRadius: "80%",
  paddingAngle: 0,
  rootTabIndex: 0,
  startAngle: 0,
  stroke: "#fff"
};
function PieImpl(props) {
  let {
    id
  } = props, propsWithoutId = _objectWithoutProperties16(props, _excluded25);
  const {
    hide,
    className,
    rootTabIndex
  } = props;
  const cells = (0, import_react35.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
  const sectors = useAppSelector((state) => selectPieSectors(state, id, cells));
  const previousSectorsRef = (0, import_react35.useRef)(null);
  const layerClass = clsx("recharts-pie", className);
  if (hide || sectors == null) {
    previousSectorsRef.current = null;
    return React29.createElement(Layer, {
      tabIndex: rootTabIndex,
      className: layerClass
    });
  }
  return React29.createElement(React29.Fragment, null, React29.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings,
    args: _objectSpread31(_objectSpread31({}, props), {}, {
      sectors
    })
  }), React29.createElement(Layer, {
    tabIndex: rootTabIndex,
    className: layerClass
  }, React29.createElement(SectorsWithAnimation, {
    props: _objectSpread31(_objectSpread31({}, propsWithoutId), {}, {
      sectors
    }),
    previousSectorsRef
  })));
}
function Pie(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultPieProps);
  let {
    id: externalId
  } = props, propsWithoutId = _objectWithoutProperties16(props, _excluded32);
  const presentationProps = svgPropertiesNoEvents(propsWithoutId);
  return React29.createElement(RegisterGraphicalItemId, {
    id: externalId,
    type: "pie"
  }, (id) => React29.createElement(React29.Fragment, null, React29.createElement(SetPolarGraphicalItem, {
    type: "pie",
    id,
    data: propsWithoutId.data,
    dataKey: propsWithoutId.dataKey,
    hide: propsWithoutId.hide,
    angleAxisId: 0,
    radiusAxisId: 0,
    name: propsWithoutId.name,
    nameKey: propsWithoutId.nameKey,
    tooltipType: propsWithoutId.tooltipType,
    legendType: propsWithoutId.legendType,
    fill: propsWithoutId.fill,
    cx: propsWithoutId.cx,
    cy: propsWithoutId.cy,
    startAngle: propsWithoutId.startAngle,
    endAngle: propsWithoutId.endAngle,
    paddingAngle: propsWithoutId.paddingAngle,
    minAngle: propsWithoutId.minAngle,
    innerRadius: propsWithoutId.innerRadius,
    outerRadius: propsWithoutId.outerRadius,
    cornerRadius: propsWithoutId.cornerRadius,
    presentationProps,
    maxRadius: props.maxRadius
  }), React29.createElement(SetPiePayloadLegend, _extends21({}, propsWithoutId, {
    id
  })), React29.createElement(PieImpl, _extends21({}, propsWithoutId, {
    id
  }))));
}
Pie.displayName = "Pie";

// node_modules/recharts/es6/polar/Radar.js
const React31 = __toESM(require_react());
const import_react37 = __toESM(require_react());
const import_last3 = __toESM(require_last3());

// node_modules/recharts/es6/component/ActivePoints.js
const React30 = __toESM(require_react());
const import_react36 = __toESM(require_react());

// node_modules/recharts/es6/state/cartesianAxisSlice.js
function ownKeys32(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread32(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys32(Object(t), true).forEach(function(r2) {
      _defineProperty33(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys32(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty33(e, r, t) {
  return (r = _toPropertyKey33(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey33(t) {
  const i = _toPrimitive33(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive33(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const defaultAxisId = 0;
const initialState7 = {
  xAxis: {},
  yAxis: {},
  zAxis: {}
};
const cartesianAxisSlice = createSlice({
  name: "cartesianAxis",
  initialState: initialState7,
  reducers: {
    addXAxis(state, action) {
      state.xAxis[action.payload.id] = castDraft(action.payload);
    },
    removeXAxis(state, action) {
      delete state.xAxis[action.payload.id];
    },
    addYAxis(state, action) {
      state.yAxis[action.payload.id] = castDraft(action.payload);
    },
    removeYAxis(state, action) {
      delete state.yAxis[action.payload.id];
    },
    addZAxis(state, action) {
      state.zAxis[action.payload.id] = castDraft(action.payload);
    },
    removeZAxis(state, action) {
      delete state.zAxis[action.payload.id];
    },
    updateYAxisWidth(state, action) {
      const {
        id,
        width
      } = action.payload;
      if (state.yAxis[id]) {
        state.yAxis[id] = _objectSpread32(_objectSpread32({}, state.yAxis[id]), {}, {
          width
        });
      }
    }
  }
});
const {
  addXAxis,
  removeXAxis,
  addYAxis,
  removeYAxis,
  addZAxis,
  removeZAxis,
  updateYAxisWidth
} = cartesianAxisSlice.actions;
const cartesianAxisReducer = cartesianAxisSlice.reducer;

// node_modules/recharts/es6/state/selectors/selectChartOffset.js
const selectChartOffset = createSelector([selectChartOffsetInternal], (offsetInternal) => {
  if (!offsetInternal) {
    return void 0;
  }
  return {
    top: offsetInternal.top,
    bottom: offsetInternal.bottom,
    left: offsetInternal.left,
    right: offsetInternal.right
  };
});

// node_modules/recharts/es6/state/selectors/selectPlotArea.js
const selectPlotArea = createSelector([selectChartOffset, selectChartWidth, selectChartHeight], (offset, chartWidth, chartHeight) => {
  if (!offset || chartWidth == null || chartHeight == null) {
    return void 0;
  }
  return {
    x: offset.left,
    y: offset.top,
    width: Math.max(0, chartWidth - offset.left - offset.right),
    height: Math.max(0, chartHeight - offset.top - offset.bottom)
  };
});

// node_modules/recharts/es6/hooks.js
const useXAxis = (xAxisId) => {
  const isPanorama = useIsPanorama();
  return useAppSelector((state) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama));
};
const useYAxis = (yAxisId) => {
  const isPanorama = useIsPanorama();
  return useAppSelector((state) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama));
};
const useActiveTooltipLabel = () => {
  return useAppSelector(selectActiveLabel);
};
const useOffset = () => {
  return useAppSelector(selectChartOffset);
};
const usePlotArea = () => {
  return useAppSelector(selectPlotArea);
};
const useActiveTooltipDataPoints = () => {
  return useAppSelector(selectActiveTooltipDataPoints);
};
const useXAxisDomain = function useXAxisDomain2() {
  const xAxisId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultAxisId;
  const isPanorama = useIsPanorama();
  return useAppSelector((state) => selectAxisDomain(state, "xAxis", xAxisId, isPanorama));
};
const useYAxisDomain = function useYAxisDomain2() {
  const yAxisId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultAxisId;
  const isPanorama = useIsPanorama();
  return useAppSelector((state) => selectAxisDomain(state, "yAxis", yAxisId, isPanorama));
};

// node_modules/recharts/es6/component/ActivePoints.js
function ownKeys33(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread33(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys33(Object(t), true).forEach(function(r2) {
      _defineProperty34(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys33(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty34(e, r, t) {
  return (r = _toPropertyKey34(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey34(t) {
  const i = _toPrimitive34(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive34(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const renderActivePoint = (_ref2) => {
  const {
    point: point6,
    childIndex,
    mainColor,
    activeDot,
    dataKey
  } = _ref2;
  if (activeDot === false || point6.x == null || point6.y == null) {
    return null;
  }
  const dotProps = _objectSpread33(_objectSpread33({
    index: childIndex,
    dataKey,
    cx: point6.x,
    cy: point6.y,
    r: 4,
    fill: mainColor !== null && mainColor !== void 0 ? mainColor : "none",
    strokeWidth: 2,
    stroke: "#fff",
    payload: point6.payload,
    value: point6.value
  }, filterProps(activeDot, false)), adaptEventHandlers(activeDot));
  let dot;
  if ((0, import_react36.isValidElement)(activeDot)) {
    dot = (0, import_react36.cloneElement)(activeDot, dotProps);
  } else if (typeof activeDot === "function") {
    dot = activeDot(dotProps);
  } else {
    dot = React30.createElement(Dot, dotProps);
  }
  return React30.createElement(Layer, {
    className: "recharts-active-dot"
  }, dot);
};
function ActivePoints(_ref2) {
  const {
    points,
    mainColor,
    activeDot,
    itemDataKey
  } = _ref2;
  const activeTooltipIndex = useAppSelector(selectActiveTooltipIndex);
  const activeDataPoints = useActiveTooltipDataPoints();
  if (points == null || activeDataPoints == null) {
    return null;
  }
  const activePoint = points.find((p) => activeDataPoints.includes(p.payload));
  if (isNullish(activePoint)) {
    return null;
  }
  return renderActivePoint({
    point: activePoint,
    childIndex: Number(activeTooltipIndex),
    mainColor,
    dataKey: itemDataKey,
    activeDot
  });
}

// node_modules/recharts/es6/state/selectors/radarSelectors.js
function ownKeys34(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread34(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys34(Object(t), true).forEach(function(r2) {
      _defineProperty35(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys34(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty35(e, r, t) {
  return (r = _toPropertyKey35(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey35(t) {
  const i = _toPrimitive35(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive35(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const selectRadiusAxisScale = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
const selectRadiusAxisForRadar = createSelector([selectRadiusAxisScale], (scale) => {
  if (scale == null) {
    return void 0;
  }
  return {
    scale
  };
});
const selectRadiusAxisForBandSize = createSelector([selectRadiusAxis, selectRadiusAxisScale], (axisSettings, scale) => {
  if (axisSettings == null || scale == null) {
    return void 0;
  }
  return _objectSpread34(_objectSpread34({}, axisSettings), {}, {
    scale
  });
});
const selectRadiusAxisTicks2 = (state, radiusAxisId, _angleAxisId, isPanorama) => {
  return selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
};
const selectAngleAxisForRadar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
const selectPolarAxisScaleForRadar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
const selectAngleAxisForBandSize = createSelector([selectAngleAxisForRadar, selectPolarAxisScaleForRadar], (axisSettings, scale) => {
  if (axisSettings == null || scale == null) {
    return void 0;
  }
  return _objectSpread34(_objectSpread34({}, axisSettings), {}, {
    scale
  });
});
const selectAngleAxisTicks2 = (state, _radiusAxisId, angleAxisId, isPanorama) => {
  return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
};
const selectAngleAxisWithScaleAndViewport = createSelector([selectAngleAxisForRadar, selectPolarAxisScaleForRadar, selectPolarViewBox], (axisOptions, scale, polarViewBox) => {
  if (polarViewBox == null || scale == null) {
    return void 0;
  }
  return {
    scale,
    type: axisOptions.type,
    dataKey: axisOptions.dataKey,
    cx: polarViewBox.cx,
    cy: polarViewBox.cy
  };
});
const pickId2 = (_state, _radiusAxisId, _angleAxisId, _isPanorama, radarId) => radarId;
const selectBandSizeOfAxis = createSelector([selectChartLayout, selectRadiusAxisForBandSize, selectRadiusAxisTicks2, selectAngleAxisForBandSize, selectAngleAxisTicks2], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
  if (isCategoricalAxis(layout, "radiusAxis")) {
    return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
  }
  return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
});
const selectSynchronisedRadarDataKey = createSelector([selectUnfilteredPolarItems, pickId2], (graphicalItems, radarId) => {
  if (graphicalItems == null) {
    return void 0;
  }
  const pgis = graphicalItems.find((item) => item.type === "radar" && radarId === item.id);
  return pgis === null || pgis === void 0 ? void 0 : pgis.dataKey;
});
const selectRadarPoints = createSelector([selectRadiusAxisForRadar, selectAngleAxisWithScaleAndViewport, selectChartDataAndAlwaysIgnoreIndexes, selectSynchronisedRadarDataKey, selectBandSizeOfAxis], (radiusAxis, angleAxis, _ref2, dataKey, bandSize) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || dataKey == null) {
    return void 0;
  }
  const displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
  return computeRadarPoints({
    radiusAxis,
    angleAxis,
    displayedData,
    dataKey,
    bandSize
  });
});

// node_modules/recharts/es6/polar/Radar.js
const _excluded17 = ["id"];
function _objectWithoutProperties17(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose17(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose17(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys35(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread35(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys35(Object(t), true).forEach(function(r2) {
      _defineProperty36(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys35(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty36(e, r, t) {
  return (r = _toPropertyKey36(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey36(t) {
  const i = _toPrimitive36(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive36(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends22() {
  return _extends22 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends22.apply(null, arguments);
}
function getLegendItemColor(stroke, fill2) {
  return stroke && stroke !== "none" ? stroke : fill2;
}
const computeLegendPayloadFromRadarSectors = (props) => {
  const {
    dataKey,
    name,
    stroke,
    fill: fill2,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: getLegendItemColor(stroke, fill2),
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings2(props) {
  const {
    dataKey,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    tooltipType
  } = props;
  return {
    /*
     * I suppose this here _could_ return props.points
     * because while Radar does not support item tooltip mode, it _could_ support it.
     * But when I actually do return the points here, a defaultIndex test starts failing.
     * So, undefined it is.
     */
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      nameKey: void 0,
      // RadarChart does not have nameKey unfortunately
      dataKey,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: tooltipType,
      color: getLegendItemColor(stroke, fill2),
      unit: ""
      // why doesn't Radar support unit?
    }
  };
}
function renderDotItem(option, props) {
  let dotItem;
  if (React31.isValidElement(option)) {
    dotItem = React31.cloneElement(option, props);
  } else if (typeof option === "function") {
    dotItem = option(props);
  } else {
    dotItem = React31.createElement(Dot, _extends22({}, props, {
      className: clsx("recharts-radar-dot", typeof option !== "boolean" ? option.className : "")
    }));
  }
  return dotItem;
}
function computeRadarPoints(_ref2) {
  const {
    radiusAxis,
    angleAxis,
    displayedData,
    dataKey,
    bandSize
  } = _ref2;
  const {
    cx,
    cy
  } = angleAxis;
  let isRange = false;
  const points = [];
  const angleBandSize = angleAxis.type !== "number" ? bandSize !== null && bandSize !== void 0 ? bandSize : 0 : 0;
  displayedData.forEach((entry, i) => {
    const name = getValueByDataKey(entry, angleAxis.dataKey, i);
    const value = getValueByDataKey(entry, dataKey);
    const angle = angleAxis.scale(name) + angleBandSize;
    const pointValue = Array.isArray(value) ? (0, import_last3.default)(value) : value;
    const radius = isNullish(pointValue) ? void 0 : radiusAxis.scale(pointValue);
    if (Array.isArray(value) && value.length >= 2) {
      isRange = true;
    }
    points.push(_objectSpread35(_objectSpread35({}, polarToCartesian(cx, cy, radius, angle)), {}, {
      // @ts-expect-error getValueByDataKey does not validate the output type
      name,
      // @ts-expect-error getValueByDataKey does not validate the output type
      value,
      cx,
      cy,
      radius,
      angle,
      payload: entry
    }));
  });
  const baseLinePoints = [];
  if (isRange) {
    points.forEach((point6) => {
      if (Array.isArray(point6.value)) {
        const baseValue = point6.value[0];
        const radius = isNullish(baseValue) ? void 0 : radiusAxis.scale(baseValue);
        baseLinePoints.push(_objectSpread35(_objectSpread35({}, point6), {}, {
          radius
        }, polarToCartesian(cx, cy, radius, point6.angle)));
      } else {
        baseLinePoints.push(point6);
      }
    });
  }
  return {
    points,
    isRange,
    baseLinePoints
  };
}
function Dots(_ref2) {
  const {
    points,
    props
  } = _ref2;
  const {
    dot,
    dataKey
  } = props;
  if (!dot) {
    return null;
  }
  let {
    id
  } = props, propsWithoutId = _objectWithoutProperties17(props, _excluded17);
  const baseProps = svgPropertiesNoEvents(propsWithoutId);
  const customDotProps = filterProps(dot, true);
  const dots = points.map((entry, i) => {
    const dotProps = _objectSpread35(_objectSpread35(_objectSpread35({
      key: "dot-".concat(i),
      r: 3
    }, baseProps), customDotProps), {}, {
      dataKey,
      cx: entry.x,
      cy: entry.y,
      index: i,
      payload: entry
    });
    return renderDotItem(dot, dotProps);
  });
  return React31.createElement(Layer, {
    className: "recharts-radar-dots"
  }, dots);
}
function RadarLabelListProvider(_ref3) {
  const {
    showLabels,
    points,
    children
  } = _ref3;
  const labelListEntries = points.map((point6) => {
    const viewBox = {
      x: point6.x,
      y: point6.y,
      width: 0,
      height: 0
    };
    return _objectSpread35(_objectSpread35({}, viewBox), {}, {
      value: point6.value,
      payload: point6.payload,
      parentViewBox: void 0,
      viewBox,
      fill: void 0
    });
  });
  return React31.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function StaticPolygon(_ref4) {
  const {
    points,
    baseLinePoints,
    props
  } = _ref4;
  if (points == null) {
    return null;
  }
  const {
    shape,
    isRange,
    connectNulls
  } = props;
  const handleMouseEnter = (e) => {
    const {
      onMouseEnter
    } = props;
    if (onMouseEnter) {
      onMouseEnter(props, e);
    }
  };
  const handleMouseLeave = (e) => {
    const {
      onMouseLeave
    } = props;
    if (onMouseLeave) {
      onMouseLeave(props, e);
    }
  };
  let radar;
  if (React31.isValidElement(shape)) {
    radar = React31.cloneElement(shape, _objectSpread35(_objectSpread35({}, props), {}, {
      points
    }));
  } else if (typeof shape === "function") {
    radar = shape(_objectSpread35(_objectSpread35({}, props), {}, {
      points
    }));
  } else {
    radar = React31.createElement(Polygon, _extends22({}, filterProps(props, true), {
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      points,
      baseLinePoints: isRange ? baseLinePoints : null,
      connectNulls
    }));
  }
  return React31.createElement(Layer, {
    className: "recharts-radar-polygon"
  }, radar, React31.createElement(Dots, {
    props,
    points
  }));
}
const interpolatePolarPoint = (prevPoints, prevPointsDiffFactor, t) => (entry, index2) => {
  const prev = prevPoints && prevPoints[Math.floor(index2 * prevPointsDiffFactor)];
  if (prev) {
    return _objectSpread35(_objectSpread35({}, entry), {}, {
      x: interpolate(prev.x, entry.x, t),
      y: interpolate(prev.y, entry.y, t)
    });
  }
  return _objectSpread35(_objectSpread35({}, entry), {}, {
    x: interpolate(entry.cx, entry.x, t),
    y: interpolate(entry.cy, entry.y, t)
  });
};
function PolygonWithAnimation(_ref5) {
  const {
    props,
    previousPointsRef,
    previousBaseLinePointsRef
  } = _ref5;
  const {
    points,
    baseLinePoints,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationEnd,
    onAnimationStart
  } = props;
  const prevPoints = previousPointsRef.current;
  const prevBaseLinePoints = previousBaseLinePointsRef.current;
  const prevPointsDiffFactor = prevPoints && prevPoints.length / points.length;
  const prevBaseLinePointsDiffFactor = prevBaseLinePoints && prevBaseLinePoints.length / baseLinePoints.length;
  const animationId = useAnimationId(props, "recharts-radar-");
  const [isAnimating, setIsAnimating] = (0, import_react37.useState)(false);
  const showLabels = !isAnimating;
  const handleAnimationEnd = (0, import_react37.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react37.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return React31.createElement(RadarLabelListProvider, {
    showLabels,
    points
  }, React31.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    key: "radar-".concat(animationId),
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart
  }, (t) => {
    const stepData = t === 1 ? points : points.map(interpolatePolarPoint(prevPoints, prevPointsDiffFactor, t));
    const stepBaseLinePoints = t === 1 ? baseLinePoints : baseLinePoints === null || baseLinePoints === void 0 ? void 0 : baseLinePoints.map(interpolatePolarPoint(prevBaseLinePoints, prevBaseLinePointsDiffFactor, t));
    if (t > 0) {
      previousPointsRef.current = stepData;
      previousBaseLinePointsRef.current = stepBaseLinePoints;
    }
    return React31.createElement(StaticPolygon, {
      points: stepData,
      baseLinePoints: stepBaseLinePoints,
      props
    });
  }), React31.createElement(LabelListFromLabelProp, {
    label: props.label
  }), props.children);
}
function RenderPolygon(props) {
  const previousPointsRef = (0, import_react37.useRef)(void 0);
  const previousBaseLinePointsRef = (0, import_react37.useRef)(void 0);
  return React31.createElement(PolygonWithAnimation, {
    props,
    previousPointsRef,
    previousBaseLinePointsRef
  });
}
const defaultRadarProps = {
  angleAxisId: 0,
  radiusAxisId: 0,
  hide: false,
  activeDot: true,
  dot: false,
  legendType: "rect",
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
};
const RadarWithState = class extends import_react37.PureComponent {
  render() {
    const {
      hide,
      className,
      points
    } = this.props;
    if (hide || points == null) {
      return null;
    }
    const layerClass = clsx("recharts-radar", className);
    return React31.createElement(React31.Fragment, null, React31.createElement(Layer, {
      className: layerClass
    }, React31.createElement(RenderPolygon, this.props)), React31.createElement(ActivePoints, {
      points,
      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
      itemDataKey: this.props.dataKey,
      activeDot: this.props.activeDot
    }));
  }
};
function RadarImpl(props) {
  const isPanorama = useIsPanorama();
  const radarPoints = useAppSelector((state) => selectRadarPoints(state, props.radiusAxisId, props.angleAxisId, isPanorama, props.id));
  return React31.createElement(RadarWithState, _extends22({}, props, {
    points: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.points,
    baseLinePoints: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.baseLinePoints,
    isRange: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.isRange
  }));
}
const Radar = class extends import_react37.PureComponent {
  render() {
    return React31.createElement(RegisterGraphicalItemId, {
      id: this.props.id,
      type: "radar"
    }, (id) => React31.createElement(React31.Fragment, null, React31.createElement(SetPolarGraphicalItem, {
      type: "radar",
      id,
      data: void 0,
      dataKey: this.props.dataKey,
      hide: this.props.hide,
      angleAxisId: this.props.angleAxisId,
      radiusAxisId: this.props.radiusAxisId
    }), React31.createElement(SetPolarLegendPayload, {
      legendPayload: computeLegendPayloadFromRadarSectors(this.props)
    }), React31.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings2,
      args: this.props
    }), React31.createElement(RadarImpl, _extends22({}, this.props, {
      id
    }))));
  }
};
_defineProperty36(Radar, "displayName", "Radar");
_defineProperty36(Radar, "defaultProps", defaultRadarProps);

// node_modules/recharts/es6/polar/RadialBar.js
const React37 = __toESM(require_react());
const import_react40 = __toESM(require_react());

// node_modules/recharts/es6/util/RadialBarUtils.js
const React32 = __toESM(require_react());
function _extends23() {
  return _extends23 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends23.apply(null, arguments);
}
function ownKeys36(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread36(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys36(Object(t), true).forEach(function(r2) {
      _defineProperty37(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys36(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty37(e, r, t) {
  return (r = _toPropertyKey37(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey37(t) {
  const i = _toPrimitive37(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive37(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function parseCornerRadius(cornerRadius) {
  if (typeof cornerRadius === "string") {
    return parseInt(cornerRadius, 10);
  }
  return cornerRadius;
}
function typeGuardSectorProps(option, props) {
  const cxValue = "".concat(props.cx || option.cx);
  const cx = Number(cxValue);
  const cyValue = "".concat(props.cy || option.cy);
  const cy = Number(cyValue);
  return _objectSpread36(_objectSpread36(_objectSpread36({}, props), option), {}, {
    cx,
    cy
  });
}
function RadialBarSector(props) {
  return React32.createElement(Shape, _extends23({
    shapeType: "sector",
    propTransformer: typeGuardSectorProps
  }, props));
}

// node_modules/recharts/es6/cartesian/Bar.js
const React36 = __toESM(require_react());
const import_react39 = __toESM(require_react());

// node_modules/recharts/es6/util/BarUtils.js
const React33 = __toESM(require_react());

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
const isProduction = false;
const prefix = "Invariant failed";
function invariant2(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  const provided = typeof message === "function" ? message() : message;
  const value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/recharts/es6/util/BarUtils.js
const _excluded18 = ["x", "y"];
function _extends24() {
  return _extends24 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends24.apply(null, arguments);
}
function ownKeys37(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread37(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys37(Object(t), true).forEach(function(r2) {
      _defineProperty38(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys37(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty38(e, r, t) {
  return (r = _toPropertyKey38(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey38(t) {
  const i = _toPrimitive38(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive38(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties18(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose18(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose18(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function typeguardBarRectangleProps(_ref2, props) {
  let {
    x: xProp,
    y: yProp
  } = _ref2, option = _objectWithoutProperties18(_ref2, _excluded18);
  const xValue = "".concat(xProp);
  const x2 = parseInt(xValue, 10);
  const yValue = "".concat(yProp);
  const y2 = parseInt(yValue, 10);
  const heightValue = "".concat(props.height || option.height);
  const height = parseInt(heightValue, 10);
  const widthValue = "".concat(props.width || option.width);
  const width = parseInt(widthValue, 10);
  return _objectSpread37(_objectSpread37(_objectSpread37(_objectSpread37(_objectSpread37({}, props), option), x2 ? {
    x: x2
  } : {}), y2 ? {
    y: y2
  } : {}), {}, {
    height,
    width,
    name: props.name,
    radius: props.radius
  });
}
function BarRectangle(props) {
  return React33.createElement(Shape, _extends24({
    shapeType: "rectangle",
    propTransformer: typeguardBarRectangleProps,
    activeClassName: "recharts-active-bar"
  }, props));
}
const minPointSizeCallback = function minPointSizeCallback2(minPointSize) {
  const defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (value, index2) => {
    if (isNumber(minPointSize)) return minPointSize;
    const isValueNumberOrNil = isNumber(value) || isNullish(value);
    if (isValueNumberOrNil) {
      return minPointSize(value, index2);
    }
    !isValueNumberOrNil ? true ? invariant2(false, "minPointSize callback function received a value with type of ".concat(typeof value, ". Currently only numbers or null/undefined are supported.")) : invariant2(false) : void 0;
    return defaultValue;
  };
};

// node_modules/recharts/es6/context/ErrorBarContext.js
const React34 = __toESM(require_react());
const import_react38 = __toESM(require_react());

// node_modules/recharts/es6/state/errorBarSlice.js
const initialState8 = {};
const errorBarSlice = createSlice({
  name: "errorBars",
  initialState: initialState8,
  reducers: {
    addErrorBar: (state, action) => {
      const {
        itemId,
        errorBar
      } = action.payload;
      if (!state[itemId]) {
        state[itemId] = [];
      }
      state[itemId].push(errorBar);
    },
    replaceErrorBar: (state, action) => {
      const {
        itemId,
        prev,
        next
      } = action.payload;
      if (state[itemId]) {
        state[itemId] = state[itemId].map((e) => e.dataKey === prev.dataKey && e.direction === prev.direction ? next : e);
      }
    },
    removeErrorBar: (state, action) => {
      const {
        itemId,
        errorBar
      } = action.payload;
      if (state[itemId]) {
        state[itemId] = state[itemId].filter((e) => e.dataKey !== errorBar.dataKey || e.direction !== errorBar.direction);
      }
    }
  }
});
const {
  addErrorBar,
  replaceErrorBar,
  removeErrorBar
} = errorBarSlice.actions;
const errorBarReducer = errorBarSlice.reducer;

// node_modules/recharts/es6/context/ErrorBarContext.js
const _excluded19 = ["children"];
function _objectWithoutProperties19(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose19(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose19(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const initialContextState = {
  data: [],
  xAxisId: "xAxis-0",
  yAxisId: "yAxis-0",
  dataPointFormatter: () => ({
    x: 0,
    y: 0,
    value: 0
  }),
  errorBarOffset: 0
};
const ErrorBarContext = (0, import_react38.createContext)(initialContextState);
function SetErrorBarContext(props) {
  let {
    children
  } = props, rest2 = _objectWithoutProperties19(props, _excluded19);
  return React34.createElement(ErrorBarContext.Provider, {
    value: rest2
  }, children);
}
const useErrorBarContext = () => (0, import_react38.useContext)(ErrorBarContext);
function ReportErrorBarSettings(props) {
  const dispatch = useAppDispatch();
  const graphicalItemId = useGraphicalItemId();
  const prevPropsRef = (0, import_react38.useRef)(null);
  (0, import_react38.useEffect)(() => {
    if (graphicalItemId == null) {
      return;
    }
    if (prevPropsRef.current === null) {
      dispatch(addErrorBar({
        itemId: graphicalItemId,
        errorBar: props
      }));
    } else if (prevPropsRef.current !== props) {
      dispatch(replaceErrorBar({
        itemId: graphicalItemId,
        prev: prevPropsRef.current,
        next: props
      }));
    }
    prevPropsRef.current = props;
  }, [dispatch, graphicalItemId, props]);
  (0, import_react38.useEffect)(() => {
    return () => {
      if (prevPropsRef.current != null) {
        dispatch(removeErrorBar({
          itemId: graphicalItemId,
          errorBar: prevPropsRef.current
        }));
        prevPropsRef.current = null;
      }
    };
  }, [dispatch, graphicalItemId]);
  return null;
}

// node_modules/recharts/es6/cartesian/GraphicalItemClipPath.js
const React35 = __toESM(require_react());
function useNeedsClip(xAxisId, yAxisId) {
  let _xAxis$allowDataOverf, _yAxis$allowDataOverf;
  const xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
  const yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
  const needClipX = (_xAxis$allowDataOverf = xAxis === null || xAxis === void 0 ? void 0 : xAxis.allowDataOverflow) !== null && _xAxis$allowDataOverf !== void 0 ? _xAxis$allowDataOverf : implicitXAxis.allowDataOverflow;
  const needClipY = (_yAxis$allowDataOverf = yAxis === null || yAxis === void 0 ? void 0 : yAxis.allowDataOverflow) !== null && _yAxis$allowDataOverf !== void 0 ? _yAxis$allowDataOverf : implicitYAxis.allowDataOverflow;
  const needClip = needClipX || needClipY;
  return {
    needClip,
    needClipX,
    needClipY
  };
}
function GraphicalItemClipPath(_ref2) {
  const {
    xAxisId,
    yAxisId,
    clipPathId
  } = _ref2;
  const plotArea = usePlotArea();
  const {
    needClipX,
    needClipY,
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  if (!needClip) {
    return null;
  }
  const {
    x: x2,
    y: y2,
    width,
    height
  } = plotArea;
  return React35.createElement("clipPath", {
    id: "clipPath-".concat(clipPathId)
  }, React35.createElement("rect", {
    x: needClipX ? x2 : x2 - width / 2,
    y: needClipY ? y2 : y2 - height / 2,
    width: needClipX ? width : width * 2,
    height: needClipY ? height : height * 2
  }));
}

// node_modules/recharts/es6/cartesian/Bar.js
const _excluded20 = ["onMouseEnter", "onMouseLeave", "onClick"];
const _excluded26 = ["value", "background", "tooltipPosition"];
const _excluded33 = ["id"];
const _excluded42 = ["onMouseEnter", "onClick", "onMouseLeave"];
function _extends25() {
  return _extends25 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends25.apply(null, arguments);
}
function ownKeys38(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread38(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys38(Object(t), true).forEach(function(r2) {
      _defineProperty39(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys38(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty39(e, r, t) {
  return (r = _toPropertyKey39(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey39(t) {
  const i = _toPrimitive39(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive39(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties20(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose20(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose20(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const computeLegendPayloadFromBarData = (props) => {
  const {
    dataKey,
    name,
    fill: fill2,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: fill2,
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings3(props) {
  const {
    dataKey,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    unit: unit2
  } = props;
  return {
    dataDefinedOnItem: void 0,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      nameKey: void 0,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: props.tooltipType,
      color: props.fill,
      unit: unit2
    }
  };
}
function BarBackground(props) {
  const activeIndex = useAppSelector(selectActiveTooltipIndex);
  const {
    data,
    dataKey,
    background: backgroundFromProps,
    allOtherBarProps
  } = props;
  let {
    onMouseEnter: onMouseEnterFromProps,
    onMouseLeave: onMouseLeaveFromProps,
    onClick: onItemClickFromProps
  } = allOtherBarProps, restOfAllOtherProps = _objectWithoutProperties20(allOtherBarProps, _excluded20);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
  if (!backgroundFromProps || data == null) {
    return null;
  }
  const backgroundProps = filterProps(backgroundFromProps, false);
  return React36.createElement(React36.Fragment, null, data.map((entry, i) => {
    let {
      value,
      background: backgroundFromDataEntry,
      tooltipPosition
    } = entry, rest2 = _objectWithoutProperties20(entry, _excluded26);
    if (!backgroundFromDataEntry) {
      return null;
    }
    const onMouseEnter = onMouseEnterFromContext(entry, i);
    const onMouseLeave = onMouseLeaveFromContext(entry, i);
    const onClick = onClickFromContext(entry, i);
    const barRectangleProps = _objectSpread38(_objectSpread38(_objectSpread38(_objectSpread38(_objectSpread38({
      option: backgroundFromProps,
      isActive: String(i) === activeIndex
    }, rest2), {}, {
      // @ts-expect-error BarRectangle props do not accept `fill` property.
      fill: "#eee"
    }, backgroundFromDataEntry), backgroundProps), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey,
      index: i,
      className: "recharts-bar-background-rectangle"
    });
    return React36.createElement(BarRectangle, _extends25({
      key: "background-bar-".concat(barRectangleProps.index)
    }, barRectangleProps));
  }));
}
function BarLabelListProvider(_ref2) {
  const {
    showLabels,
    children,
    rects
  } = _ref2;
  const labelListEntries = rects === null || rects === void 0 ? void 0 : rects.map((entry) => {
    const viewBox = {
      x: entry.x,
      y: entry.y,
      width: entry.width,
      height: entry.height
    };
    return _objectSpread38(_objectSpread38({}, viewBox), {}, {
      value: entry.value,
      payload: entry.payload,
      parentViewBox: entry.parentViewBox,
      viewBox,
      fill: entry.fill
    });
  });
  return React36.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : void 0
  }, children);
}
function BarRectangleWithActiveState(props) {
  const {
    shape,
    activeBar,
    baseProps,
    entry,
    index: index2,
    dataKey
  } = props;
  const activeIndex = useAppSelector(selectActiveTooltipIndex);
  const activeDataKey = useAppSelector(selectActiveTooltipDataKey);
  const isActive = activeBar && String(index2) === activeIndex && (activeDataKey == null || dataKey === activeDataKey);
  const option = isActive ? activeBar : shape;
  return React36.createElement(BarRectangle, _extends25({}, baseProps, entry, {
    isActive,
    option,
    index: index2,
    dataKey
  }));
}
function BarRectangleNeverActive(props) {
  const {
    shape,
    baseProps,
    entry,
    index: index2,
    dataKey
  } = props;
  return React36.createElement(BarRectangle, _extends25({}, baseProps, entry, {
    isActive: false,
    option: shape,
    index: index2,
    dataKey
  }));
}
function BarRectangles(_ref2) {
  const {
    data,
    props
  } = _ref2;
  const _svgPropertiesNoEvent = svgPropertiesNoEvents(props), {
    id
  } = _svgPropertiesNoEvent, baseProps = _objectWithoutProperties20(_svgPropertiesNoEvent, _excluded33);
  const {
    shape,
    dataKey,
    activeBar
  } = props;
  let {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = props, restOfAllOtherProps = _objectWithoutProperties20(props, _excluded42);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
  if (!data) {
    return null;
  }
  return React36.createElement(React36.Fragment, null, data.map((entry, i) => {
    return React36.createElement(Layer, _extends25({
      className: "recharts-bar-rectangle"
    }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
      // @ts-expect-error BarRectangleItem type definition says it's missing properties, but I can see them present in debugger!
      onMouseEnter: onMouseEnterFromContext(entry, i),
      onMouseLeave: onMouseLeaveFromContext(entry, i),
      onClick: onClickFromContext(entry, i),
      key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i)
    }), activeBar ? React36.createElement(BarRectangleWithActiveState, {
      shape,
      activeBar,
      baseProps,
      entry,
      index: i,
      dataKey
    }) : (
      /*
       * If the `activeBar` prop is falsy, then let's call the variant without hooks.
       * Using the `selectActiveTooltipIndex` selector is usually fast
       * but in charts with large-ish amount of data even the few nanoseconds add up to a noticeable jank.
       * If the activeBar is false then we don't need to know which index is active - because we won't use it anyway.
       * So let's just skip the hooks altogether. That way, React can skip rendering the component,
       * and can skip the tree reconciliation for its children too.
       * Because we can't call hooks conditionally, we need to have a separate component for that.
       */
      React36.createElement(BarRectangleNeverActive, {
        shape,
        baseProps,
        entry,
        index: i,
        dataKey
      })
    ));
  }));
}
function RectanglesWithAnimation(_ref3) {
  const {
    props,
    previousRectanglesRef
  } = _ref3;
  const {
    data,
    layout,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationEnd,
    onAnimationStart
  } = props;
  const prevData = previousRectanglesRef.current;
  const animationId = useAnimationId(props, "recharts-bar-");
  const [isAnimating, setIsAnimating] = (0, import_react39.useState)(false);
  const showLabels = !isAnimating;
  const handleAnimationEnd = (0, import_react39.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react39.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return React36.createElement(BarLabelListProvider, {
    showLabels,
    rects: data
  }, React36.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t) => {
    const stepData = t === 1 ? data : data === null || data === void 0 ? void 0 : data.map((entry, index2) => {
      const prev = prevData && prevData[index2];
      if (prev) {
        return _objectSpread38(_objectSpread38({}, entry), {}, {
          x: interpolate(prev.x, entry.x, t),
          y: interpolate(prev.y, entry.y, t),
          width: interpolate(prev.width, entry.width, t),
          height: interpolate(prev.height, entry.height, t)
        });
      }
      if (layout === "horizontal") {
        const h = interpolate(0, entry.height, t);
        return _objectSpread38(_objectSpread38({}, entry), {}, {
          y: entry.y + entry.height - h,
          height: h
        });
      }
      const w = interpolate(0, entry.width, t);
      return _objectSpread38(_objectSpread38({}, entry), {}, {
        width: w
      });
    });
    if (t > 0) {
      previousRectanglesRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
    }
    if (stepData == null) {
      return null;
    }
    return React36.createElement(Layer, null, React36.createElement(BarRectangles, {
      props,
      data: stepData
    }));
  }), React36.createElement(LabelListFromLabelProp, {
    label: props.label
  }), props.children);
}
function RenderRectangles(props) {
  const previousRectanglesRef = (0, import_react39.useRef)(null);
  return React36.createElement(RectanglesWithAnimation, {
    previousRectanglesRef,
    props
  });
}
const defaultMinPointSize = 0;
const errorBarDataPointFormatter = (dataPoint, dataKey) => {
  const value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
  return {
    x: dataPoint.x,
    y: dataPoint.y,
    value,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: getValueByDataKey(dataPoint, dataKey)
  };
};
const BarWithState = class extends import_react39.PureComponent {
  render() {
    const {
      hide,
      data,
      dataKey,
      className,
      xAxisId,
      yAxisId,
      needClip,
      background,
      id
    } = this.props;
    if (hide || data == null) {
      return null;
    }
    const layerClass = clsx("recharts-bar", className);
    const clipPathId = id;
    return React36.createElement(Layer, {
      className: layerClass,
      id
    }, needClip && React36.createElement("defs", null, React36.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    })), React36.createElement(Layer, {
      className: "recharts-bar-rectangles",
      clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
    }, React36.createElement(BarBackground, {
      data,
      dataKey,
      background,
      allOtherBarProps: this.props
    }), React36.createElement(RenderRectangles, this.props)));
  }
};
const defaultBarProps = {
  activeBar: false,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease",
  hide: false,
  isAnimationActive: !Global.isSsr,
  legendType: "rect",
  minPointSize: defaultMinPointSize,
  xAxisId: 0,
  yAxisId: 0
};
function BarImpl(props) {
  const {
    xAxisId,
    yAxisId,
    hide,
    legendType,
    minPointSize,
    activeBar,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive
  } = props;
  const {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  const layout = useChartLayout();
  const isPanorama = useIsPanorama();
  const cells = findAllByType(props.children, Cell);
  const rects = useAppSelector((state) => selectBarRectangles(state, xAxisId, yAxisId, isPanorama, props.id, cells));
  if (layout !== "vertical" && layout !== "horizontal") {
    return null;
  }
  let errorBarOffset;
  const firstDataPoint = rects === null || rects === void 0 ? void 0 : rects[0];
  if (firstDataPoint == null || firstDataPoint.height == null || firstDataPoint.width == null) {
    errorBarOffset = 0;
  } else {
    errorBarOffset = layout === "vertical" ? firstDataPoint.height / 2 : firstDataPoint.width / 2;
  }
  return React36.createElement(SetErrorBarContext, {
    xAxisId,
    yAxisId,
    data: rects,
    dataPointFormatter: errorBarDataPointFormatter,
    errorBarOffset
  }, React36.createElement(BarWithState, _extends25({}, props, {
    layout,
    needClip,
    data: rects,
    xAxisId,
    yAxisId,
    hide,
    legendType,
    minPointSize,
    activeBar,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive
  })));
}
function computeBarRectangles(_ref4) {
  const {
    layout,
    barSettings: {
      dataKey,
      minPointSize: minPointSizeProp
    },
    pos,
    bandSize,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    stackedData,
    displayedData,
    offset,
    cells,
    parentViewBox
  } = _ref4;
  const numericAxis = layout === "horizontal" ? yAxis : xAxis;
  const stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  const baseValue = getBaseValueOfBar({
    numericAxis
  });
  return displayedData.map((entry, index2) => {
    let value, x2, y2, width, height, background;
    if (stackedData) {
      value = truncateByDomain(stackedData[index2], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!Array.isArray(value)) {
        value = [baseValue, value];
      }
    }
    const minPointSize = minPointSizeCallback(minPointSizeProp, defaultMinPointSize)(value[1], index2);
    if (layout === "horizontal") {
      let _ref5;
      const [baseValueScale, currentValueScale] = [yAxis.scale(value[0]), yAxis.scale(value[1])];
      x2 = getCateCoordinateOfBar({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      y2 = (_ref5 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref5 !== void 0 ? _ref5 : void 0;
      width = pos.size;
      const computedHeight = baseValueScale - currentValueScale;
      height = isNan(computedHeight) ? 0 : computedHeight;
      background = {
        x: x2,
        y: offset.top,
        width,
        height: offset.height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
        const delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
        y2 -= delta;
        height += delta;
      }
    } else {
      const [_baseValueScale, _currentValueScale] = [xAxis.scale(value[0]), xAxis.scale(value[1])];
      x2 = _baseValueScale;
      y2 = getCateCoordinateOfBar({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      width = _currentValueScale - _baseValueScale;
      height = pos.size;
      background = {
        x: offset.left,
        y: y2,
        width: offset.width,
        height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
        const _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
        width += _delta;
      }
    }
    if (x2 == null || y2 == null || width == null || height == null) {
      return null;
    }
    const barRectangleItem = _objectSpread38(_objectSpread38({}, entry), {}, {
      x: x2,
      y: y2,
      width,
      height,
      value: stackedData ? value : value[1],
      payload: entry,
      background,
      tooltipPosition: {
        x: x2 + width / 2,
        y: y2 + height / 2
      },
      parentViewBox
    }, cells && cells[index2] && cells[index2].props);
    return barRectangleItem;
  }).filter(Boolean);
}
function BarFn(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultBarProps);
  const isPanorama = useIsPanorama();
  return React36.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "bar"
  }, (id) => React36.createElement(React36.Fragment, null, React36.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromBarData(props)
  }), React36.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings3,
    args: props
  }), React36.createElement(SetCartesianGraphicalItem, {
    type: "bar",
    id,
    data: void 0,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: 0,
    dataKey: props.dataKey,
    stackId: getNormalizedStackId(props.stackId),
    hide: props.hide,
    barSize: props.barSize,
    minPointSize: props.minPointSize,
    maxBarSize: props.maxBarSize,
    isPanorama
  }), React36.createElement(BarImpl, _extends25({}, props, {
    id
  }))));
}
const Bar = React36.memo(BarFn);
Bar.displayName = "Bar";

// node_modules/recharts/es6/state/selectors/barSelectors.js
function ownKeys39(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread39(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys39(Object(t), true).forEach(function(r2) {
      _defineProperty40(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys39(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty40(e, r, t) {
  return (r = _toPropertyKey40(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey40(t) {
  const i = _toPrimitive40(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive40(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const pickXAxisId = (_state, xAxisId) => xAxisId;
const pickYAxisId = (_state, _xAxisId, yAxisId) => yAxisId;
const pickIsPanorama = (_state, _xAxisId, _yAxisId, isPanorama) => isPanorama;
const pickBarId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
const selectSynchronisedBarSettings = createSelector([selectUnfilteredCartesianItems, pickBarId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "bar").find((item) => item.id === id));
const selectMaxBarSize = createSelector([selectSynchronisedBarSettings], (barSettings) => barSettings === null || barSettings === void 0 ? void 0 : barSettings.maxBarSize);
const pickCells2 = (_state, _xAxisId, _yAxisId, _isPanorama, _id, cells) => cells;
const getBarSize = (globalSize, totalSize, selfSize) => {
  const barSize = selfSize !== null && selfSize !== void 0 ? selfSize : globalSize;
  if (isNullish(barSize)) {
    return void 0;
  }
  return getPercentValue(barSize, totalSize, 0);
};
const selectAllVisibleBars = createSelector([selectChartLayout, selectUnfilteredCartesianItems, pickXAxisId, pickYAxisId, pickIsPanorama], (layout, allItems, xAxisId, yAxisId, isPanorama) => allItems.filter((i) => {
  if (layout === "horizontal") {
    return i.xAxisId === xAxisId;
  }
  return i.yAxisId === yAxisId;
}).filter((i) => i.isPanorama === isPanorama).filter((i) => i.hide === false).filter((i) => i.type === "bar"));
const selectBarStackGroups = (state, xAxisId, yAxisId, isPanorama) => {
  const layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return selectStackGroups(state, "yAxis", yAxisId, isPanorama);
  }
  return selectStackGroups(state, "xAxis", xAxisId, isPanorama);
};
const selectBarCartesianAxisSize = (state, xAxisId, yAxisId) => {
  const layout = selectChartLayout(state);
  if (layout === "horizontal") {
    return selectCartesianAxisSize(state, "xAxis", xAxisId);
  }
  return selectCartesianAxisSize(state, "yAxis", yAxisId);
};
const combineBarSizeList = (allBars, globalSize, totalSize) => {
  const initialValue = {};
  const stackedBars = allBars.filter(isStacked);
  const unstackedBars = allBars.filter((b) => b.stackId == null);
  const groupByStack = stackedBars.reduce((acc, bar) => {
    if (!acc[bar.stackId]) {
      acc[bar.stackId] = [];
    }
    acc[bar.stackId].push(bar);
    return acc;
  }, initialValue);
  const stackedSizeList = Object.entries(groupByStack).map((_ref2) => {
    const [stackId, bars] = _ref2;
    const dataKeys = bars.map((b) => b.dataKey);
    const barSize = getBarSize(globalSize, totalSize, bars[0].barSize);
    return {
      stackId,
      dataKeys,
      barSize
    };
  });
  const unstackedSizeList = unstackedBars.map((b) => {
    const dataKeys = [b.dataKey].filter((dk) => dk != null);
    const barSize = getBarSize(globalSize, totalSize, b.barSize);
    return {
      stackId: void 0,
      dataKeys,
      barSize
    };
  });
  return [...stackedSizeList, ...unstackedSizeList];
};
const selectBarSizeList = createSelector([selectAllVisibleBars, selectRootBarSize, selectBarCartesianAxisSize], combineBarSizeList);
const selectBarBandSize = (state, xAxisId, yAxisId, isPanorama, id) => {
  let _ref2, _getBandSizeOfAxis;
  const barSettings = selectSynchronisedBarSettings(state, xAxisId, yAxisId, isPanorama, id);
  if (barSettings == null) {
    return void 0;
  }
  const layout = selectChartLayout(state);
  const globalMaxBarSize = selectRootMaxBarSize(state);
  const {
    maxBarSize: childMaxBarSize
  } = barSettings;
  const maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
  let axis, ticks2;
  if (layout === "horizontal") {
    axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  } else {
    axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  }
  return (_ref2 = (_getBandSizeOfAxis = getBandSizeOfAxis(axis, ticks2, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
};
const selectAxisBandSize = (state, xAxisId, yAxisId, isPanorama) => {
  const layout = selectChartLayout(state);
  let axis, ticks2;
  if (layout === "horizontal") {
    axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
  } else {
    axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
    ticks2 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
  }
  return getBandSizeOfAxis(axis, ticks2);
};
function getBarPositions(barGap, barCategoryGap, bandSize, sizeList, maxBarSize) {
  const len = sizeList.length;
  if (len < 1) {
    return void 0;
  }
  let realBarGap = getPercentValue(barGap, bandSize, 0, true);
  let result;
  const initialValue = [];
  if (isWellBehavedNumber(sizeList[0].barSize)) {
    let useFull = false;
    let fullBarSize = bandSize / len;
    let sum4 = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
    sum4 += (len - 1) * realBarGap;
    if (sum4 >= bandSize) {
      sum4 -= (len - 1) * realBarGap;
      realBarGap = 0;
    }
    if (sum4 >= bandSize && fullBarSize > 0) {
      useFull = true;
      fullBarSize *= 0.9;
      sum4 = len * fullBarSize;
    }
    const offset = (bandSize - sum4) / 2 >> 0;
    let prev = {
      offset: offset - realBarGap,
      size: 0
    };
    result = sizeList.reduce((res, entry) => {
      let _entry$barSize;
      const newPosition = {
        stackId: entry.stackId,
        dataKeys: entry.dataKeys,
        position: {
          offset: prev.offset + prev.size + realBarGap,
          size: useFull ? fullBarSize : (_entry$barSize = entry.barSize) !== null && _entry$barSize !== void 0 ? _entry$barSize : 0
        }
      };
      const newRes = [...res, newPosition];
      prev = newRes[newRes.length - 1].position;
      return newRes;
    }, initialValue);
  } else {
    const _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
      realBarGap = 0;
    }
    let originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
    if (originalSize > 1) {
      originalSize >>= 0;
    }
    const size = isWellBehavedNumber(maxBarSize) ? Math.min(originalSize, maxBarSize) : originalSize;
    result = sizeList.reduce((res, entry, i) => [...res, {
      stackId: entry.stackId,
      dataKeys: entry.dataKeys,
      position: {
        offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
        size
      }
    }], initialValue);
  }
  return result;
}
const combineAllBarPositions = (sizeList, globalMaxBarSize, barGap, barCategoryGap, barBandSize, bandSize, childMaxBarSize) => {
  const maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
  let allBarPositions = getBarPositions(barGap, barCategoryGap, barBandSize !== bandSize ? barBandSize : bandSize, sizeList, maxBarSize);
  if (barBandSize !== bandSize && allBarPositions != null) {
    allBarPositions = allBarPositions.map((pos) => _objectSpread39(_objectSpread39({}, pos), {}, {
      position: _objectSpread39(_objectSpread39({}, pos.position), {}, {
        offset: pos.position.offset - barBandSize / 2
      })
    }));
  }
  return allBarPositions;
};
const selectAllBarPositions = createSelector([selectBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectBarBandSize, selectAxisBandSize, selectMaxBarSize], combineAllBarPositions);
const selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
const selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
const selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
const selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
const selectBarPosition = createSelector([selectAllBarPositions, selectSynchronisedBarSettings], (allBarPositions, barSettings) => {
  if (allBarPositions == null || barSettings == null) {
    return void 0;
  }
  const position2 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
  if (position2 == null) {
    return void 0;
  }
  return position2.position;
});
const combineStackedData = (stackGroups, barSettings) => {
  const stackSeriesIdentifier = getStackSeriesIdentifier(barSettings);
  if (!stackGroups || stackSeriesIdentifier == null || barSettings == null) {
    return void 0;
  }
  const {
    stackId
  } = barSettings;
  if (stackId == null) {
    return void 0;
  }
  const stackGroup = stackGroups[stackId];
  if (!stackGroup) {
    return void 0;
  }
  const {
    stackedData
  } = stackGroup;
  if (!stackedData) {
    return void 0;
  }
  return stackedData.find((sd) => sd.key === stackSeriesIdentifier);
};
const selectStackedDataOfItem = createSelector([selectBarStackGroups, selectSynchronisedBarSettings], combineStackedData);
var selectBarRectangles = createSelector([selectChartOffsetInternal, selectAxisViewBox, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectBarPosition, selectChartLayout, selectChartDataWithIndexesIfNotInPanorama, selectAxisBandSize, selectStackedDataOfItem, selectSynchronisedBarSettings, pickCells2], (offset, axisViewBox, xAxis, yAxis, xAxisTicks, yAxisTicks, pos, layout, _ref3, bandSize, stackedData, barSettings, cells) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref3;
  if (barSettings == null || pos == null || axisViewBox == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || bandSize == null) {
    return void 0;
  }
  const {
    data
  } = barSettings;
  let displayedData;
  if (data != null && data.length > 0) {
    displayedData = data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null) {
    return void 0;
  }
  return computeBarRectangles({
    layout,
    barSettings,
    pos,
    parentViewBox: axisViewBox,
    bandSize,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    stackedData,
    displayedData,
    offset,
    cells
  });
});

// node_modules/recharts/es6/state/selectors/radialBarSelectors.js
function ownKeys40(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread40(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys40(Object(t), true).forEach(function(r2) {
      _defineProperty41(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys40(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty41(e, r, t) {
  return (r = _toPropertyKey41(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey41(t) {
  const i = _toPrimitive41(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive41(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const selectRadiusAxisForRadialBar = (state, radiusAxisId) => selectRadiusAxis(state, radiusAxisId);
const selectRadiusAxisScaleForRadar = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
const selectRadiusAxisWithScale = createSelector([selectRadiusAxisForRadialBar, selectRadiusAxisScaleForRadar], (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread40(_objectSpread40({}, axis), {}, {
    scale
  });
});
const selectRadiusAxisTicks3 = (state, radiusAxisId, _angleAxisId, isPanorama) => {
  return selectPolarGraphicalItemAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
};
const selectAngleAxisForRadialBar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
const selectAngleAxisScaleForRadialBar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
const selectAngleAxisWithScale = createSelector([selectAngleAxisForRadialBar, selectAngleAxisScaleForRadialBar], (axis, scale) => {
  if (axis == null || scale == null) {
    return void 0;
  }
  return _objectSpread40(_objectSpread40({}, axis), {}, {
    scale
  });
});
const selectAngleAxisTicks3 = (state, _radiusAxisId, angleAxisId, isPanorama) => {
  return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
};
const pickRadialBarSettings = (_state, _radiusAxisId, _angleAxisId, radialBarSettings) => radialBarSettings;
const selectSynchronisedRadialBarSettings = createSelector([selectUnfilteredPolarItems, pickRadialBarSettings], (graphicalItems, radialBarSettingsFromProps) => {
  if (graphicalItems.some((pgis) => pgis.type === "radialBar" && radialBarSettingsFromProps.dataKey === pgis.dataKey && radialBarSettingsFromProps.stackId === pgis.stackId)) {
    return radialBarSettingsFromProps;
  }
  return void 0;
});
const selectBandSizeOfPolarAxis = createSelector([selectChartLayout, selectRadiusAxisWithScale, selectRadiusAxisTicks3, selectAngleAxisWithScale, selectAngleAxisTicks3], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
  if (isCategoricalAxis(layout, "radiusAxis")) {
    return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
  }
  return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
});
const selectBaseValue = createSelector([selectAngleAxisWithScale, selectRadiusAxisWithScale, selectChartLayout], (angleAxis, radiusAxis, layout) => {
  const numericAxis = layout === "radial" ? angleAxis : radiusAxis;
  if (numericAxis == null || numericAxis.scale == null) {
    return void 0;
  }
  return getBaseValueOfBar({
    numericAxis
  });
});
const pickCells3 = (_state, _radiusAxisId, _angleAxisId, _radialBarSettings, cells) => cells;
const pickAngleAxisId = (_state, _radiusAxisId, angleAxisId, _radialBarSettings, _cells) => angleAxisId;
const pickRadiusAxisId = (_state, radiusAxisId, _angleAxisId, _radialBarSettings, _cells) => radiusAxisId;
const pickMaxBarSize = (_state, _radiusAxisId, _angleAxisId, radialBarSettings, _cells) => radialBarSettings.maxBarSize;
const selectAllVisibleRadialBars = createSelector([selectChartLayout, selectUnfilteredPolarItems, pickAngleAxisId, pickRadiusAxisId], (layout, allItems, angleAxisId, radiusAxisId) => {
  return allItems.filter((i) => {
    if (layout === "centric") {
      return i.angleAxisId === angleAxisId;
    }
    return i.radiusAxisId === radiusAxisId;
  }).filter((i) => i.hide === false).filter((i) => i.type === "radialBar");
});
const selectPolarBarAxisSize = () => void 0;
const selectPolarBarSizeList = createSelector([selectAllVisibleRadialBars, selectRootBarSize, selectPolarBarAxisSize], combineBarSizeList);
const selectPolarBarBandSize = createSelector([selectChartLayout, selectRootMaxBarSize, selectAngleAxisWithScale, selectAngleAxisTicks3, selectRadiusAxisWithScale, selectRadiusAxisTicks3, pickMaxBarSize], (layout, globalMaxBarSize, angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, childMaxBarSize) => {
  let _ref2, _getBandSizeOfAxis2;
  const maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
  if (layout === "centric") {
    let _ref3, _getBandSizeOfAxis;
    return (_ref3 = (_getBandSizeOfAxis = getBandSizeOfAxis(angleAxis, angleAxisTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref3 !== void 0 ? _ref3 : 0;
  }
  return (_ref2 = (_getBandSizeOfAxis2 = getBandSizeOfAxis(radiusAxis, radiusAxisTicks, true)) !== null && _getBandSizeOfAxis2 !== void 0 ? _getBandSizeOfAxis2 : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
});
const selectAllPolarBarPositions = createSelector([selectPolarBarSizeList, selectRootMaxBarSize, selectBarGap, selectBarCategoryGap, selectPolarBarBandSize, selectBandSizeOfPolarAxis, pickMaxBarSize], combineAllBarPositions);
const selectPolarBarPosition = createSelector([selectAllPolarBarPositions, selectSynchronisedRadialBarSettings], (allBarPositions, barSettings) => {
  if (allBarPositions == null || barSettings == null) {
    return void 0;
  }
  const position2 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
  if (position2 == null) {
    return void 0;
  }
  return position2.position;
});
const selectStackedRadialBars = createSelector([selectPolarItemsSettings], (allPolarItems) => allPolarItems.filter((item) => item.type === "radialBar").filter(isStacked));
const selectPolarCombinedStackedData = createSelector([selectStackedRadialBars, selectChartDataAndAlwaysIgnoreIndexes, selectTooltipAxis], combineDisplayedStackedData);
const selectStackGroups2 = createSelector([selectPolarCombinedStackedData, selectStackedRadialBars, selectStackOffsetType], combineStackGroups);
const selectRadialBarStackGroups = (state, radiusAxisId, angleAxisId) => {
  const layout = selectChartLayout(state);
  if (layout === "centric") {
    return selectStackGroups2(state, "radiusAxis", radiusAxisId);
  }
  return selectStackGroups2(state, "angleAxis", angleAxisId);
};
const selectPolarStackedData = createSelector([selectRadialBarStackGroups, selectSynchronisedRadialBarSettings], combineStackedData);
const selectRadialBarSectors = createSelector([selectAngleAxisWithScale, selectAngleAxisTicks3, selectRadiusAxisWithScale, selectRadiusAxisTicks3, selectChartDataWithIndexes, selectSynchronisedRadialBarSettings, selectBandSizeOfPolarAxis, selectChartLayout, selectBaseValue, selectPolarViewBox, pickCells3, selectPolarBarPosition, selectPolarStackedData], (angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, _ref3, radialBarSettings, bandSize, layout, baseValue, polarViewBox, cells, pos, stackedData) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref3;
  if (radialBarSettings == null || radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || pos == null || layout !== "centric" && layout !== "radial" || radiusAxisTicks == null) {
    return [];
  }
  const {
    dataKey,
    minPointSize
  } = radialBarSettings;
  const {
    cx,
    cy,
    startAngle,
    endAngle
  } = polarViewBox;
  const displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
  const numericAxis = layout === "centric" ? radiusAxis : angleAxis;
  const stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  return computeRadialBarDataItems({
    angleAxis,
    angleAxisTicks,
    bandSize,
    baseValue,
    cells,
    cx,
    cy,
    dataKey,
    dataStartIndex,
    displayedData,
    endAngle,
    layout,
    minPointSize,
    pos,
    radiusAxis,
    radiusAxisTicks,
    stackedData,
    stackedDomain,
    startAngle
  });
});
const selectRadialBarLegendPayload = createSelector([selectChartDataAndAlwaysIgnoreIndexes, (_s, l) => l], (_ref4, legendType) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref4;
  if (chartData == null) {
    return [];
  }
  const displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
  if (displayedData.length === 0) {
    return [];
  }
  return displayedData.map((entry) => {
    return {
      type: legendType,
      // @ts-expect-error we need a better typing for our data inputs
      value: entry.name,
      // @ts-expect-error we need a better typing for our data inputs
      color: entry.fill,
      payload: entry
    };
  });
});

// node_modules/recharts/es6/polar/RadialBar.js
const _excluded21 = ["shape", "activeShape", "cornerRadius", "id"];
const _excluded27 = ["onMouseEnter", "onClick", "onMouseLeave"];
const _excluded34 = ["value", "background"];
function _extends26() {
  return _extends26 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends26.apply(null, arguments);
}
function ownKeys41(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread41(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys41(Object(t), true).forEach(function(r2) {
      _defineProperty42(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys41(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty42(e, r, t) {
  return (r = _toPropertyKey42(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey42(t) {
  const i = _toPrimitive42(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive42(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties21(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose21(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose21(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const STABLE_EMPTY_ARRAY = [];
function RadialBarLabelListProvider(_ref2) {
  const {
    showLabels,
    sectors,
    children
  } = _ref2;
  const labelListEntries = sectors.map((sector) => ({
    value: sector.value,
    payload: sector.payload,
    parentViewBox: void 0,
    clockWise: false,
    viewBox: {
      cx: sector.cx,
      cy: sector.cy,
      innerRadius: sector.innerRadius,
      outerRadius: sector.outerRadius,
      startAngle: sector.startAngle,
      endAngle: sector.endAngle,
      clockWise: false
    },
    fill: sector.fill
  }));
  return React37.createElement(PolarLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function RadialBarSectors(_ref2) {
  const {
    sectors,
    allOtherRadialBarProps,
    showLabels
  } = _ref2;
  let {
    shape,
    activeShape,
    cornerRadius,
    id
  } = allOtherRadialBarProps, others = _objectWithoutProperties21(allOtherRadialBarProps, _excluded21);
  const baseProps = svgPropertiesNoEvents(others);
  const activeIndex = useAppSelector(selectActiveTooltipIndex);
  let {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = allOtherRadialBarProps, restOfAllOtherProps = _objectWithoutProperties21(allOtherRadialBarProps, _excluded27);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherRadialBarProps.dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherRadialBarProps.dataKey);
  if (sectors == null) {
    return null;
  }
  return React37.createElement(RadialBarLabelListProvider, {
    showLabels,
    sectors
  }, sectors.map((entry, i) => {
    const isActive = activeShape && activeIndex === String(i);
    const onMouseEnter = onMouseEnterFromContext(entry, i);
    const onMouseLeave = onMouseLeaveFromContext(entry, i);
    const onClick = onClickFromContext(entry, i);
    const radialBarSectorProps = _objectSpread41(_objectSpread41(_objectSpread41(_objectSpread41({}, baseProps), {}, {
      cornerRadius: parseCornerRadius(cornerRadius)
    }, entry), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
      onMouseEnter,
      onMouseLeave,
      onClick,
      key: "sector-".concat(i),
      className: "recharts-radial-bar-sector ".concat(entry.className),
      forceCornerRadius: others.forceCornerRadius,
      cornerIsExternal: others.cornerIsExternal,
      isActive,
      option: isActive ? activeShape : shape
    });
    return React37.createElement(RadialBarSector, radialBarSectorProps);
  }), React37.createElement(LabelListFromLabelProp, {
    label: allOtherRadialBarProps.label
  }), allOtherRadialBarProps.children);
}
function SectorsWithAnimation2(_ref3) {
  const {
    props,
    previousSectorsRef
  } = _ref3;
  const {
    data,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationEnd,
    onAnimationStart
  } = props;
  const animationId = useAnimationId(props, "recharts-radialbar-");
  const prevData = previousSectorsRef.current;
  const [isAnimating, setIsAnimating] = (0, import_react40.useState)(false);
  const handleAnimationEnd = (0, import_react40.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react40.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return React37.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationStart: handleAnimationStart,
    onAnimationEnd: handleAnimationEnd,
    key: animationId
  }, (t) => {
    const stepData = t === 1 ? data : (data !== null && data !== void 0 ? data : STABLE_EMPTY_ARRAY).map((entry, index2) => {
      const prev = prevData && prevData[index2];
      if (prev) {
        const interpolatorStartAngle = interpolateNumber(prev.startAngle, entry.startAngle);
        const interpolatorEndAngle = interpolateNumber(prev.endAngle, entry.endAngle);
        return _objectSpread41(_objectSpread41({}, entry), {}, {
          startAngle: interpolatorStartAngle(t),
          endAngle: interpolatorEndAngle(t)
        });
      }
      const {
        endAngle,
        startAngle
      } = entry;
      const interpolator = interpolateNumber(startAngle, endAngle);
      return _objectSpread41(_objectSpread41({}, entry), {}, {
        endAngle: interpolator(t)
      });
    });
    if (t > 0) {
      previousSectorsRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
    }
    return React37.createElement(Layer, null, React37.createElement(RadialBarSectors, {
      sectors: stepData !== null && stepData !== void 0 ? stepData : STABLE_EMPTY_ARRAY,
      allOtherRadialBarProps: props,
      showLabels: !isAnimating
    }));
  });
}
function RenderSectors(props) {
  const previousSectorsRef = (0, import_react40.useRef)(null);
  return React37.createElement(SectorsWithAnimation2, {
    props,
    previousSectorsRef
  });
}
function SetRadialBarPayloadLegend(props) {
  const legendPayload = useAppSelector((state) => selectRadialBarLegendPayload(state, props.legendType));
  return React37.createElement(SetPolarLegendPayload, {
    legendPayload: legendPayload !== null && legendPayload !== void 0 ? legendPayload : []
  });
}
function getTooltipEntrySettings4(props) {
  const {
    dataKey,
    data,
    stroke,
    strokeWidth,
    name,
    hide,
    fill: fill2,
    tooltipType
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      nameKey: void 0,
      // RadialBar does not have nameKey, why?
      dataKey,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: tooltipType,
      color: fill2,
      unit: ""
      // Why does RadialBar not support unit?
    }
  };
}
const RadialBarWithState = class extends import_react40.PureComponent {
  renderBackground(sectors) {
    if (sectors == null) {
      return null;
    }
    const {
      cornerRadius
    } = this.props;
    const backgroundProps = filterProps(this.props.background, false);
    return sectors.map((entry, i) => {
      let {
        value,
        background
      } = entry, rest2 = _objectWithoutProperties21(entry, _excluded34);
      if (!background) {
        return null;
      }
      const props = _objectSpread41(_objectSpread41(_objectSpread41(_objectSpread41(_objectSpread41({
        cornerRadius: parseCornerRadius(cornerRadius)
      }, rest2), {}, {
        fill: "#eee"
      }, background), backgroundProps), adaptEventsOfChild(this.props, entry, i)), {}, {
        index: i,
        key: "sector-".concat(i),
        className: clsx("recharts-radial-bar-background-sector", backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className),
        option: background,
        isActive: false
      });
      return React37.createElement(RadialBarSector, props);
    });
  }
  render() {
    const {
      hide,
      data,
      className,
      background
    } = this.props;
    if (hide) {
      return null;
    }
    const layerClass = clsx("recharts-area", className);
    return React37.createElement(Layer, {
      className: layerClass
    }, background && React37.createElement(Layer, {
      className: "recharts-radial-bar-background"
    }, this.renderBackground(data)), React37.createElement(Layer, {
      className: "recharts-radial-bar-sectors"
    }, React37.createElement(RenderSectors, this.props)));
  }
};
function RadialBarImpl(props) {
  let _useAppSelector;
  const cells = findAllByType(props.children, Cell);
  const radialBarSettings = {
    data: void 0,
    hide: false,
    id: props.id,
    dataKey: props.dataKey,
    minPointSize: props.minPointSize,
    stackId: getNormalizedStackId(props.stackId),
    maxBarSize: props.maxBarSize,
    barSize: props.barSize,
    type: "radialBar",
    angleAxisId: props.angleAxisId,
    radiusAxisId: props.radiusAxisId
  };
  const data = (_useAppSelector = useAppSelector((state) => selectRadialBarSectors(state, props.radiusAxisId, props.angleAxisId, radialBarSettings, cells))) !== null && _useAppSelector !== void 0 ? _useAppSelector : STABLE_EMPTY_ARRAY;
  return React37.createElement(React37.Fragment, null, React37.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings4,
    args: _objectSpread41(_objectSpread41({}, props), {}, {
      data
    })
  }), React37.createElement(RadialBarWithState, _extends26({}, props, {
    data
  })));
}
const defaultRadialBarProps = {
  angleAxisId: 0,
  radiusAxisId: 0,
  minPointSize: 0,
  hide: false,
  legendType: "rect",
  data: [],
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  forceCornerRadius: false,
  cornerIsExternal: false
};
function computeRadialBarDataItems(_ref4) {
  const {
    displayedData,
    stackedData,
    dataStartIndex,
    stackedDomain,
    dataKey,
    baseValue,
    layout,
    radiusAxis,
    radiusAxisTicks,
    bandSize,
    pos,
    angleAxis,
    minPointSize,
    cx,
    cy,
    angleAxisTicks,
    cells,
    startAngle: rootStartAngle,
    endAngle: rootEndAngle
  } = _ref4;
  return (displayedData !== null && displayedData !== void 0 ? displayedData : []).map((entry, index2) => {
    let value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;
    if (stackedData) {
      value = truncateByDomain(stackedData[dataStartIndex + index2], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!Array.isArray(value)) {
        value = [baseValue, value];
      }
    }
    if (layout === "radial") {
      innerRadius = getCateCoordinateOfBar({
        axis: radiusAxis,
        ticks: radiusAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      endAngle = angleAxis.scale(value[1]);
      startAngle = angleAxis.scale(value[0]);
      outerRadius = (innerRadius !== null && innerRadius !== void 0 ? innerRadius : 0) + pos.size;
      const deltaAngle = endAngle - startAngle;
      if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {
        const delta = mathSign(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));
        endAngle += delta;
      }
      backgroundSector = {
        background: {
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle: rootStartAngle,
          endAngle: rootEndAngle
        }
      };
    } else {
      innerRadius = radiusAxis.scale(value[0]);
      outerRadius = radiusAxis.scale(value[1]);
      startAngle = getCateCoordinateOfBar({
        axis: angleAxis,
        ticks: angleAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index2
      });
      endAngle = (startAngle !== null && startAngle !== void 0 ? startAngle : 0) + pos.size;
      const deltaRadius = outerRadius - innerRadius;
      if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {
        const _delta = mathSign(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));
        outerRadius += _delta;
      }
    }
    return _objectSpread41(_objectSpread41(_objectSpread41({}, entry), backgroundSector), {}, {
      payload: entry,
      value: stackedData ? value : value[1],
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, cells && cells[index2] && cells[index2].props);
  });
}
const RadialBar = class extends import_react40.PureComponent {
  render() {
    return React37.createElement(RegisterGraphicalItemId, {
      id: this.props.id,
      type: "radialBar"
    }, (id) => {
      let _this$props$hide, _this$props$angleAxis, _this$props$radiusAxi;
      return React37.createElement(React37.Fragment, null, React37.createElement(SetPolarGraphicalItem, {
        type: "radialBar",
        id,
        data: void 0,
        dataKey: this.props.dataKey,
        hide: (_this$props$hide = this.props.hide) !== null && _this$props$hide !== void 0 ? _this$props$hide : defaultRadialBarProps.hide,
        angleAxisId: (_this$props$angleAxis = this.props.angleAxisId) !== null && _this$props$angleAxis !== void 0 ? _this$props$angleAxis : defaultRadialBarProps.angleAxisId,
        radiusAxisId: (_this$props$radiusAxi = this.props.radiusAxisId) !== null && _this$props$radiusAxi !== void 0 ? _this$props$radiusAxi : defaultRadialBarProps.radiusAxisId,
        stackId: getNormalizedStackId(this.props.stackId),
        barSize: this.props.barSize,
        minPointSize: this.props.minPointSize,
        maxBarSize: this.props.maxBarSize
      }), React37.createElement(SetRadialBarPayloadLegend, this.props), React37.createElement(RadialBarImpl, _extends26({}, this.props, {
        id
      })));
    });
  }
};
_defineProperty42(RadialBar, "displayName", "RadialBar");
_defineProperty42(RadialBar, "defaultProps", defaultRadialBarProps);

// node_modules/recharts/es6/cartesian/Brush.js
const React38 = __toESM(require_react());
const import_react43 = __toESM(require_react());
const import_range4 = __toESM(require_range2());

// node_modules/recharts/es6/util/CssPrefixUtils.js
function ownKeys42(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread42(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys42(Object(t), true).forEach(function(r2) {
      _defineProperty43(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys42(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty43(e, r, t) {
  return (r = _toPropertyKey43(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey43(t) {
  const i = _toPrimitive43(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive43(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const PREFIX_LIST = ["Webkit", "Moz", "O", "ms"];
const generatePrefixStyle = (name, value) => {
  if (!name) {
    return void 0;
  }
  const camelName = name.replace(/(\w)/, (v) => v.toUpperCase());
  const result = PREFIX_LIST.reduce((res, entry) => _objectSpread42(_objectSpread42({}, res), {}, {
    [entry + camelName]: value
  }), {});
  result[name] = value;
  return result;
};

// node_modules/recharts/es6/context/chartDataContext.js
const import_react41 = __toESM(require_react());
const ChartDataContextProvider = (props) => {
  const {
    chartData
  } = props;
  const dispatch = useAppDispatch();
  const isPanorama = useIsPanorama();
  (0, import_react41.useEffect)(() => {
    if (isPanorama) {
      return () => {
      };
    }
    dispatch(setChartData(chartData));
    return () => {
      dispatch(setChartData(void 0));
    };
  }, [chartData, dispatch, isPanorama]);
  return null;
};
const SetComputedData = (props) => {
  const {
    computedData
  } = props;
  const dispatch = useAppDispatch();
  (0, import_react41.useEffect)(() => {
    dispatch(setComputedData(computedData));
    return () => {
      dispatch(setChartData(void 0));
    };
  }, [computedData, dispatch]);
  return null;
};
const selectChartData = (state) => state.chartData.chartData;
const useChartData = () => useAppSelector(selectChartData);
const selectDataIndex = (state) => {
  const {
    dataStartIndex,
    dataEndIndex
  } = state.chartData;
  return {
    startIndex: dataStartIndex,
    endIndex: dataEndIndex
  };
};
const useDataIndex = () => {
  return useAppSelector(selectDataIndex);
};

// node_modules/recharts/es6/context/brushUpdateContext.js
const import_react42 = __toESM(require_react());
const BrushUpdateDispatchContext = (0, import_react42.createContext)(() => {
});

// node_modules/recharts/es6/state/brushSlice.js
const initialState9 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
};
const brushSlice = createSlice({
  name: "brush",
  initialState: initialState9,
  reducers: {
    setBrushSettings(_state, action) {
      if (action.payload == null) {
        return initialState9;
      }
      return action.payload;
    }
  }
});
const {
  setBrushSettings
} = brushSlice.actions;
const brushReducer = brushSlice.reducer;

// node_modules/recharts/es6/cartesian/Brush.js
function _extends27() {
  return _extends27 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends27.apply(null, arguments);
}
function ownKeys43(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread43(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys43(Object(t), true).forEach(function(r2) {
      _defineProperty44(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys43(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty44(e, r, t) {
  return (r = _toPropertyKey44(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey44(t) {
  const i = _toPrimitive44(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive44(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function DefaultTraveller(props) {
  const {
    x: x2,
    y: y2,
    width,
    height,
    stroke
  } = props;
  const lineY = Math.floor(y2 + height / 2) - 1;
  return React38.createElement(React38.Fragment, null, React38.createElement("rect", {
    x: x2,
    y: y2,
    width,
    height,
    fill: stroke,
    stroke: "none"
  }), React38.createElement("line", {
    x1: x2 + 1,
    y1: lineY,
    x2: x2 + width - 1,
    y2: lineY,
    fill: "none",
    stroke: "#fff"
  }), React38.createElement("line", {
    x1: x2 + 1,
    y1: lineY + 2,
    x2: x2 + width - 1,
    y2: lineY + 2,
    fill: "none",
    stroke: "#fff"
  }));
}
function Traveller(props) {
  const {
    travellerProps,
    travellerType
  } = props;
  if (React38.isValidElement(travellerType)) {
    return React38.cloneElement(travellerType, travellerProps);
  }
  if (typeof travellerType === "function") {
    return travellerType(travellerProps);
  }
  return React38.createElement(DefaultTraveller, travellerProps);
}
function TravellerLayer(_ref2) {
  let _data$startIndex, _data$endIndex;
  const {
    otherProps,
    travellerX,
    id,
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onTouchStart,
    onTravellerMoveKeyboard,
    onFocus,
    onBlur
  } = _ref2;
  const {
    y: y2,
    x: xFromProps,
    travellerWidth,
    height,
    traveller,
    ariaLabel,
    data,
    startIndex,
    endIndex
  } = otherProps;
  const x2 = Math.max(travellerX, xFromProps);
  const travellerProps = _objectSpread43(_objectSpread43({}, svgPropertiesNoEvents(otherProps)), {}, {
    x: x2,
    y: y2,
    width: travellerWidth,
    height
  });
  const ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
  return React38.createElement(Layer, {
    tabIndex: 0,
    role: "slider",
    "aria-label": ariaLabelBrush,
    "aria-valuenow": travellerX,
    className: "recharts-brush-traveller",
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onTouchStart,
    onKeyDown: (e) => {
      if (!["ArrowLeft", "ArrowRight"].includes(e.key)) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      onTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
    },
    onFocus,
    onBlur,
    style: {
      cursor: "col-resize"
    }
  }, React38.createElement(Traveller, {
    travellerType: traveller,
    travellerProps
  }));
}
function getTextOfTick(props) {
  const {
    index: index2,
    data,
    tickFormatter,
    dataKey
  } = props;
  const text = getValueByDataKey(data[index2], dataKey, index2);
  return typeof tickFormatter === "function" ? tickFormatter(text, index2) : text;
}
function getIndexInRange(valueRange, x2) {
  const len = valueRange.length;
  let start = 0;
  let end = len - 1;
  while (end - start > 1) {
    const middle = Math.floor((start + end) / 2);
    if (valueRange[middle] > x2) {
      end = middle;
    } else {
      start = middle;
    }
  }
  return x2 >= valueRange[end] ? end : start;
}
function getIndex(_ref2) {
  const {
    startX,
    endX,
    scaleValues,
    gap,
    data
  } = _ref2;
  const lastIndex = data.length - 1;
  const min3 = Math.min(startX, endX);
  const max3 = Math.max(startX, endX);
  const minIndex2 = getIndexInRange(scaleValues, min3);
  const maxIndex2 = getIndexInRange(scaleValues, max3);
  return {
    startIndex: minIndex2 - minIndex2 % gap,
    endIndex: maxIndex2 === lastIndex ? lastIndex : maxIndex2 - maxIndex2 % gap
  };
}
function Background(_ref3) {
  const {
    x: x2,
    y: y2,
    width,
    height,
    fill: fill2,
    stroke
  } = _ref3;
  return React38.createElement("rect", {
    stroke,
    fill: fill2,
    x: x2,
    y: y2,
    width,
    height
  });
}
function BrushText(_ref4) {
  const {
    startIndex,
    endIndex,
    y: y2,
    height,
    travellerWidth,
    stroke,
    tickFormatter,
    dataKey,
    data,
    startX,
    endX
  } = _ref4;
  const offset = 5;
  const attrs = {
    pointerEvents: "none",
    fill: stroke
  };
  return React38.createElement(Layer, {
    className: "recharts-brush-texts"
  }, React38.createElement(Text, _extends27({
    textAnchor: "end",
    verticalAnchor: "middle",
    x: Math.min(startX, endX) - offset,
    y: y2 + height / 2
  }, attrs), getTextOfTick({
    index: startIndex,
    tickFormatter,
    dataKey,
    data
  })), React38.createElement(Text, _extends27({
    textAnchor: "start",
    verticalAnchor: "middle",
    x: Math.max(startX, endX) + travellerWidth + offset,
    y: y2 + height / 2
  }, attrs), getTextOfTick({
    index: endIndex,
    tickFormatter,
    dataKey,
    data
  })));
}
function Slide(_ref5) {
  const {
    y: y2,
    height,
    stroke,
    travellerWidth,
    startX,
    endX,
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onTouchStart
  } = _ref5;
  const x2 = Math.min(startX, endX) + travellerWidth;
  const width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
  return React38.createElement("rect", {
    className: "recharts-brush-slide",
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onTouchStart,
    style: {
      cursor: "move"
    },
    stroke: "none",
    fill: stroke,
    fillOpacity: 0.2,
    x: x2,
    y: y2,
    width,
    height
  });
}
function Panorama(_ref6) {
  const {
    x: x2,
    y: y2,
    width,
    height,
    data,
    children,
    padding
  } = _ref6;
  const isPanoramic = React38.Children.count(children) === 1;
  if (!isPanoramic) {
    return null;
  }
  const chartElement = import_react43.Children.only(children);
  if (!chartElement) {
    return null;
  }
  return React38.cloneElement(chartElement, {
    x: x2,
    y: y2,
    width,
    height,
    margin: padding,
    compact: true,
    data
  });
}
const createScale = (_ref7) => {
  const {
    data,
    startIndex,
    endIndex,
    x: x2,
    width,
    travellerWidth
  } = _ref7;
  if (!data || !data.length) {
    return {};
  }
  const len = data.length;
  const scale = point5().domain((0, import_range4.default)(0, len)).range([x2, x2 + width - travellerWidth]);
  const scaleValues = scale.domain().map((entry) => scale(entry));
  return {
    isTextActive: false,
    isSlideMoving: false,
    isTravellerMoving: false,
    isTravellerFocused: false,
    startX: scale(startIndex),
    endX: scale(endIndex),
    scale,
    scaleValues
  };
};
const isTouch = (e) => e.changedTouches && !!e.changedTouches.length;
const BrushWithState = class extends import_react43.PureComponent {
  constructor(props) {
    super(props);
    _defineProperty44(this, "handleDrag", (e) => {
      if (this.leaveTimer) {
        clearTimeout(this.leaveTimer);
        this.leaveTimer = null;
      }
      if (this.state.isTravellerMoving) {
        this.handleTravellerMove(e);
      } else if (this.state.isSlideMoving) {
        this.handleSlideDrag(e);
      }
    });
    _defineProperty44(this, "handleTouchMove", (e) => {
      if (e.changedTouches != null && e.changedTouches.length > 0) {
        this.handleDrag(e.changedTouches[0]);
      }
    });
    _defineProperty44(this, "handleDragEnd", () => {
      this.setState({
        isTravellerMoving: false,
        isSlideMoving: false
      }, () => {
        const {
          endIndex,
          onDragEnd,
          startIndex
        } = this.props;
        onDragEnd === null || onDragEnd === void 0 || onDragEnd({
          endIndex,
          startIndex
        });
      });
      this.detachDragEndListener();
    });
    _defineProperty44(this, "handleLeaveWrapper", () => {
      if (this.state.isTravellerMoving || this.state.isSlideMoving) {
        this.leaveTimer = window.setTimeout(this.handleDragEnd, this.props.leaveTimeOut);
      }
    });
    _defineProperty44(this, "handleEnterSlideOrTraveller", () => {
      this.setState({
        isTextActive: true
      });
    });
    _defineProperty44(this, "handleLeaveSlideOrTraveller", () => {
      this.setState({
        isTextActive: false
      });
    });
    _defineProperty44(this, "handleSlideDragStart", (e) => {
      const event = isTouch(e) ? e.changedTouches[0] : e;
      this.setState({
        isTravellerMoving: false,
        isSlideMoving: true,
        slideMoveStartX: event.pageX
      });
      this.attachDragEndListener();
    });
    _defineProperty44(this, "handleTravellerMoveKeyboard", (direction, id) => {
      const {
        data,
        gap,
        startIndex,
        endIndex
      } = this.props;
      const {
        scaleValues,
        startX,
        endX
      } = this.state;
      if (scaleValues == null) {
        return;
      }
      let currentIndex = -1;
      if (id === "startX") {
        currentIndex = startIndex;
      } else if (id === "endX") {
        currentIndex = endIndex;
      }
      if (currentIndex < 0 || currentIndex >= data.length) {
        return;
      }
      const newIndex = currentIndex + direction;
      if (newIndex === -1 || newIndex >= scaleValues.length) {
        return;
      }
      const newScaleValue = scaleValues[newIndex];
      if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) {
        return;
      }
      this.setState(
        // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React
        {
          [id]: newScaleValue
        },
        () => {
          this.props.onChange(getIndex({
            startX: this.state.startX,
            endX: this.state.endX,
            data,
            gap,
            scaleValues
          }));
        }
      );
    });
    this.travellerDragStartHandlers = {
      startX: this.handleTravellerDragStart.bind(this, "startX"),
      endX: this.handleTravellerDragStart.bind(this, "endX")
    };
    this.state = {
      brushMoveStartX: 0,
      movingTravellerId: void 0,
      endX: 0,
      startX: 0,
      slideMoveStartX: 0
    };
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      data,
      width,
      x: x2,
      travellerWidth,
      startIndex,
      endIndex,
      startIndexControlledFromProps,
      endIndexControlledFromProps
    } = nextProps;
    if (data !== prevState.prevData) {
      return _objectSpread43({
        prevData: data,
        prevTravellerWidth: travellerWidth,
        prevX: x2,
        prevWidth: width
      }, data && data.length ? createScale({
        data,
        width,
        x: x2,
        travellerWidth,
        startIndex,
        endIndex
      }) : {
        scale: void 0,
        scaleValues: void 0
      });
    }
    const prevScale = prevState.scale;
    if (prevScale && (width !== prevState.prevWidth || x2 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
      prevScale.range([x2, x2 + width - travellerWidth]);
      const scaleValues = prevScale.domain().map((entry) => prevScale(entry)).filter((value) => value != null);
      return {
        prevData: data,
        prevTravellerWidth: travellerWidth,
        prevX: x2,
        prevWidth: width,
        startX: prevScale(nextProps.startIndex),
        endX: prevScale(nextProps.endIndex),
        scaleValues
      };
    }
    if (prevState.scale && !prevState.isSlideMoving && !prevState.isTravellerMoving && !prevState.isTravellerFocused && !prevState.isTextActive) {
      if (startIndexControlledFromProps != null && prevState.prevStartIndexControlledFromProps !== startIndexControlledFromProps) {
        return {
          startX: prevState.scale(startIndexControlledFromProps),
          prevStartIndexControlledFromProps: startIndexControlledFromProps
        };
      }
      if (endIndexControlledFromProps != null && prevState.prevEndIndexControlledFromProps !== endIndexControlledFromProps) {
        return {
          endX: prevState.scale(endIndexControlledFromProps),
          prevEndIndexControlledFromProps: endIndexControlledFromProps
        };
      }
    }
    return null;
  }
  componentWillUnmount() {
    if (this.leaveTimer) {
      clearTimeout(this.leaveTimer);
      this.leaveTimer = null;
    }
    this.detachDragEndListener();
  }
  attachDragEndListener() {
    window.addEventListener("mouseup", this.handleDragEnd, true);
    window.addEventListener("touchend", this.handleDragEnd, true);
    window.addEventListener("mousemove", this.handleDrag, true);
  }
  detachDragEndListener() {
    window.removeEventListener("mouseup", this.handleDragEnd, true);
    window.removeEventListener("touchend", this.handleDragEnd, true);
    window.removeEventListener("mousemove", this.handleDrag, true);
  }
  handleSlideDrag(e) {
    const {
      slideMoveStartX,
      startX,
      endX,
      scaleValues
    } = this.state;
    if (scaleValues == null) {
      return;
    }
    const {
      x: x2,
      width,
      travellerWidth,
      startIndex,
      endIndex,
      onChange,
      data,
      gap
    } = this.props;
    let delta = e.pageX - slideMoveStartX;
    if (delta > 0) {
      delta = Math.min(delta, x2 + width - travellerWidth - endX, x2 + width - travellerWidth - startX);
    } else if (delta < 0) {
      delta = Math.max(delta, x2 - startX, x2 - endX);
    }
    const newIndex = getIndex({
      startX: startX + delta,
      endX: endX + delta,
      data,
      gap,
      scaleValues
    });
    if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
      onChange(newIndex);
    }
    this.setState({
      startX: startX + delta,
      endX: endX + delta,
      slideMoveStartX: e.pageX
    });
  }
  handleTravellerDragStart(id, e) {
    const event = isTouch(e) ? e.changedTouches[0] : e;
    this.setState({
      isSlideMoving: false,
      isTravellerMoving: true,
      movingTravellerId: id,
      brushMoveStartX: event.pageX
    });
    this.attachDragEndListener();
  }
  handleTravellerMove(e) {
    const {
      brushMoveStartX,
      movingTravellerId,
      endX,
      startX,
      scaleValues
    } = this.state;
    if (movingTravellerId == null) {
      return;
    }
    const prevValue = this.state[movingTravellerId];
    const {
      x: x2,
      width,
      travellerWidth,
      onChange,
      gap,
      data
    } = this.props;
    const params = {
      startX: this.state.startX,
      endX: this.state.endX,
      data,
      gap,
      scaleValues
    };
    let delta = e.pageX - brushMoveStartX;
    if (delta > 0) {
      delta = Math.min(delta, x2 + width - travellerWidth - prevValue);
    } else if (delta < 0) {
      delta = Math.max(delta, x2 - prevValue);
    }
    params[movingTravellerId] = prevValue + delta;
    const newIndex = getIndex(params);
    const {
      startIndex,
      endIndex
    } = newIndex;
    const isFullGap = () => {
      const lastIndex = data.length - 1;
      if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
        return true;
      }
      return false;
    };
    this.setState(
      // @ts-expect-error not sure why typescript is not happy with this, partial update is fine in React
      {
        [movingTravellerId]: prevValue + delta,
        brushMoveStartX: e.pageX
      },
      () => {
        if (onChange) {
          if (isFullGap()) {
            onChange(newIndex);
          }
        }
      }
    );
  }
  render() {
    const {
      data,
      className,
      children,
      x: x2,
      y: y2,
      dy,
      width,
      height,
      alwaysShowText,
      fill: fill2,
      stroke,
      startIndex,
      endIndex,
      travellerWidth,
      tickFormatter,
      dataKey,
      padding
    } = this.props;
    const {
      startX,
      endX,
      isTextActive,
      isSlideMoving,
      isTravellerMoving,
      isTravellerFocused
    } = this.state;
    if (!data || !data.length || !isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
      return null;
    }
    const layerClass = clsx("recharts-brush", className);
    const style = generatePrefixStyle("userSelect", "none");
    const calculatedY = y2 + (dy !== null && dy !== void 0 ? dy : 0);
    return React38.createElement(Layer, {
      className: layerClass,
      onMouseLeave: this.handleLeaveWrapper,
      onTouchMove: this.handleTouchMove,
      style
    }, React38.createElement(Background, {
      x: x2,
      y: calculatedY,
      width,
      height,
      fill: fill2,
      stroke
    }), React38.createElement(PanoramaContextProvider, null, React38.createElement(Panorama, {
      x: x2,
      y: calculatedY,
      width,
      height,
      data,
      padding
    }, children)), React38.createElement(Slide, {
      y: calculatedY,
      height,
      stroke,
      travellerWidth,
      startX,
      endX,
      onMouseEnter: this.handleEnterSlideOrTraveller,
      onMouseLeave: this.handleLeaveSlideOrTraveller,
      onMouseDown: this.handleSlideDragStart,
      onTouchStart: this.handleSlideDragStart
    }), React38.createElement(TravellerLayer, {
      travellerX: startX,
      id: "startX",
      otherProps: _objectSpread43(_objectSpread43({}, this.props), {}, {
        y: calculatedY
      }),
      onMouseEnter: this.handleEnterSlideOrTraveller,
      onMouseLeave: this.handleLeaveSlideOrTraveller,
      onMouseDown: this.travellerDragStartHandlers.startX,
      onTouchStart: this.travellerDragStartHandlers.startX,
      onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
      onFocus: () => {
        this.setState({
          isTravellerFocused: true
        });
      },
      onBlur: () => {
        this.setState({
          isTravellerFocused: false
        });
      }
    }), React38.createElement(TravellerLayer, {
      travellerX: endX,
      id: "endX",
      otherProps: _objectSpread43(_objectSpread43({}, this.props), {}, {
        y: calculatedY
      }),
      onMouseEnter: this.handleEnterSlideOrTraveller,
      onMouseLeave: this.handleLeaveSlideOrTraveller,
      onMouseDown: this.travellerDragStartHandlers.endX,
      onTouchStart: this.travellerDragStartHandlers.endX,
      onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
      onFocus: () => {
        this.setState({
          isTravellerFocused: true
        });
      },
      onBlur: () => {
        this.setState({
          isTravellerFocused: false
        });
      }
    }), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && React38.createElement(BrushText, {
      startIndex,
      endIndex,
      y: calculatedY,
      height,
      travellerWidth,
      stroke,
      tickFormatter,
      dataKey,
      data,
      startX,
      endX
    }));
  }
};
function BrushInternal(props) {
  const dispatch = useAppDispatch();
  const chartData = useChartData();
  const dataIndexes = useDataIndex();
  const onChangeFromContext = (0, import_react43.useContext)(BrushUpdateDispatchContext);
  const onChangeFromProps = props.onChange;
  const {
    startIndex: startIndexFromProps,
    endIndex: endIndexFromProps
  } = props;
  (0, import_react43.useEffect)(() => {
    dispatch(setDataStartEndIndexes({
      startIndex: startIndexFromProps,
      endIndex: endIndexFromProps
    }));
  }, [dispatch, endIndexFromProps, startIndexFromProps]);
  useBrushChartSynchronisation();
  const onChange = (0, import_react43.useCallback)((nextState) => {
    if (dataIndexes == null) {
      return;
    }
    const {
      startIndex: startIndex2,
      endIndex: endIndex2
    } = dataIndexes;
    if (nextState.startIndex !== startIndex2 || nextState.endIndex !== endIndex2) {
      onChangeFromContext === null || onChangeFromContext === void 0 || onChangeFromContext(nextState);
      onChangeFromProps === null || onChangeFromProps === void 0 || onChangeFromProps(nextState);
      dispatch(setDataStartEndIndexes(nextState));
    }
  }, [onChangeFromProps, onChangeFromContext, dispatch, dataIndexes]);
  const brushDimensions = useAppSelector(selectBrushDimensions);
  if (brushDimensions == null || dataIndexes == null || chartData == null || !chartData.length) {
    return null;
  }
  const {
    startIndex,
    endIndex
  } = dataIndexes;
  const {
    x: x2,
    y: y2,
    width
  } = brushDimensions;
  const contextProperties = {
    data: chartData,
    x: x2,
    y: y2,
    width,
    startIndex,
    endIndex,
    onChange
  };
  return React38.createElement(BrushWithState, _extends27({}, props, contextProperties, {
    startIndexControlledFromProps: startIndexFromProps !== null && startIndexFromProps !== void 0 ? startIndexFromProps : void 0,
    endIndexControlledFromProps: endIndexFromProps !== null && endIndexFromProps !== void 0 ? endIndexFromProps : void 0
  }));
}
function BrushSettingsDispatcher(props) {
  const dispatch = useAppDispatch();
  (0, import_react43.useEffect)(() => {
    dispatch(setBrushSettings(props));
    return () => {
      dispatch(setBrushSettings(null));
    };
  }, [dispatch, props]);
  return null;
}
const defaultBrushProps = {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: false
};
function Brush(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultBrushProps);
  return React38.createElement(React38.Fragment, null, React38.createElement(BrushSettingsDispatcher, {
    height: props.height,
    x: props.x,
    y: props.y,
    width: props.width,
    padding: props.padding
  }), React38.createElement(BrushInternal, props));
}
Brush.displayName = "Brush";

// node_modules/recharts/es6/cartesian/ReferenceLine.js
const React40 = __toESM(require_react());
const import_react45 = __toESM(require_react());

// node_modules/recharts/es6/util/CartesianUtils.js
function ownKeys44(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread44(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys44(Object(t), true).forEach(function(r2) {
      _defineProperty45(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys44(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty45(e, r, t) {
  return (r = _toPropertyKey45(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey45(t) {
  const i = _toPrimitive45(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive45(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const rectWithPoints = (_ref2, _ref22) => {
  const {
    x: x1,
    y: y1
  } = _ref2;
  const {
    x: x2,
    y: y2
  } = _ref22;
  return {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    width: Math.abs(x2 - x1),
    height: Math.abs(y2 - y1)
  };
};
const rectWithCoords = (_ref3) => {
  const {
    x1,
    y1,
    x2,
    y2
  } = _ref3;
  return rectWithPoints({
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  });
};
const ScaleHelper = class _ScaleHelper {
  static create(obj) {
    return new _ScaleHelper(obj);
  }
  constructor(scale) {
    this.scale = scale;
  }
  get domain() {
    return this.scale.domain;
  }
  get range() {
    return this.scale.range;
  }
  get rangeMin() {
    return this.range()[0];
  }
  get rangeMax() {
    return this.range()[1];
  }
  get bandwidth() {
    return this.scale.bandwidth;
  }
  apply(value) {
    const {
      bandAware,
      position: position2
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (value === void 0) {
      return void 0;
    }
    if (position2) {
      switch (position2) {
        case "start": {
          return this.scale(value);
        }
        case "middle": {
          const offset = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(value) + offset;
        }
        case "end": {
          const _offset = this.bandwidth ? this.bandwidth() : 0;
          return this.scale(value) + _offset;
        }
        default: {
          return this.scale(value);
        }
      }
    }
    if (bandAware) {
      const _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
      return this.scale(value) + _offset2;
    }
    return this.scale(value);
  }
  isInRange(value) {
    const range6 = this.range();
    const first = range6[0];
    const last4 = range6[range6.length - 1];
    return first <= last4 ? value >= first && value <= last4 : value >= last4 && value <= first;
  }
};
_defineProperty45(ScaleHelper, "EPS", 1e-4);
const createLabeledScales = (options3) => {
  const scales = Object.keys(options3).reduce((res, key) => _objectSpread44(_objectSpread44({}, res), {}, {
    [key]: ScaleHelper.create(options3[key])
  }), {});
  return _objectSpread44(_objectSpread44({}, scales), {}, {
    apply(coord) {
      const {
        bandAware,
        position: position2
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return Object.fromEntries(Object.entries(coord).map((_ref4) => {
        const [label, value] = _ref4;
        return [label, scales[label].apply(value, {
          bandAware,
          position: position2
        })];
      }));
    },
    isInRange(coord) {
      return Object.keys(coord).every((label) => scales[label].isInRange(coord[label]));
    }
  });
};
function normalizeAngle(angle) {
  return (angle % 180 + 180) % 180;
}
const getAngledRectangleWidth = function getAngledRectangleWidth2(_ref5) {
  const {
    width,
    height
  } = _ref5;
  const angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const normalizedAngle = normalizeAngle(angle);
  const angleRadians = normalizedAngle * Math.PI / 180;
  const angleThreshold = Math.atan(height / width);
  const angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
  return Math.abs(angledWidth);
};

// node_modules/recharts/es6/state/referenceElementsSlice.js
const initialState10 = {
  dots: [],
  areas: [],
  lines: []
};
const referenceElementsSlice = createSlice({
  name: "referenceElements",
  initialState: initialState10,
  reducers: {
    addDot: (state, action) => {
      state.dots.push(action.payload);
    },
    removeDot: (state, action) => {
      const index2 = current(state).dots.findIndex((dot) => dot === action.payload);
      if (index2 !== -1) {
        state.dots.splice(index2, 1);
      }
    },
    addArea: (state, action) => {
      state.areas.push(action.payload);
    },
    removeArea: (state, action) => {
      const index2 = current(state).areas.findIndex((area) => area === action.payload);
      if (index2 !== -1) {
        state.areas.splice(index2, 1);
      }
    },
    addLine: (state, action) => {
      state.lines.push(action.payload);
    },
    removeLine: (state, action) => {
      const index2 = current(state).lines.findIndex((line) => line === action.payload);
      if (index2 !== -1) {
        state.lines.splice(index2, 1);
      }
    }
  }
});
const {
  addDot,
  removeDot,
  addArea,
  removeArea,
  addLine,
  removeLine
} = referenceElementsSlice.actions;
const referenceElementsReducer = referenceElementsSlice.reducer;

// node_modules/recharts/es6/container/ClipPathProvider.js
const React39 = __toESM(require_react());
const import_react44 = __toESM(require_react());
const ClipPathIdContext = (0, import_react44.createContext)(void 0);
const ClipPathProvider = (_ref2) => {
  const {
    children
  } = _ref2;
  const [clipPathId] = (0, import_react44.useState)("".concat(uniqueId("recharts"), "-clip"));
  const plotArea = usePlotArea();
  if (plotArea == null) {
    return null;
  }
  const {
    x: x2,
    y: y2,
    width,
    height
  } = plotArea;
  return React39.createElement(ClipPathIdContext.Provider, {
    value: clipPathId
  }, React39.createElement("defs", null, React39.createElement("clipPath", {
    id: clipPathId
  }, React39.createElement("rect", {
    x: x2,
    y: y2,
    height,
    width
  }))), children);
};
const useClipPathId = () => {
  return (0, import_react44.useContext)(ClipPathIdContext);
};

// node_modules/recharts/es6/cartesian/ReferenceLine.js
function ownKeys45(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread45(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys45(Object(t), true).forEach(function(r2) {
      _defineProperty46(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys45(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty46(e, r, t) {
  return (r = _toPropertyKey46(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey46(t) {
  const i = _toPrimitive46(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive46(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends28() {
  return _extends28 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends28.apply(null, arguments);
}
const renderLine = (option, props) => {
  let line;
  if (React40.isValidElement(option)) {
    line = React40.cloneElement(option, props);
  } else if (typeof option === "function") {
    line = option(props);
  } else {
    line = React40.createElement("line", _extends28({}, props, {
      className: "recharts-reference-line-line"
    }));
  }
  return line;
};
const getEndPoints = (scales, isFixedX, isFixedY, isSegment, viewBox, position2, xAxisOrientation, yAxisOrientation, props) => {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = viewBox;
  if (isFixedY) {
    const {
      y: yCoord
    } = props;
    const coord = scales.y.apply(yCoord, {
      position: position2
    });
    if (isNan(coord)) return null;
    if (props.ifOverflow === "discard" && !scales.y.isInRange(coord)) {
      return null;
    }
    const points = [{
      x: x2 + width,
      y: coord
    }, {
      x: x2,
      y: coord
    }];
    return yAxisOrientation === "left" ? points.reverse() : points;
  }
  if (isFixedX) {
    const {
      x: xCoord
    } = props;
    const _coord = scales.x.apply(xCoord, {
      position: position2
    });
    if (isNan(_coord)) return null;
    if (props.ifOverflow === "discard" && !scales.x.isInRange(_coord)) {
      return null;
    }
    const _points = [{
      x: _coord,
      y: y2 + height
    }, {
      x: _coord,
      y: y2
    }];
    return xAxisOrientation === "top" ? _points.reverse() : _points;
  }
  if (isSegment) {
    const {
      segment
    } = props;
    const _points2 = segment.map((p) => scales.apply(p, {
      position: position2
    }));
    if (props.ifOverflow === "discard" && _points2.some((p) => !scales.isInRange(p))) {
      return null;
    }
    return _points2;
  }
  return null;
};
function ReportReferenceLine(props) {
  const dispatch = useAppDispatch();
  (0, import_react45.useEffect)(() => {
    dispatch(addLine(props));
    return () => {
      dispatch(removeLine(props));
    };
  });
  return null;
}
function ReferenceLineImpl(props) {
  const {
    x: fixedX,
    y: fixedY,
    segment,
    xAxisId,
    yAxisId,
    shape,
    className,
    ifOverflow
  } = props;
  const isPanorama = useIsPanorama();
  const clipPathId = useClipPathId();
  const xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
  const yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
  const xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
  const yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
  const viewBox = useViewBox();
  const isFixedX = isNumOrStr(fixedX);
  const isFixedY = isNumOrStr(fixedY);
  if (!clipPathId || !viewBox || xAxis == null || yAxis == null || xAxisScale == null || yAxisScale == null) {
    return null;
  }
  const scales = createLabeledScales({
    x: xAxisScale,
    y: yAxisScale
  });
  const isSegment = segment && segment.length === 2;
  const endPoints = getEndPoints(scales, isFixedX, isFixedY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
  if (!endPoints) {
    return null;
  }
  const [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }] = endPoints;
  const clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
  const lineProps = _objectSpread45(_objectSpread45({
    clipPath
  }, filterProps(props, true)), {}, {
    x1,
    y1,
    x2,
    y2
  });
  return React40.createElement(Layer, {
    className: clsx("recharts-reference-line", className)
  }, renderLine(shape, lineProps), React40.createElement(CartesianLabelContextProvider, rectWithCoords({
    x1,
    y1,
    x2,
    y2
  }), React40.createElement(CartesianLabelFromLabelProp, {
    label: props.label
  }), props.children));
}
function ReferenceLineSettingsDispatcher(props) {
  return React40.createElement(React40.Fragment, null, React40.createElement(ReportReferenceLine, {
    yAxisId: props.yAxisId,
    xAxisId: props.xAxisId,
    ifOverflow: props.ifOverflow,
    x: props.x,
    y: props.y
  }), React40.createElement(ReferenceLineImpl, props));
}
const ReferenceLine = class extends import_react45.Component {
  render() {
    return React40.createElement(ReferenceLineSettingsDispatcher, this.props);
  }
};
_defineProperty46(ReferenceLine, "displayName", "ReferenceLine");
_defineProperty46(ReferenceLine, "defaultProps", {
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
});

// node_modules/recharts/es6/cartesian/ReferenceDot.js
const React41 = __toESM(require_react());
const import_react46 = __toESM(require_react());
function ownKeys46(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread46(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys46(Object(t), true).forEach(function(r2) {
      _defineProperty47(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys46(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty47(e, r, t) {
  return (r = _toPropertyKey47(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey47(t) {
  const i = _toPrimitive47(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive47(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends29() {
  return _extends29 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends29.apply(null, arguments);
}
const useCoordinate = (x2, y2, xAxisId, yAxisId, ifOverflow) => {
  const isX = isNumOrStr(x2);
  const isY = isNumOrStr(y2);
  const isPanorama = useIsPanorama();
  const xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
  const yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
  if (!isX || !isY || xAxisScale == null || yAxisScale == null) {
    return null;
  }
  const scales = createLabeledScales({
    x: xAxisScale,
    y: yAxisScale
  });
  const result = scales.apply({
    x: x2,
    y: y2
  }, {
    bandAware: true
  });
  if (ifOverflow === "discard" && !scales.isInRange(result)) {
    return null;
  }
  return result;
};
function ReportReferenceDot(props) {
  const dispatch = useAppDispatch();
  (0, import_react46.useEffect)(() => {
    dispatch(addDot(props));
    return () => {
      dispatch(removeDot(props));
    };
  });
  return null;
}
const renderDot = (option, props) => {
  let dot;
  if (React41.isValidElement(option)) {
    dot = React41.cloneElement(option, props);
  } else if (typeof option === "function") {
    dot = option(props);
  } else {
    dot = React41.createElement(Dot, _extends29({}, props, {
      cx: props.cx,
      cy: props.cy,
      className: "recharts-reference-dot-dot"
    }));
  }
  return dot;
};
function ReferenceDotImpl(props) {
  const {
    x: x2,
    y: y2,
    r
  } = props;
  const clipPathId = useClipPathId();
  const coordinate = useCoordinate(x2, y2, props.xAxisId, props.yAxisId, props.ifOverflow);
  if (!coordinate) {
    return null;
  }
  const {
    x: cx,
    y: cy
  } = coordinate;
  const {
    shape,
    className,
    ifOverflow
  } = props;
  const clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
  const dotProps = _objectSpread46(_objectSpread46({
    clipPath
  }, filterProps(props, true)), {}, {
    cx,
    cy
  });
  return React41.createElement(Layer, {
    className: clsx("recharts-reference-dot", className)
  }, renderDot(shape, dotProps), React41.createElement(CartesianLabelContextProvider, {
    x: cx - r,
    y: cy - r,
    width: 2 * r,
    height: 2 * r
  }, React41.createElement(CartesianLabelFromLabelProp, {
    label: props.label
  }), props.children));
}
function ReferenceDotSettingsDispatcher(props) {
  const {
    x: x2,
    y: y2,
    r,
    ifOverflow,
    yAxisId,
    xAxisId
  } = props;
  return React41.createElement(React41.Fragment, null, React41.createElement(ReportReferenceDot, {
    y: y2,
    x: x2,
    r,
    yAxisId,
    xAxisId,
    ifOverflow
  }), React41.createElement(ReferenceDotImpl, props));
}
const ReferenceDot = class extends import_react46.Component {
  render() {
    return React41.createElement(ReferenceDotSettingsDispatcher, this.props);
  }
};
_defineProperty47(ReferenceDot, "displayName", "ReferenceDot");
_defineProperty47(ReferenceDot, "defaultProps", {
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
});

// node_modules/recharts/es6/cartesian/ReferenceArea.js
const React42 = __toESM(require_react());
const import_react47 = __toESM(require_react());
function ownKeys47(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread47(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys47(Object(t), true).forEach(function(r2) {
      _defineProperty48(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys47(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty48(e, r, t) {
  return (r = _toPropertyKey48(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey48(t) {
  const i = _toPrimitive48(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive48(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends30() {
  return _extends30 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends30.apply(null, arguments);
}
const getRect = (hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props) => {
  const {
    x1: xValue1,
    x2: xValue2,
    y1: yValue1,
    y2: yValue2
  } = props;
  if (xAxisScale == null || yAxisScale == null) {
    return null;
  }
  const scales = createLabeledScales({
    x: xAxisScale,
    y: yAxisScale
  });
  const p1 = {
    x: hasX1 ? scales.x.apply(xValue1, {
      position: "start"
    }) : scales.x.rangeMin,
    y: hasY1 ? scales.y.apply(yValue1, {
      position: "start"
    }) : scales.y.rangeMin
  };
  const p2 = {
    x: hasX2 ? scales.x.apply(xValue2, {
      position: "end"
    }) : scales.x.rangeMax,
    y: hasY2 ? scales.y.apply(yValue2, {
      position: "end"
    }) : scales.y.rangeMax
  };
  if (props.ifOverflow === "discard" && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
    return null;
  }
  return rectWithPoints(p1, p2);
};
const renderRect = (option, props) => {
  let rect;
  if (React42.isValidElement(option)) {
    rect = React42.cloneElement(option, props);
  } else if (typeof option === "function") {
    rect = option(props);
  } else {
    rect = React42.createElement(Rectangle, _extends30({}, props, {
      className: "recharts-reference-area-rect"
    }));
  }
  return rect;
};
function ReportReferenceArea(props) {
  const dispatch = useAppDispatch();
  (0, import_react47.useEffect)(() => {
    dispatch(addArea(props));
    return () => {
      dispatch(removeArea(props));
    };
  });
  return null;
}
function ReferenceAreaImpl(props) {
  const {
    x1,
    x2,
    y1,
    y2,
    className,
    shape,
    xAxisId,
    yAxisId
  } = props;
  const clipPathId = useClipPathId();
  const isPanorama = useIsPanorama();
  const xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
  const yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
  if (xAxisScale == null || !yAxisScale == null) {
    return null;
  }
  const hasX1 = isNumOrStr(x1);
  const hasX2 = isNumOrStr(x2);
  const hasY1 = isNumOrStr(y1);
  const hasY2 = isNumOrStr(y2);
  if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
    return null;
  }
  const rect = getRect(hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props);
  if (!rect && !shape) {
    return null;
  }
  const isOverflowHidden = props.ifOverflow === "hidden";
  const clipPath = isOverflowHidden ? "url(#".concat(clipPathId, ")") : void 0;
  return React42.createElement(Layer, {
    className: clsx("recharts-reference-area", className)
  }, renderRect(shape, _objectSpread47(_objectSpread47({
    clipPath
  }, filterProps(props, true)), rect)), React42.createElement(CartesianLabelContextProvider, rect, React42.createElement(CartesianLabelFromLabelProp, {
    label: props.label
  }), props.children));
}
function ReferenceAreaSettingsDispatcher(props) {
  return React42.createElement(React42.Fragment, null, React42.createElement(ReportReferenceArea, {
    yAxisId: props.yAxisId,
    xAxisId: props.xAxisId,
    ifOverflow: props.ifOverflow,
    x1: props.x1,
    x2: props.x2,
    y1: props.y1,
    y2: props.y2
  }), React42.createElement(ReferenceAreaImpl, props));
}
const ReferenceArea = class extends import_react47.Component {
  render() {
    return React42.createElement(ReferenceAreaSettingsDispatcher, this.props);
  }
};
_defineProperty48(ReferenceArea, "displayName", "ReferenceArea");
_defineProperty48(ReferenceArea, "defaultProps", {
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
});

// node_modules/recharts/es6/cartesian/CartesianAxis.js
const React43 = __toESM(require_react());
const import_react48 = __toESM(require_react());
const import_get5 = __toESM(require_get2());

// node_modules/recharts/es6/util/ShallowEqual.js
function shallowEqual(a2, b) {
  for (const key in a2) {
    if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b, key) || a2[key] !== b[key])) {
      return false;
    }
  }
  for (const _key in b) {
    if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a2, _key)) {
      return false;
    }
  }
  return true;
}

// node_modules/recharts/es6/util/getEveryNthWithCondition.js
function getEveryNthWithCondition(array2, n, isValid) {
  if (n < 1) {
    return [];
  }
  if (n === 1 && isValid === void 0) {
    return array2;
  }
  const result = [];
  for (let i = 0; i < array2.length; i += n) {
    if (isValid === void 0 || isValid(array2[i]) === true) {
      result.push(array2[i]);
    } else {
      return void 0;
    }
  }
  return result;
}

// node_modules/recharts/es6/util/TickUtils.js
function getAngledTickWidth(contentSize, unitSize, angle) {
  const size = {
    width: contentSize.width + unitSize.width,
    height: contentSize.height + unitSize.height
  };
  return getAngledRectangleWidth(size, angle);
}
function getTickBoundaries(viewBox, sign2, sizeKey) {
  const isWidth = sizeKey === "width";
  const {
    x: x2,
    y: y2,
    width,
    height
  } = viewBox;
  if (sign2 === 1) {
    return {
      start: isWidth ? x2 : y2,
      end: isWidth ? x2 + width : y2 + height
    };
  }
  return {
    start: isWidth ? x2 + width : y2 + height,
    end: isWidth ? x2 : y2
  };
}
function isVisible(sign2, tickPosition, getSize, start, end) {
  if (sign2 * tickPosition < sign2 * start || sign2 * tickPosition > sign2 * end) {
    return false;
  }
  const size = getSize();
  return sign2 * (tickPosition - sign2 * size / 2 - start) >= 0 && sign2 * (tickPosition + sign2 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks2, interval) {
  return getEveryNthWithCondition(ticks2, interval + 1);
}

// node_modules/recharts/es6/cartesian/getEquidistantTicks.js
function getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  const result = (ticks2 || []).slice();
  const {
    start: initialStart,
    end
  } = boundaries;
  let index2 = 0;
  let stepsize = 1;
  let start = initialStart;
  let _loop = function _loop2() {
    const entry = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2[index2];
    if (entry === void 0) {
      return {
        v: getEveryNthWithCondition(ticks2, stepsize)
      };
    }
    const i = index2;
    let size;
    const getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i);
      }
      return size;
    };
    const tickCoord = entry.coordinate;
    const isShow = index2 === 0 || isVisible(sign2, tickCoord, getSize, start, end);
    if (!isShow) {
      index2 = 0;
      start = initialStart;
      stepsize += 1;
    }
    if (isShow) {
      start = tickCoord + sign2 * (getSize() / 2 + minTickGap);
      index2 += stepsize;
    }
  }, _ret;
  while (stepsize <= result.length) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return [];
}

// node_modules/recharts/es6/cartesian/getTicks.js
function ownKeys48(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread48(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys48(Object(t), true).forEach(function(r2) {
      _defineProperty49(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys48(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty49(e, r, t) {
  return (r = _toPropertyKey49(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey49(t) {
  const i = _toPrimitive49(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive49(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap) {
  const result = (ticks2 || []).slice();
  const len = result.length;
  const {
    start
  } = boundaries;
  let {
    end
  } = boundaries;
  const _loop = function _loop2(i2) {
    let entry = result[i2];
    let size;
    const getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i2);
      }
      return size;
    };
    if (i2 === len - 1) {
      const gap = sign2 * (entry.coordinate + sign2 * getSize() / 2 - end);
      result[i2] = entry = _objectSpread48(_objectSpread48({}, entry), {}, {
        tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i2] = entry = _objectSpread48(_objectSpread48({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    const isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
    if (isShow) {
      end = entry.tickCoord - sign2 * (getSize() / 2 + minTickGap);
      result[i2] = _objectSpread48(_objectSpread48({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (let i = len - 1; i >= 0; i--) {
    _loop(i);
  }
  return result;
}
function getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, preserveEnd) {
  const result = (ticks2 || []).slice();
  const len = result.length;
  let {
    start,
    end
  } = boundaries;
  if (preserveEnd) {
    let tail2 = ticks2[len - 1];
    const tailSize = getTickSize(tail2, len - 1);
    const tailGap = sign2 * (tail2.coordinate + sign2 * tailSize / 2 - end);
    result[len - 1] = tail2 = _objectSpread48(_objectSpread48({}, tail2), {}, {
      tickCoord: tailGap > 0 ? tail2.coordinate - tailGap * sign2 : tail2.coordinate
    });
    const isTailShow = isVisible(sign2, tail2.tickCoord, () => tailSize, start, end);
    if (isTailShow) {
      end = tail2.tickCoord - sign2 * (tailSize / 2 + minTickGap);
      result[len - 1] = _objectSpread48(_objectSpread48({}, tail2), {}, {
        isShow: true
      });
    }
  }
  const count2 = preserveEnd ? len - 1 : len;
  const _loop2 = function _loop22(i2) {
    let entry = result[i2];
    let size;
    const getSize = () => {
      if (size === void 0) {
        size = getTickSize(entry, i2);
      }
      return size;
    };
    if (i2 === 0) {
      const gap = sign2 * (entry.coordinate - sign2 * getSize() / 2 - start);
      result[i2] = entry = _objectSpread48(_objectSpread48({}, entry), {}, {
        tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i2] = entry = _objectSpread48(_objectSpread48({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    const isShow = isVisible(sign2, entry.tickCoord, getSize, start, end);
    if (isShow) {
      start = entry.tickCoord + sign2 * (getSize() / 2 + minTickGap);
      result[i2] = _objectSpread48(_objectSpread48({}, entry), {}, {
        isShow: true
      });
    }
  };
  for (let i = 0; i < count2; i++) {
    _loop2(i);
  }
  return result;
}
function getTicks(props, fontSize, letterSpacing) {
  const {
    tick,
    ticks: ticks2,
    viewBox,
    minTickGap,
    orientation,
    interval,
    tickFormatter,
    unit: unit2,
    angle
  } = props;
  if (!ticks2 || !ticks2.length || !tick) {
    return [];
  }
  if (isNumber(interval) || Global.isSsr) {
    let _getNumberIntervalTic;
    return (_getNumberIntervalTic = getNumberIntervalTicks(ticks2, isNumber(interval) ? interval : 0)) !== null && _getNumberIntervalTic !== void 0 ? _getNumberIntervalTic : [];
  }
  let candidates = [];
  const sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
  const unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
    fontSize,
    letterSpacing
  }) : {
    width: 0,
    height: 0
  };
  const getTickSize = (content, index2) => {
    const value = typeof tickFormatter === "function" ? tickFormatter(content.value, index2) : content.value;
    return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
      fontSize,
      letterSpacing
    }), unitSize, angle) : getStringSize(value, {
      fontSize,
      letterSpacing
    })[sizeKey];
  };
  const sign2 = ticks2.length >= 2 ? mathSign(ticks2[1].coordinate - ticks2[0].coordinate) : 1;
  const boundaries = getTickBoundaries(viewBox, sign2, sizeKey);
  if (interval === "equidistantPreserveStart") {
    return getEquidistantTicks(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  if (interval === "preserveStart" || interval === "preserveStartEnd") {
    candidates = getTicksStart(sign2, boundaries, getTickSize, ticks2, minTickGap, interval === "preserveStartEnd");
  } else {
    candidates = getTicksEnd(sign2, boundaries, getTickSize, ticks2, minTickGap);
  }
  return candidates.filter((entry) => entry.isShow);
}

// node_modules/recharts/es6/util/YAxisUtils.js
const getCalculatedYAxisWidth = (_ref2) => {
  const {
    ticks: ticks2,
    label,
    labelGapWithTick = 5,
    // Default gap between label and tick
    tickSize = 0,
    tickMargin = 0
  } = _ref2;
  let maxTickWidth = 0;
  if (ticks2) {
    ticks2.forEach((tickNode) => {
      if (tickNode) {
        const bbox = tickNode.getBoundingClientRect();
        if (bbox.width > maxTickWidth) {
          maxTickWidth = bbox.width;
        }
      }
    });
    const labelWidth = label ? label.getBoundingClientRect().width : 0;
    const tickWidth = tickSize + tickMargin;
    const updatedYAxisWidth = maxTickWidth + tickWidth + labelWidth + (label ? labelGapWithTick : 0);
    return Math.round(updatedYAxisWidth);
  }
  return 0;
};

// node_modules/recharts/es6/cartesian/CartesianAxis.js
const _excluded28 = ["axisLine", "width", "height", "className", "hide", "ticks"];
const _excluded29 = ["viewBox"];
const _excluded35 = ["viewBox"];
function _objectWithoutProperties22(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose22(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose22(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends31() {
  return _extends31 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends31.apply(null, arguments);
}
function ownKeys49(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread49(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys49(Object(t), true).forEach(function(r2) {
      _defineProperty50(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys49(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty50(e, r, t) {
  return (r = _toPropertyKey50(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey50(t) {
  const i = _toPrimitive50(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive50(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const defaultCartesianAxisProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: true,
  axisLine: true,
  tick: true,
  mirror: false,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
};
function AxisLine2(axisLineProps) {
  const {
    x: x2,
    y: y2,
    width,
    height,
    orientation,
    mirror,
    axisLine,
    otherSvgProps
  } = axisLineProps;
  if (!axisLine) {
    return null;
  }
  let props = _objectSpread49(_objectSpread49(_objectSpread49({}, otherSvgProps), filterProps(axisLine, false)), {}, {
    fill: "none"
  });
  if (orientation === "top" || orientation === "bottom") {
    const needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
    props = _objectSpread49(_objectSpread49({}, props), {}, {
      x1: x2,
      y1: y2 + needHeight * height,
      x2: x2 + width,
      y2: y2 + needHeight * height
    });
  } else {
    const needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
    props = _objectSpread49(_objectSpread49({}, props), {}, {
      x1: x2 + needWidth * width,
      y1: y2,
      x2: x2 + needWidth * width,
      y2: y2 + height
    });
  }
  return React43.createElement("line", _extends31({}, props, {
    className: clsx("recharts-cartesian-axis-line", (0, import_get5.default)(axisLine, "className"))
  }));
}
function getTickLineCoord2(data, x2, y2, width, height, orientation, tickSize, mirror, tickMargin) {
  let x1, x22, y1, y22, tx, ty;
  const sign2 = mirror ? -1 : 1;
  const finalTickSize = data.tickSize || tickSize;
  const tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
  switch (orientation) {
    case "top":
      x1 = x22 = data.coordinate;
      y22 = y2 + +!mirror * height;
      y1 = y22 - sign2 * finalTickSize;
      ty = y1 - sign2 * tickMargin;
      tx = tickCoord;
      break;
    case "left":
      y1 = y22 = data.coordinate;
      x22 = x2 + +!mirror * width;
      x1 = x22 - sign2 * finalTickSize;
      tx = x1 - sign2 * tickMargin;
      ty = tickCoord;
      break;
    case "right":
      y1 = y22 = data.coordinate;
      x22 = x2 + +mirror * width;
      x1 = x22 + sign2 * finalTickSize;
      tx = x1 + sign2 * tickMargin;
      ty = tickCoord;
      break;
    default:
      x1 = x22 = data.coordinate;
      y22 = y2 + +mirror * height;
      y1 = y22 + sign2 * finalTickSize;
      ty = y1 + sign2 * tickMargin;
      tx = tickCoord;
      break;
  }
  return {
    line: {
      x1,
      y1,
      x2: x22,
      y2: y22
    },
    tick: {
      x: tx,
      y: ty
    }
  };
}
function getTickTextAnchor3(orientation, mirror) {
  switch (orientation) {
    case "left":
      return mirror ? "start" : "end";
    case "right":
      return mirror ? "end" : "start";
    default:
      return "middle";
  }
}
function getTickVerticalAnchor(orientation, mirror) {
  switch (orientation) {
    case "left":
    case "right":
      return "middle";
    case "top":
      return mirror ? "start" : "end";
    default:
      return mirror ? "end" : "start";
  }
}
function TickItem(props) {
  const {
    option,
    tickProps,
    value
  } = props;
  let tickItem;
  const combinedClassName = clsx(tickProps.className, "recharts-cartesian-axis-tick-value");
  if (React43.isValidElement(option)) {
    tickItem = React43.cloneElement(option, _objectSpread49(_objectSpread49({}, tickProps), {}, {
      className: combinedClassName
    }));
  } else if (typeof option === "function") {
    tickItem = option(_objectSpread49(_objectSpread49({}, tickProps), {}, {
      className: combinedClassName
    }));
  } else {
    let className = "recharts-cartesian-axis-tick-value";
    if (typeof option !== "boolean") {
      className = clsx(className, option === null || option === void 0 ? void 0 : option.className);
    }
    tickItem = React43.createElement(Text, _extends31({}, tickProps, {
      className
    }), value);
  }
  return tickItem;
}
function Ticks2(props) {
  const {
    ticks: ticks2 = [],
    tick,
    tickLine,
    stroke,
    tickFormatter,
    unit: unit2,
    padding,
    tickTextProps,
    orientation,
    mirror,
    x: x2,
    y: y2,
    width,
    height,
    tickSize,
    tickMargin,
    fontSize,
    letterSpacing,
    getTicksConfig,
    events
  } = props;
  const finalTicks = getTicks(_objectSpread49(_objectSpread49({}, getTicksConfig), {}, {
    ticks: ticks2
  }), fontSize, letterSpacing);
  const textAnchor = getTickTextAnchor3(orientation, mirror);
  const verticalAnchor = getTickVerticalAnchor(orientation, mirror);
  const axisProps = svgPropertiesNoEvents(getTicksConfig);
  const customTickProps = filterProps(tick, false);
  const tickLineProps = _objectSpread49(_objectSpread49({}, axisProps), {}, {
    fill: "none"
  }, filterProps(tickLine, false));
  const items = finalTicks.map((entry, i) => {
    const {
      line: lineCoord,
      tick: tickCoord
    } = getTickLineCoord2(entry, x2, y2, width, height, orientation, tickSize, mirror, tickMargin);
    const tickProps = _objectSpread49(_objectSpread49(_objectSpread49(_objectSpread49({
      // @ts-expect-error textAnchor from axisProps is typed as `string` but Text wants type `TextAnchor`
      textAnchor,
      verticalAnchor
    }, axisProps), {}, {
      stroke: "none",
      fill: stroke
    }, customTickProps), tickCoord), {}, {
      index: i,
      payload: entry,
      visibleTicksCount: finalTicks.length,
      tickFormatter,
      padding
    }, tickTextProps);
    return React43.createElement(Layer, _extends31({
      className: "recharts-cartesian-axis-tick",
      key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
    }, adaptEventsOfChild(events, entry, i)), tickLine && // @ts-expect-error recharts scale is not compatible with SVG scale
    React43.createElement("line", _extends31({}, tickLineProps, lineCoord, {
      className: clsx("recharts-cartesian-axis-tick-line", (0, import_get5.default)(tickLine, "className"))
    })), tick && React43.createElement(TickItem, {
      option: tick,
      tickProps,
      value: "".concat(typeof tickFormatter === "function" ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")
    }));
  });
  if (items.length > 0) {
    return React43.createElement("g", {
      className: "recharts-cartesian-axis-ticks"
    }, items);
  }
  return null;
}
const CartesianAxisComponent = (0, import_react48.forwardRef)((props, ref) => {
  let {
    axisLine,
    width,
    height,
    className,
    hide,
    ticks: ticks2
  } = props, rest2 = _objectWithoutProperties22(props, _excluded28);
  const [fontSize, setFontSize] = (0, import_react48.useState)("");
  const [letterSpacing, setLetterSpacing] = (0, import_react48.useState)("");
  const tickRefs = (0, import_react48.useRef)([]);
  (0, import_react48.useImperativeHandle)(ref, () => ({
    getCalculatedWidth: () => {
      let _props$labelRef;
      return getCalculatedYAxisWidth({
        ticks: tickRefs.current,
        label: (_props$labelRef = props.labelRef) === null || _props$labelRef === void 0 ? void 0 : _props$labelRef.current,
        labelGapWithTick: 5,
        tickSize: props.tickSize,
        tickMargin: props.tickMargin
      });
    }
  }));
  const layerRef = (0, import_react48.useCallback)((el) => {
    if (el) {
      const tickNodes = el.getElementsByClassName("recharts-cartesian-axis-tick-value");
      tickRefs.current = Array.from(tickNodes);
      const tick = tickNodes[0];
      if (tick) {
        const computedStyle = window.getComputedStyle(tick);
        const calculatedFontSize = computedStyle.fontSize;
        const calculatedLetterSpacing = computedStyle.letterSpacing;
        if (calculatedFontSize !== fontSize || calculatedLetterSpacing !== letterSpacing) {
          setFontSize(calculatedFontSize);
          setLetterSpacing(calculatedLetterSpacing);
        }
      }
    }
  }, [fontSize, letterSpacing]);
  if (hide) {
    return null;
  }
  if (width != null && width <= 0 || height != null && height <= 0) {
    return null;
  }
  return React43.createElement(Layer, {
    className: clsx("recharts-cartesian-axis", className),
    ref: layerRef
  }, React43.createElement(AxisLine2, {
    x: props.x,
    y: props.y,
    width,
    height,
    orientation: props.orientation,
    mirror: props.mirror,
    axisLine,
    otherSvgProps: svgPropertiesNoEvents(props)
  }), React43.createElement(Ticks2, {
    ticks: ticks2,
    tick: props.tick,
    tickLine: props.tickLine,
    stroke: props.stroke,
    tickFormatter: props.tickFormatter,
    unit: props.unit,
    padding: props.padding,
    tickTextProps: props.tickTextProps,
    orientation: props.orientation,
    mirror: props.mirror,
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height,
    tickSize: props.tickSize,
    tickMargin: props.tickMargin,
    fontSize,
    letterSpacing,
    getTicksConfig: props,
    events: rest2
  }), React43.createElement(CartesianLabelContextProvider, {
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height
  }, React43.createElement(CartesianLabelFromLabelProp, {
    label: props.label
  }), props.children));
});
const MemoCartesianAxis = React43.memo(CartesianAxisComponent, (prevProps, nextProps) => {
  let {
    viewBox: prevViewBox
  } = prevProps, prevRestProps = _objectWithoutProperties22(prevProps, _excluded29);
  let {
    viewBox: nextViewBox
  } = nextProps, nextRestProps = _objectWithoutProperties22(nextProps, _excluded35);
  return shallowEqual(prevViewBox, nextViewBox) && shallowEqual(prevRestProps, nextRestProps);
});
const CartesianAxis = React43.forwardRef((outsideProps, ref) => {
  const props = resolveDefaultProps(outsideProps, defaultCartesianAxisProps);
  return React43.createElement(MemoCartesianAxis, _extends31({}, props, {
    ref
  }));
});
CartesianAxis.displayName = "CartesianAxis";

// node_modules/recharts/es6/cartesian/CartesianGrid.js
const React44 = __toESM(require_react());
const _excluded30 = ["x1", "y1", "x2", "y2", "key"];
const _excluded210 = ["offset"];
const _excluded36 = ["xAxisId", "yAxisId"];
const _excluded43 = ["xAxisId", "yAxisId"];
function ownKeys50(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread50(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys50(Object(t), true).forEach(function(r2) {
      _defineProperty51(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys50(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty51(e, r, t) {
  return (r = _toPropertyKey51(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey51(t) {
  const i = _toPrimitive51(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive51(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends32() {
  return _extends32 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends32.apply(null, arguments);
}
function _objectWithoutProperties23(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose23(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose23(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const Background2 = (props) => {
  const {
    fill: fill2
  } = props;
  if (!fill2 || fill2 === "none") {
    return null;
  }
  const {
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    ry
  } = props;
  return React44.createElement("rect", {
    x: x2,
    y: y2,
    ry,
    width,
    height,
    stroke: "none",
    fill: fill2,
    fillOpacity,
    className: "recharts-cartesian-grid-bg"
  });
};
function renderLineItem(option, props) {
  let lineItem;
  if (React44.isValidElement(option)) {
    lineItem = React44.cloneElement(option, props);
  } else if (typeof option === "function") {
    lineItem = option(props);
  } else {
    let {
      x1,
      y1,
      x2,
      y2,
      key
    } = props, others = _objectWithoutProperties23(props, _excluded30);
    const _svgPropertiesNoEvent = svgPropertiesNoEvents(others), {
      offset: __
    } = _svgPropertiesNoEvent, restOfFilteredProps = _objectWithoutProperties23(_svgPropertiesNoEvent, _excluded210);
    lineItem = React44.createElement("line", _extends32({}, restOfFilteredProps, {
      x1,
      y1,
      x2,
      y2,
      fill: "none",
      key
    }));
  }
  return lineItem;
}
function HorizontalGridLines(props) {
  const {
    x: x2,
    width,
    horizontal = true,
    horizontalPoints
  } = props;
  if (!horizontal || !horizontalPoints || !horizontalPoints.length) {
    return null;
  }
  let {
    xAxisId,
    yAxisId
  } = props, otherLineItemProps = _objectWithoutProperties23(props, _excluded36);
  const items = horizontalPoints.map((entry, i) => {
    const lineItemProps = _objectSpread50(_objectSpread50({}, otherLineItemProps), {}, {
      x1: x2,
      y1: entry,
      x2: x2 + width,
      y2: entry,
      key: "line-".concat(i),
      index: i
    });
    return renderLineItem(horizontal, lineItemProps);
  });
  return React44.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, items);
}
function VerticalGridLines(props) {
  const {
    y: y2,
    height,
    vertical = true,
    verticalPoints
  } = props;
  if (!vertical || !verticalPoints || !verticalPoints.length) {
    return null;
  }
  let {
    xAxisId,
    yAxisId
  } = props, otherLineItemProps = _objectWithoutProperties23(props, _excluded43);
  const items = verticalPoints.map((entry, i) => {
    const lineItemProps = _objectSpread50(_objectSpread50({}, otherLineItemProps), {}, {
      x1: entry,
      y1: y2,
      x2: entry,
      y2: y2 + height,
      key: "line-".concat(i),
      index: i
    });
    return renderLineItem(vertical, lineItemProps);
  });
  return React44.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, items);
}
function HorizontalStripes(props) {
  const {
    horizontalFill,
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    horizontalPoints,
    horizontal = true
  } = props;
  if (!horizontal || !horizontalFill || !horizontalFill.length) {
    return null;
  }
  const roundedSortedHorizontalPoints = horizontalPoints.map((e) => Math.round(e + y2 - y2)).sort((a2, b) => a2 - b);
  if (y2 !== roundedSortedHorizontalPoints[0]) {
    roundedSortedHorizontalPoints.unshift(0);
  }
  const items = roundedSortedHorizontalPoints.map((entry, i) => {
    const lastStripe = !roundedSortedHorizontalPoints[i + 1];
    const lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
    if (lineHeight <= 0) {
      return null;
    }
    const colorIndex = i % horizontalFill.length;
    return React44.createElement("rect", {
      key: "react-".concat(i),
      y: entry,
      x: x2,
      height: lineHeight,
      width,
      stroke: "none",
      fill: horizontalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return React44.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, items);
}
function VerticalStripes(props) {
  const {
    vertical = true,
    verticalFill,
    fillOpacity,
    x: x2,
    y: y2,
    width,
    height,
    verticalPoints
  } = props;
  if (!vertical || !verticalFill || !verticalFill.length) {
    return null;
  }
  const roundedSortedVerticalPoints = verticalPoints.map((e) => Math.round(e + x2 - x2)).sort((a2, b) => a2 - b);
  if (x2 !== roundedSortedVerticalPoints[0]) {
    roundedSortedVerticalPoints.unshift(0);
  }
  const items = roundedSortedVerticalPoints.map((entry, i) => {
    const lastStripe = !roundedSortedVerticalPoints[i + 1];
    const lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
    if (lineWidth <= 0) {
      return null;
    }
    const colorIndex = i % verticalFill.length;
    return React44.createElement("rect", {
      key: "react-".concat(i),
      x: entry,
      y: y2,
      width: lineWidth,
      height,
      stroke: "none",
      fill: verticalFill[colorIndex],
      fillOpacity,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return React44.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, items);
}
const defaultVerticalCoordinatesGenerator = (_ref2, syncWithTicks) => {
  const {
    xAxis,
    width,
    height,
    offset
  } = _ref2;
  return getCoordinatesOfGrid(getTicks(_objectSpread50(_objectSpread50(_objectSpread50({}, defaultCartesianAxisProps), xAxis), {}, {
    ticks: getTicksOfAxis(xAxis, true),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset.left, offset.left + offset.width, syncWithTicks);
};
const defaultHorizontalCoordinatesGenerator = (_ref2, syncWithTicks) => {
  const {
    yAxis,
    width,
    height,
    offset
  } = _ref2;
  return getCoordinatesOfGrid(getTicks(_objectSpread50(_objectSpread50(_objectSpread50({}, defaultCartesianAxisProps), yAxis), {}, {
    ticks: getTicksOfAxis(yAxis, true),
    viewBox: {
      x: 0,
      y: 0,
      width,
      height
    }
  })), offset.top, offset.top + offset.height, syncWithTicks);
};
const defaultProps4 = {
  horizontal: true,
  vertical: true,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: [],
  xAxisId: 0,
  yAxisId: 0
};
function CartesianGrid(props) {
  const chartWidth = useChartWidth();
  const chartHeight = useChartHeight();
  const offset = useOffsetInternal();
  const propsIncludingDefaults = _objectSpread50(_objectSpread50({}, resolveDefaultProps(props, defaultProps4)), {}, {
    x: isNumber(props.x) ? props.x : offset.left,
    y: isNumber(props.y) ? props.y : offset.top,
    width: isNumber(props.width) ? props.width : offset.width,
    height: isNumber(props.height) ? props.height : offset.height
  });
  const {
    xAxisId,
    yAxisId,
    x: x2,
    y: y2,
    width,
    height,
    syncWithTicks,
    horizontalValues,
    verticalValues
  } = propsIncludingDefaults;
  const isPanorama = useIsPanorama();
  const xAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "xAxis", xAxisId, isPanorama));
  const yAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "yAxis", yAxisId, isPanorama));
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
    return null;
  }
  const verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
  const horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
  let {
    horizontalPoints,
    verticalPoints
  } = propsIncludingDefaults;
  if ((!horizontalPoints || !horizontalPoints.length) && typeof horizontalCoordinatesGenerator === "function") {
    const isHorizontalValues = horizontalValues && horizontalValues.length;
    const generatorResult = horizontalCoordinatesGenerator({
      yAxis: yAxis ? _objectSpread50(_objectSpread50({}, yAxis), {}, {
        ticks: isHorizontalValues ? horizontalValues : yAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset
    }, isHorizontalValues ? true : syncWithTicks);
    warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof generatorResult, "]"));
    if (Array.isArray(generatorResult)) {
      horizontalPoints = generatorResult;
    }
  }
  if ((!verticalPoints || !verticalPoints.length) && typeof verticalCoordinatesGenerator === "function") {
    const isVerticalValues = verticalValues && verticalValues.length;
    const _generatorResult = verticalCoordinatesGenerator({
      xAxis: xAxis ? _objectSpread50(_objectSpread50({}, xAxis), {}, {
        ticks: isVerticalValues ? verticalValues : xAxis.ticks
      }) : void 0,
      width: chartWidth,
      height: chartHeight,
      offset
    }, isVerticalValues ? true : syncWithTicks);
    warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof _generatorResult, "]"));
    if (Array.isArray(_generatorResult)) {
      verticalPoints = _generatorResult;
    }
  }
  return React44.createElement("g", {
    className: "recharts-cartesian-grid"
  }, React44.createElement(Background2, {
    fill: propsIncludingDefaults.fill,
    fillOpacity: propsIncludingDefaults.fillOpacity,
    x: propsIncludingDefaults.x,
    y: propsIncludingDefaults.y,
    width: propsIncludingDefaults.width,
    height: propsIncludingDefaults.height,
    ry: propsIncludingDefaults.ry
  }), React44.createElement(HorizontalStripes, _extends32({}, propsIncludingDefaults, {
    horizontalPoints
  })), React44.createElement(VerticalStripes, _extends32({}, propsIncludingDefaults, {
    verticalPoints
  })), React44.createElement(HorizontalGridLines, _extends32({}, propsIncludingDefaults, {
    offset,
    horizontalPoints,
    xAxis,
    yAxis
  })), React44.createElement(VerticalGridLines, _extends32({}, propsIncludingDefaults, {
    offset,
    verticalPoints,
    xAxis,
    yAxis
  })));
}
CartesianGrid.displayName = "CartesianGrid";

// node_modules/recharts/es6/cartesian/Line.js
const React45 = __toESM(require_react());
const import_react49 = __toESM(require_react());

// node_modules/recharts/es6/state/selectors/lineSelectors.js
const selectXAxisWithScale2 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
const selectXAxisTicks2 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
const selectYAxisWithScale2 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
const selectYAxisTicks2 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
const selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale2, selectYAxisWithScale2, selectXAxisTicks2, selectYAxisTicks2], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
  if (isCategoricalAxis(layout, "xAxis")) {
    return getBandSizeOfAxis(xAxis, xAxisTicks, false);
  }
  return getBandSizeOfAxis(yAxis, yAxisTicks, false);
});
const pickLineId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
function isLineSettings(item) {
  return item.type === "line";
}
const selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineId], (graphicalItems, id) => graphicalItems.filter(isLineSettings).find((x2) => x2.id === id));
const selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale2, selectYAxisWithScale2, selectXAxisTicks2, selectYAxisTicks2, selectSynchronisedLineSettings, selectBandSize, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref2) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
    return void 0;
  }
  const {
    dataKey,
    data
  } = lineSettings;
  let displayedData;
  if (data != null && data.length > 0) {
    displayedData = data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null) {
    return void 0;
  }
  return computeLinePoints({
    layout,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    dataKey,
    bandSize,
    displayedData
  });
});

// node_modules/recharts/es6/cartesian/Line.js
const _excluded31 = ["id"];
const _excluded211 = ["type", "layout", "connectNulls", "needClip"];
const _excluded37 = ["activeDot", "animateNewValues", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "hide", "isAnimationActive", "label", "legendType", "xAxisId", "yAxisId", "id"];
function ownKeys51(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread51(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys51(Object(t), true).forEach(function(r2) {
      _defineProperty52(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys51(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty52(e, r, t) {
  return (r = _toPropertyKey52(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey52(t) {
  const i = _toPrimitive52(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive52(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties24(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose24(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose24(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends33() {
  return _extends33 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends33.apply(null, arguments);
}
const computeLegendPayloadFromAreaData = (props) => {
  const {
    dataKey,
    name,
    stroke,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: stroke,
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings5(props) {
  const {
    dataKey,
    data,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    unit: unit2
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      nameKey: void 0,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: props.tooltipType,
      color: props.stroke,
      unit: unit2
    }
  };
}
const generateSimpleStrokeDasharray = (totalLength, length) => {
  return "".concat(length, "px ").concat(totalLength - length, "px");
};
function repeat(lines, count2) {
  const linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;
  let result = [];
  for (let i = 0; i < count2; ++i) {
    result = [...result, ...linesUnit];
  }
  return result;
}
const getStrokeDasharray = (length, totalLength, lines) => {
  const lineLength = lines.reduce((pre, next) => pre + next);
  if (!lineLength) {
    return generateSimpleStrokeDasharray(totalLength, length);
  }
  const count2 = Math.floor(length / lineLength);
  const remainLength = length % lineLength;
  const restLength = totalLength - length;
  let remainLines = [];
  for (let i = 0, sum4 = 0; i < lines.length; sum4 += lines[i], ++i) {
    if (sum4 + lines[i] > remainLength) {
      remainLines = [...lines.slice(0, i), remainLength - sum4];
      break;
    }
  }
  const emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
  return [...repeat(lines, count2), ...remainLines, ...emptyLines].map((line) => "".concat(line, "px")).join(", ");
};
function renderDotItem2(option, props) {
  let dotItem;
  if (React45.isValidElement(option)) {
    dotItem = React45.cloneElement(option, props);
  } else if (typeof option === "function") {
    dotItem = option(props);
  } else {
    const className = clsx("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
    dotItem = React45.createElement(Dot, _extends33({}, props, {
      className
    }));
  }
  return dotItem;
}
function shouldRenderDots(points, dot) {
  if (points == null) {
    return false;
  }
  if (dot) {
    return true;
  }
  return points.length === 1;
}
function Dots2(_ref2) {
  const {
    clipPathId,
    points,
    props
  } = _ref2;
  const {
    dot,
    dataKey,
    needClip
  } = props;
  if (!shouldRenderDots(points, dot)) {
    return null;
  }
  let {
    id
  } = props, propsWithoutId = _objectWithoutProperties24(props, _excluded31);
  const clipDot = isClipDot(dot);
  const lineProps = svgPropertiesNoEvents(propsWithoutId);
  const customDotProps = filterProps(dot, true);
  const dots = points.map((entry, i) => {
    const dotProps = _objectSpread51(_objectSpread51(_objectSpread51({
      key: "dot-".concat(i),
      r: 3
    }, lineProps), customDotProps), {}, {
      index: i,
      cx: entry.x,
      cy: entry.y,
      dataKey,
      value: entry.value,
      payload: entry.payload,
      points
    });
    return renderDotItem2(dot, dotProps);
  });
  const dotsProps = {
    clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0
  };
  return React45.createElement(Layer, _extends33({
    className: "recharts-line-dots",
    key: "dots"
  }, dotsProps), dots);
}
function LineLabelListProvider(_ref2) {
  const {
    showLabels,
    children,
    points
  } = _ref2;
  const labelListEntries = (0, import_react49.useMemo)(() => {
    return points === null || points === void 0 ? void 0 : points.map((point6) => {
      const viewBox = {
        x: point6.x,
        y: point6.y,
        width: 0,
        height: 0
      };
      return _objectSpread51(_objectSpread51({}, viewBox), {}, {
        value: point6.value,
        payload: point6.payload,
        viewBox,
        /*
         * Line is not passing parentViewBox to the LabelList so the labels can escape - looks like a bug, should we pass parentViewBox?
         * Or should this just be the root chart viewBox?
         */
        parentViewBox: void 0,
        fill: void 0
      });
    });
  }, [points]);
  return React45.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function StaticCurve(_ref3) {
  const {
    clipPathId,
    pathRef,
    points,
    strokeDasharray,
    props
  } = _ref3;
  let {
    type,
    layout,
    connectNulls,
    needClip
  } = props, others = _objectWithoutProperties24(props, _excluded211);
  const curveProps = _objectSpread51(_objectSpread51({}, filterProps(others, true)), {}, {
    fill: "none",
    className: "recharts-line-curve",
    clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0,
    points,
    type,
    layout,
    connectNulls,
    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray
  });
  return React45.createElement(React45.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && React45.createElement(Curve, _extends33({}, curveProps, {
    pathRef
  })), React45.createElement(Dots2, {
    points,
    clipPathId,
    props
  }));
}
function getTotalLength(mainCurve) {
  try {
    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;
  } catch (_unused) {
    return 0;
  }
}
function CurveWithAnimation(_ref4) {
  const {
    clipPathId,
    props,
    pathRef,
    previousPointsRef,
    longestAnimatedLengthRef
  } = _ref4;
  const {
    points,
    strokeDasharray,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    animateNewValues,
    width,
    height,
    onAnimationEnd,
    onAnimationStart
  } = props;
  const prevPoints = previousPointsRef.current;
  const animationId = useAnimationId(props, "recharts-line-");
  const [isAnimating, setIsAnimating] = (0, import_react49.useState)(false);
  const showLabels = !isAnimating;
  const handleAnimationEnd = (0, import_react49.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react49.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  const totalLength = getTotalLength(pathRef.current);
  const startingPoint = longestAnimatedLengthRef.current;
  return React45.createElement(LineLabelListProvider, {
    points,
    showLabels
  }, props.children, React45.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t) => {
    const lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);
    const curLength = Math.min(lengthInterpolated, totalLength);
    let currentStrokeDasharray;
    if (isAnimationActive) {
      if (strokeDasharray) {
        const lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map((num) => parseFloat(num));
        currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);
      } else {
        currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);
      }
    } else {
      currentStrokeDasharray = strokeDasharray == null ? void 0 : String(strokeDasharray);
    }
    if (prevPoints) {
      const prevPointsDiffFactor = prevPoints.length / points.length;
      const stepData = t === 1 ? points : points.map((entry, index2) => {
        const prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
        if (prevPoints[prevPointIndex]) {
          const prev = prevPoints[prevPointIndex];
          return _objectSpread51(_objectSpread51({}, entry), {}, {
            x: interpolate(prev.x, entry.x, t),
            y: interpolate(prev.y, entry.y, t)
          });
        }
        if (animateNewValues) {
          return _objectSpread51(_objectSpread51({}, entry), {}, {
            x: interpolate(width * 2, entry.x, t),
            y: interpolate(height / 2, entry.y, t)
          });
        }
        return _objectSpread51(_objectSpread51({}, entry), {}, {
          x: entry.x,
          y: entry.y
        });
      });
      previousPointsRef.current = stepData;
      return React45.createElement(StaticCurve, {
        props,
        points: stepData,
        clipPathId,
        pathRef,
        strokeDasharray: currentStrokeDasharray
      });
    }
    if (t > 0 && totalLength > 0) {
      previousPointsRef.current = points;
      longestAnimatedLengthRef.current = curLength;
    }
    return React45.createElement(StaticCurve, {
      props,
      points,
      clipPathId,
      pathRef,
      strokeDasharray: currentStrokeDasharray
    });
  }), React45.createElement(LabelListFromLabelProp, {
    label: props.label
  }));
}
function RenderCurve(_ref5) {
  const {
    clipPathId,
    props
  } = _ref5;
  const previousPointsRef = (0, import_react49.useRef)(null);
  const longestAnimatedLengthRef = (0, import_react49.useRef)(0);
  const pathRef = (0, import_react49.useRef)(null);
  return React45.createElement(CurveWithAnimation, {
    props,
    clipPathId,
    previousPointsRef,
    longestAnimatedLengthRef,
    pathRef
  });
}
const errorBarDataPointFormatter2 = (dataPoint, dataKey) => {
  return {
    x: dataPoint.x,
    y: dataPoint.y,
    value: dataPoint.value,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: getValueByDataKey(dataPoint.payload, dataKey)
  };
};
const LineWithState = class extends import_react49.Component {
  render() {
    let _filterProps;
    const {
      hide,
      dot,
      points,
      className,
      xAxisId,
      yAxisId,
      top,
      left,
      width,
      height,
      id,
      needClip
    } = this.props;
    if (hide) {
      return null;
    }
    const layerClass = clsx("recharts-line", className);
    const clipPathId = id;
    const {
      r = 3,
      strokeWidth = 2
    } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
      r: 3,
      strokeWidth: 2
    };
    const clipDot = isClipDot(dot);
    const dotSize = r * 2 + strokeWidth;
    return React45.createElement(React45.Fragment, null, React45.createElement(Layer, {
      className: layerClass
    }, needClip && React45.createElement("defs", null, React45.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    }), !clipDot && React45.createElement("clipPath", {
      id: "clipPath-dots-".concat(clipPathId)
    }, React45.createElement("rect", {
      x: left - dotSize / 2,
      y: top - dotSize / 2,
      width: width + dotSize,
      height: height + dotSize
    }))), React45.createElement(SetErrorBarContext, {
      xAxisId,
      yAxisId,
      data: points,
      dataPointFormatter: errorBarDataPointFormatter2,
      errorBarOffset: 0
    }, React45.createElement(RenderCurve, {
      props: this.props,
      clipPathId
    }))), React45.createElement(ActivePoints, {
      activeDot: this.props.activeDot,
      points,
      mainColor: this.props.stroke,
      itemDataKey: this.props.dataKey
    }));
  }
};
const defaultLineProps = {
  activeDot: true,
  animateNewValues: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: false,
  dot: true,
  fill: "#fff",
  hide: false,
  isAnimationActive: !Global.isSsr,
  label: false,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  xAxisId: 0,
  yAxisId: 0
};
function LineImpl(props) {
  const _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps), {
    activeDot,
    animateNewValues,
    animationBegin,
    animationDuration,
    animationEasing,
    connectNulls,
    dot,
    hide,
    isAnimationActive,
    label,
    legendType,
    xAxisId,
    yAxisId,
    id
  } = _resolveDefaultProps, everythingElse = _objectWithoutProperties24(_resolveDefaultProps, _excluded37);
  const {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  const plotArea = usePlotArea();
  const layout = useChartLayout();
  const isPanorama = useIsPanorama();
  const points = useAppSelector((state) => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));
  if (layout !== "horizontal" && layout !== "vertical" || points == null || plotArea == null) {
    return null;
  }
  const {
    height,
    width,
    x: left,
    y: top
  } = plotArea;
  return React45.createElement(LineWithState, _extends33({}, everythingElse, {
    id,
    connectNulls,
    dot,
    activeDot,
    animateNewValues,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive,
    hide,
    label,
    legendType,
    xAxisId,
    yAxisId,
    points,
    layout,
    height,
    width,
    left,
    top,
    needClip
  }));
}
function computeLinePoints(_ref6) {
  const {
    layout,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    dataKey,
    bandSize,
    displayedData
  } = _ref6;
  return displayedData.map((entry, index2) => {
    const value = getValueByDataKey(entry, dataKey);
    if (layout === "horizontal") {
      const _x = getCateCoordinateOfLine({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        entry,
        index: index2
      });
      const _y = isNullish(value) ? null : yAxis.scale(value);
      return {
        x: _x,
        y: _y,
        value,
        payload: entry
      };
    }
    const x2 = isNullish(value) ? null : xAxis.scale(value);
    const y2 = getCateCoordinateOfLine({
      axis: yAxis,
      ticks: yAxisTicks,
      bandSize,
      entry,
      index: index2
    });
    if (x2 == null || y2 == null) {
      return null;
    }
    return {
      x: x2,
      y: y2,
      value,
      payload: entry
    };
  }).filter(Boolean);
}
function LineFn(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultLineProps);
  const isPanorama = useIsPanorama();
  return React45.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "line"
  }, (id) => React45.createElement(React45.Fragment, null, React45.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromAreaData(props)
  }), React45.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings5,
    args: props
  }), React45.createElement(SetCartesianGraphicalItem, {
    type: "line",
    id,
    data: props.data,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: 0,
    dataKey: props.dataKey,
    hide: props.hide,
    isPanorama
  }), React45.createElement(LineImpl, _extends33({}, props, {
    id
  }))));
}
const Line = React45.memo(LineFn);
Line.displayName = "Line";

// node_modules/recharts/es6/cartesian/Area.js
const React46 = __toESM(require_react());
const import_react50 = __toESM(require_react());

// node_modules/recharts/es6/state/selectors/areaSelectors.js
const selectXAxisWithScale3 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
const selectXAxisTicks3 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
const selectYAxisWithScale3 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
const selectYAxisTicks3 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
const selectBandSize2 = createSelector([selectChartLayout, selectXAxisWithScale3, selectYAxisWithScale3, selectXAxisTicks3, selectYAxisTicks3], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
  if (isCategoricalAxis(layout, "xAxis")) {
    return getBandSizeOfAxis(xAxis, xAxisTicks, false);
  }
  return getBandSizeOfAxis(yAxis, yAxisTicks, false);
});
const pickAreaId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
const selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "area").find((item) => item.id === id));
const selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, id) => {
  let _stackGroups$stackId;
  const areaSettings = selectSynchronisedAreaSettings(state, xAxisId, yAxisId, isPanorama, id);
  if (areaSettings == null) {
    return void 0;
  }
  const layout = selectChartLayout(state);
  const isXAxisCategorical = isCategoricalAxis(layout, "xAxis");
  let stackGroups;
  if (isXAxisCategorical) {
    stackGroups = selectStackGroups(state, "yAxis", yAxisId, isPanorama);
  } else {
    stackGroups = selectStackGroups(state, "xAxis", xAxisId, isPanorama);
  }
  if (stackGroups == null) {
    return void 0;
  }
  const {
    stackId
  } = areaSettings;
  const stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);
  if (stackId == null || stackSeriesIdentifier == null) {
    return void 0;
  }
  const groups2 = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;
  return groups2 === null || groups2 === void 0 ? void 0 : groups2.find((v) => v.key === stackSeriesIdentifier);
};
const selectArea = createSelector([selectChartLayout, selectXAxisWithScale3, selectYAxisWithScale3, selectXAxisTicks3, selectYAxisTicks3, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize2, selectSynchronisedAreaSettings], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref2, bandSize, areaSettings) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (areaSettings == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {
    return void 0;
  }
  const {
    data
  } = areaSettings;
  let displayedData;
  if (data && data.length > 0) {
    displayedData = data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null) {
    return void 0;
  }
  const chartBaseValue = void 0;
  return computeArea({
    layout,
    xAxis,
    yAxis,
    xAxisTicks,
    yAxisTicks,
    dataStartIndex,
    areaSettings,
    stackedData,
    displayedData,
    chartBaseValue,
    bandSize
  });
});

// node_modules/recharts/es6/cartesian/Area.js
const _excluded38 = ["id"];
const _excluded212 = ["activeDot", "animationBegin", "animationDuration", "animationEasing", "connectNulls", "dot", "fill", "fillOpacity", "hide", "isAnimationActive", "legendType", "stroke", "xAxisId", "yAxisId"];
function _objectWithoutProperties25(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose25(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose25(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys52(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread52(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys52(Object(t), true).forEach(function(r2) {
      _defineProperty53(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys52(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty53(e, r, t) {
  return (r = _toPropertyKey53(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey53(t) {
  const i = _toPrimitive53(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive53(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _extends34() {
  return _extends34 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends34.apply(null, arguments);
}
function getLegendItemColor2(stroke, fill2) {
  return stroke && stroke !== "none" ? stroke : fill2;
}
const computeLegendPayloadFromAreaData2 = (props) => {
  const {
    dataKey,
    name,
    stroke,
    fill: fill2,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: getLegendItemColor2(stroke, fill2),
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function getTooltipEntrySettings6(props) {
  const {
    dataKey,
    data,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    unit: unit2
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      nameKey: void 0,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: props.tooltipType,
      color: getLegendItemColor2(stroke, fill2),
      unit: unit2
    }
  };
}
const renderDotItem3 = (option, props) => {
  let dotItem;
  if (React46.isValidElement(option)) {
    dotItem = React46.cloneElement(option, props);
  } else if (typeof option === "function") {
    dotItem = option(props);
  } else {
    const className = clsx("recharts-area-dot", typeof option !== "boolean" ? option.className : "");
    dotItem = React46.createElement(Dot, _extends34({}, props, {
      className
    }));
  }
  return dotItem;
};
function shouldRenderDots2(points, dot) {
  if (points == null) {
    return false;
  }
  if (dot) {
    return true;
  }
  return points.length === 1;
}
function Dots3(_ref2) {
  const {
    clipPathId,
    points,
    props
  } = _ref2;
  const {
    needClip,
    dot,
    dataKey
  } = props;
  if (!shouldRenderDots2(points, dot)) {
    return null;
  }
  const clipDot = isClipDot(dot);
  const areaProps = svgPropertiesNoEvents(props);
  const customDotProps = filterProps(dot, true);
  const dots = points.map((entry, i) => {
    const dotProps = _objectSpread52(_objectSpread52(_objectSpread52({
      key: "dot-".concat(i),
      r: 3
    }, areaProps), customDotProps), {}, {
      index: i,
      cx: entry.x,
      cy: entry.y,
      dataKey,
      value: entry.value,
      payload: entry.payload,
      points
    });
    return renderDotItem3(dot, dotProps);
  });
  const dotsProps = {
    clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0
  };
  return React46.createElement(Layer, _extends34({
    className: "recharts-area-dots"
  }, dotsProps), dots);
}
function AreaLabelListProvider(_ref2) {
  const {
    showLabels,
    children,
    points
  } = _ref2;
  const labelListEntries = points.map((point6) => {
    const viewBox = {
      x: point6.x,
      y: point6.y,
      width: 0,
      height: 0
    };
    return _objectSpread52(_objectSpread52({}, viewBox), {}, {
      value: point6.value,
      payload: point6.payload,
      parentViewBox: void 0,
      viewBox,
      fill: void 0
    });
  });
  return React46.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function StaticArea(_ref3) {
  const {
    points,
    baseLine,
    needClip,
    clipPathId,
    props
  } = _ref3;
  const {
    layout,
    type,
    stroke,
    connectNulls,
    isRange
  } = props;
  let {
    id
  } = props, propsWithoutId = _objectWithoutProperties25(props, _excluded38);
  const allOtherProps = svgPropertiesNoEvents(propsWithoutId);
  return React46.createElement(React46.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && React46.createElement(Layer, {
    clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
  }, React46.createElement(Curve, _extends34({}, allOtherProps, {
    id,
    points,
    connectNulls,
    type,
    baseLine,
    layout,
    stroke: "none",
    className: "recharts-area-area"
  })), stroke !== "none" && React46.createElement(Curve, _extends34({}, allOtherProps, {
    className: "recharts-area-curve",
    layout,
    type,
    connectNulls,
    fill: "none",
    points
  })), stroke !== "none" && isRange && React46.createElement(Curve, _extends34({}, allOtherProps, {
    className: "recharts-area-curve",
    layout,
    type,
    connectNulls,
    fill: "none",
    points: baseLine
  }))), React46.createElement(Dots3, {
    points,
    props: propsWithoutId,
    clipPathId
  }));
}
function VerticalRect(_ref4) {
  const {
    alpha: alpha2,
    baseLine,
    points,
    strokeWidth
  } = _ref4;
  const startY = points[0].y;
  const endY = points[points.length - 1].y;
  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {
    return null;
  }
  const height = alpha2 * Math.abs(startY - endY);
  let maxX = Math.max(...points.map((entry) => entry.x || 0));
  if (isNumber(baseLine)) {
    maxX = Math.max(baseLine, maxX);
  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
    maxX = Math.max(...baseLine.map((entry) => entry.x || 0), maxX);
  }
  if (isNumber(maxX)) {
    return React46.createElement("rect", {
      x: 0,
      y: startY < endY ? startY : startY - height,
      width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
      height: Math.floor(height)
    });
  }
  return null;
}
function HorizontalRect(_ref5) {
  const {
    alpha: alpha2,
    baseLine,
    points,
    strokeWidth
  } = _ref5;
  const startX = points[0].x;
  const endX = points[points.length - 1].x;
  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {
    return null;
  }
  const width = alpha2 * Math.abs(startX - endX);
  let maxY = Math.max(...points.map((entry) => entry.y || 0));
  if (isNumber(baseLine)) {
    maxY = Math.max(baseLine, maxY);
  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {
    maxY = Math.max(...baseLine.map((entry) => entry.y || 0), maxY);
  }
  if (isNumber(maxY)) {
    return React46.createElement("rect", {
      x: startX < endX ? startX : startX - width,
      y: 0,
      width,
      height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
    });
  }
  return null;
}
function ClipRect(_ref6) {
  const {
    alpha: alpha2,
    layout,
    points,
    baseLine,
    strokeWidth
  } = _ref6;
  if (layout === "vertical") {
    return React46.createElement(VerticalRect, {
      alpha: alpha2,
      points,
      baseLine,
      strokeWidth
    });
  }
  return React46.createElement(HorizontalRect, {
    alpha: alpha2,
    points,
    baseLine,
    strokeWidth
  });
}
function AreaWithAnimation(_ref7) {
  const {
    needClip,
    clipPathId,
    props,
    previousPointsRef,
    previousBaselineRef
  } = _ref7;
  const {
    points,
    baseLine,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationStart,
    onAnimationEnd
  } = props;
  const animationId = useAnimationId(props, "recharts-area-");
  const [isAnimating, setIsAnimating] = (0, import_react50.useState)(false);
  const showLabels = !isAnimating;
  const handleAnimationEnd = (0, import_react50.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react50.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  const prevPoints = previousPointsRef.current;
  const prevBaseLine = previousBaselineRef.current;
  return React46.createElement(AreaLabelListProvider, {
    showLabels,
    points
  }, props.children, React46.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t) => {
    if (prevPoints) {
      const prevPointsDiffFactor = prevPoints.length / points.length;
      const stepPoints = (
        /*
         * Here it is important that at the very end of the animation, on the last frame,
         * we render the original points without any interpolation.
         * This is needed because the code above is checking for reference equality to decide if the animation should run
         * and if we create a new array instance (even if the numbers were the same)
         * then we would break animations.
         */
        t === 1 ? points : points.map((entry, index2) => {
          const prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
          if (prevPoints[prevPointIndex]) {
            const prev = prevPoints[prevPointIndex];
            return _objectSpread52(_objectSpread52({}, entry), {}, {
              x: interpolate(prev.x, entry.x, t),
              y: interpolate(prev.y, entry.y, t)
            });
          }
          return entry;
        })
      );
      let stepBaseLine;
      if (isNumber(baseLine)) {
        stepBaseLine = interpolate(prevBaseLine, baseLine, t);
      } else if (isNullish(baseLine) || isNan(baseLine)) {
        stepBaseLine = interpolate(prevBaseLine, 0, t);
      } else {
        stepBaseLine = baseLine.map((entry, index2) => {
          const prevPointIndex = Math.floor(index2 * prevPointsDiffFactor);
          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {
            const prev = prevBaseLine[prevPointIndex];
            return _objectSpread52(_objectSpread52({}, entry), {}, {
              x: interpolate(prev.x, entry.x, t),
              y: interpolate(prev.y, entry.y, t)
            });
          }
          return entry;
        });
      }
      if (t > 0) {
        previousPointsRef.current = stepPoints;
        previousBaselineRef.current = stepBaseLine;
      }
      return React46.createElement(StaticArea, {
        points: stepPoints,
        baseLine: stepBaseLine,
        needClip,
        clipPathId,
        props
      });
    }
    if (t > 0) {
      previousPointsRef.current = points;
      previousBaselineRef.current = baseLine;
    }
    return React46.createElement(Layer, null, isAnimationActive && React46.createElement("defs", null, React46.createElement("clipPath", {
      id: "animationClipPath-".concat(clipPathId)
    }, React46.createElement(ClipRect, {
      alpha: t,
      points,
      baseLine,
      layout: props.layout,
      strokeWidth: props.strokeWidth
    }))), React46.createElement(Layer, {
      clipPath: "url(#animationClipPath-".concat(clipPathId, ")")
    }, React46.createElement(StaticArea, {
      points,
      baseLine,
      needClip,
      clipPathId,
      props
    })));
  }), React46.createElement(LabelListFromLabelProp, {
    label: props.label
  }));
}
function RenderArea(_ref8) {
  const {
    needClip,
    clipPathId,
    props
  } = _ref8;
  const previousPointsRef = (0, import_react50.useRef)(null);
  const previousBaselineRef = (0, import_react50.useRef)();
  return React46.createElement(AreaWithAnimation, {
    needClip,
    clipPathId,
    props,
    previousPointsRef,
    previousBaselineRef
  });
}
const AreaWithState = class extends import_react50.PureComponent {
  render() {
    let _filterProps;
    const {
      hide,
      dot,
      points,
      className,
      top,
      left,
      needClip,
      xAxisId,
      yAxisId,
      width,
      height,
      id,
      baseLine
    } = this.props;
    if (hide) {
      return null;
    }
    const layerClass = clsx("recharts-area", className);
    const clipPathId = id;
    const {
      r = 3,
      strokeWidth = 2
    } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {
      r: 3,
      strokeWidth: 2
    };
    const clipDot = isClipDot(dot);
    const dotSize = r * 2 + strokeWidth;
    return React46.createElement(React46.Fragment, null, React46.createElement(Layer, {
      className: layerClass
    }, needClip && React46.createElement("defs", null, React46.createElement(GraphicalItemClipPath, {
      clipPathId,
      xAxisId,
      yAxisId
    }), !clipDot && React46.createElement("clipPath", {
      id: "clipPath-dots-".concat(clipPathId)
    }, React46.createElement("rect", {
      x: left - dotSize / 2,
      y: top - dotSize / 2,
      width: width + dotSize,
      height: height + dotSize
    }))), React46.createElement(RenderArea, {
      needClip,
      clipPathId,
      props: this.props
    })), React46.createElement(ActivePoints, {
      points,
      mainColor: getLegendItemColor2(this.props.stroke, this.props.fill),
      itemDataKey: this.props.dataKey,
      activeDot: this.props.activeDot
    }), this.props.isRange && Array.isArray(baseLine) && React46.createElement(ActivePoints, {
      points: baseLine,
      mainColor: getLegendItemColor2(this.props.stroke, this.props.fill),
      itemDataKey: this.props.dataKey,
      activeDot: this.props.activeDot
    }));
  }
};
const defaultAreaProps = {
  activeDot: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  connectNulls: false,
  dot: false,
  fill: "#3182bd",
  fillOpacity: 0.6,
  hide: false,
  isAnimationActive: !Global.isSsr,
  legendType: "line",
  stroke: "#3182bd",
  xAxisId: 0,
  yAxisId: 0
};
function AreaImpl(props) {
  let _useAppSelector;
  const _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps), {
    activeDot,
    animationBegin,
    animationDuration,
    animationEasing,
    connectNulls,
    dot,
    fill: fill2,
    fillOpacity,
    hide,
    isAnimationActive,
    legendType,
    stroke,
    xAxisId,
    yAxisId
  } = _resolveDefaultProps, everythingElse = _objectWithoutProperties25(_resolveDefaultProps, _excluded212);
  const layout = useChartLayout();
  const chartName = useChartName();
  const {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  const isPanorama = useIsPanorama();
  const {
    points,
    isRange,
    baseLine
  } = (_useAppSelector = useAppSelector((state) => selectArea(state, xAxisId, yAxisId, isPanorama, props.id))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};
  const plotArea = usePlotArea();
  if (layout !== "horizontal" && layout !== "vertical" || plotArea == null) {
    return null;
  }
  if (chartName !== "AreaChart" && chartName !== "ComposedChart") {
    return null;
  }
  const {
    height,
    width,
    x: left,
    y: top
  } = plotArea;
  if (!points || !points.length) {
    return null;
  }
  return React46.createElement(AreaWithState, _extends34({}, everythingElse, {
    activeDot,
    animationBegin,
    animationDuration,
    animationEasing,
    baseLine,
    connectNulls,
    dot,
    fill: fill2,
    fillOpacity,
    height,
    hide,
    layout,
    isAnimationActive,
    isRange,
    legendType,
    needClip,
    points,
    stroke,
    width,
    left,
    top,
    xAxisId,
    yAxisId
  }));
}
const getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {
  const baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
  if (isNumber(baseValue)) {
    return baseValue;
  }
  const numericAxis = layout === "horizontal" ? yAxis : xAxis;
  const domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    const domainMax = Math.max(domain[0], domain[1]);
    const domainMin = Math.min(domain[0], domain[1]);
    if (baseValue === "dataMin") {
      return domainMin;
    }
    if (baseValue === "dataMax") {
      return domainMax;
    }
    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);
  }
  if (baseValue === "dataMin") {
    return domain[0];
  }
  if (baseValue === "dataMax") {
    return domain[1];
  }
  return domain[0];
};
function computeArea(_ref9) {
  const {
    areaSettings: {
      connectNulls,
      baseValue: itemBaseValue,
      dataKey
    },
    stackedData,
    layout,
    chartBaseValue,
    xAxis,
    yAxis,
    displayedData,
    dataStartIndex,
    xAxisTicks,
    yAxisTicks,
    bandSize
  } = _ref9;
  const hasStack = stackedData && stackedData.length;
  const baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);
  const isHorizontalLayout = layout === "horizontal";
  let isRange = false;
  const points = displayedData.map((entry, index2) => {
    let value;
    if (hasStack) {
      value = stackedData[dataStartIndex + index2];
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!Array.isArray(value)) {
        value = [baseValue, value];
      } else {
        isRange = true;
      }
    }
    const isBreakPoint = value[1] == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;
    if (isHorizontalLayout) {
      return {
        x: getCateCoordinateOfLine({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          entry,
          index: index2
        }),
        y: isBreakPoint ? null : yAxis.scale(value[1]),
        value,
        payload: entry
      };
    }
    return {
      x: isBreakPoint ? null : xAxis.scale(value[1]),
      y: getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        entry,
        index: index2
      }),
      value,
      payload: entry
    };
  });
  let baseLine;
  if (hasStack || isRange) {
    baseLine = points.map((entry) => {
      const x2 = Array.isArray(entry.value) ? entry.value[0] : null;
      if (isHorizontalLayout) {
        return {
          x: entry.x,
          y: x2 != null && entry.y != null ? yAxis.scale(x2) : null,
          payload: entry.payload
        };
      }
      return {
        x: x2 != null ? xAxis.scale(x2) : null,
        y: entry.y,
        payload: entry.payload
      };
    });
  } else {
    baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);
  }
  return {
    points,
    baseLine,
    isRange
  };
}
function AreaFn(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultAreaProps);
  const isPanorama = useIsPanorama();
  return React46.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "area"
  }, (id) => React46.createElement(React46.Fragment, null, React46.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromAreaData2(props)
  }), React46.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings6,
    args: props
  }), React46.createElement(SetCartesianGraphicalItem, {
    type: "area",
    id,
    data: props.data,
    dataKey: props.dataKey,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: 0,
    stackId: getNormalizedStackId(props.stackId),
    hide: props.hide,
    barSize: void 0,
    baseValue: props.baseValue,
    isPanorama,
    connectNulls: props.connectNulls
  }), React46.createElement(AreaImpl, _extends34({}, props, {
    id
  }))));
}
const Area = React46.memo(AreaFn);
Area.displayName = "Area";

// node_modules/recharts/es6/cartesian/Scatter.js
const React49 = __toESM(require_react());
const import_react52 = __toESM(require_react());

// node_modules/recharts/es6/cartesian/ZAxis.js
const React47 = __toESM(require_react());
const import_react51 = __toESM(require_react());
function _defineProperty54(e, r, t) {
  return (r = _toPropertyKey54(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey54(t) {
  const i = _toPrimitive54(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive54(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function SetZAxisSettings(settings) {
  const dispatch = useAppDispatch();
  (0, import_react51.useEffect)(() => {
    dispatch(addZAxis(settings));
    return () => {
      dispatch(removeZAxis(settings));
    };
  }, [settings, dispatch]);
  return null;
}
const ZAxis = class extends import_react51.Component {
  render() {
    return React47.createElement(SetZAxisSettings, {
      domain: this.props.domain,
      id: this.props.zAxisId,
      dataKey: this.props.dataKey,
      name: this.props.name,
      unit: this.props.unit,
      range: this.props.range,
      scale: this.props.scale,
      type: this.props.type,
      allowDuplicatedCategory: implicitZAxis.allowDuplicatedCategory,
      allowDataOverflow: implicitZAxis.allowDataOverflow,
      reversed: implicitZAxis.reversed,
      includeHidden: implicitZAxis.includeHidden
    });
  }
};
_defineProperty54(ZAxis, "displayName", "ZAxis");
_defineProperty54(ZAxis, "defaultProps", {
  zAxisId: 0,
  range: implicitZAxis.range,
  scale: implicitZAxis.scale,
  type: implicitZAxis.type
});

// node_modules/recharts/es6/util/ScatterUtils.js
const React48 = __toESM(require_react());
const _excluded39 = ["option", "isActive"];
function _extends35() {
  return _extends35 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends35.apply(null, arguments);
}
function _objectWithoutProperties26(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose26(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose26(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ScatterSymbol(_ref2) {
  let {
    option,
    isActive
  } = _ref2, props = _objectWithoutProperties26(_ref2, _excluded39);
  if (typeof option === "string") {
    return React48.createElement(Shape, _extends35({
      option: React48.createElement(Symbols, _extends35({
        type: option
      }, props)),
      isActive,
      shapeType: "symbols"
    }, props));
  }
  return React48.createElement(Shape, _extends35({
    option,
    isActive,
    shapeType: "symbols"
  }, props));
}

// node_modules/recharts/es6/state/selectors/scatterSelectors.js
const selectXAxisWithScale4 = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
const selectXAxisTicks4 = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
const selectYAxisWithScale4 = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
const selectYAxisTicks4 = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
const selectZAxis = (state, _xAxisId, _yAxisId, zAxisId) => selectZAxisWithScale(state, "zAxis", zAxisId, false);
const pickScatterId = (_state, _xAxisId, _yAxisId, _zAxisId, id) => id;
const pickCells4 = (_state, _xAxisId, _yAxisId, _zAxisId, _id, cells) => cells;
const scatterChartDataSelector = (state, xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectChartDataWithIndexesIfNotInPanorama(state, xAxisId, yAxisId, isPanorama);
const selectSynchronisedScatterSettings = createSelector([selectUnfilteredCartesianItems, pickScatterId], (graphicalItems, id) => {
  return graphicalItems.filter((item) => item.type === "scatter").find((item) => item.id === id);
});
const selectScatterPoints = createSelector([scatterChartDataSelector, selectXAxisWithScale4, selectXAxisTicks4, selectYAxisWithScale4, selectYAxisTicks4, selectZAxis, selectSynchronisedScatterSettings, pickCells4], (_ref2, xAxis, xAxisTicks, yAxis, yAxisTicks, zAxis, scatterSettings, cells) => {
  const {
    chartData,
    dataStartIndex,
    dataEndIndex
  } = _ref2;
  if (scatterSettings == null) {
    return void 0;
  }
  let displayedData;
  if ((scatterSettings === null || scatterSettings === void 0 ? void 0 : scatterSettings.data) != null && scatterSettings.data.length > 0) {
    displayedData = scatterSettings.data;
  } else {
    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
  }
  if (displayedData == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || (xAxisTicks === null || xAxisTicks === void 0 ? void 0 : xAxisTicks.length) === 0 || (yAxisTicks === null || yAxisTicks === void 0 ? void 0 : yAxisTicks.length) === 0) {
    return void 0;
  }
  return computeScatterPoints({
    displayedData,
    xAxis,
    yAxis,
    zAxis,
    scatterSettings,
    xAxisTicks,
    yAxisTicks,
    cells
  });
});

// node_modules/recharts/es6/cartesian/Scatter.js
const _excluded40 = ["onMouseEnter", "onClick", "onMouseLeave"];
const _excluded213 = ["id"];
const _excluded310 = ["animationBegin", "animationDuration", "animationEasing", "hide", "isAnimationActive", "legendType", "lineJointType", "lineType", "shape", "xAxisId", "yAxisId", "zAxisId"];
function _objectWithoutProperties27(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose27(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose27(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends36() {
  return _extends36 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends36.apply(null, arguments);
}
function ownKeys53(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread53(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys53(Object(t), true).forEach(function(r2) {
      _defineProperty55(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys53(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty55(e, r, t) {
  return (r = _toPropertyKey55(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey55(t) {
  const i = _toPrimitive55(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive55(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const computeLegendPayloadFromScatterProps = (props) => {
  const {
    dataKey,
    name,
    fill: fill2,
    legendType,
    hide
  } = props;
  return [{
    inactive: hide,
    dataKey,
    type: legendType,
    color: fill2,
    value: getTooltipNameProp(name, dataKey),
    payload: props
  }];
};
function ScatterLine(_ref2) {
  const {
    points,
    props
  } = _ref2;
  const {
    line,
    lineType,
    lineJointType
  } = props;
  if (!line) {
    return null;
  }
  const scatterProps = svgPropertiesNoEvents(props);
  const customLineProps = filterProps(line, false);
  let linePoints, lineItem;
  if (lineType === "joint") {
    linePoints = points.map((entry) => ({
      x: entry.cx,
      y: entry.cy
    }));
  } else if (lineType === "fitting") {
    const {
      xmin,
      xmax,
      a: a2,
      b
    } = getLinearRegression(points);
    const linearExp = (x2) => a2 * x2 + b;
    linePoints = [{
      x: xmin,
      y: linearExp(xmin)
    }, {
      x: xmax,
      y: linearExp(xmax)
    }];
  }
  const lineProps = _objectSpread53(_objectSpread53(_objectSpread53({}, scatterProps), {}, {
    fill: "none",
    stroke: scatterProps && scatterProps.fill
  }, customLineProps), {}, {
    points: linePoints
  });
  if (React49.isValidElement(line)) {
    lineItem = React49.cloneElement(line, lineProps);
  } else if (typeof line === "function") {
    lineItem = line(lineProps);
  } else {
    lineItem = React49.createElement(Curve, _extends36({}, lineProps, {
      type: lineJointType
    }));
  }
  return React49.createElement(Layer, {
    className: "recharts-scatter-line",
    key: "recharts-scatter-line"
  }, lineItem);
}
function ScatterLabelListProvider(_ref2) {
  const {
    showLabels,
    points,
    children
  } = _ref2;
  const chartViewBox = useViewBox();
  const labelListEntries = (0, import_react52.useMemo)(() => {
    return points === null || points === void 0 ? void 0 : points.map((point6) => {
      const viewBox = {
        /*
         * Scatter label uses x and y as the reference point for the label,
         * not cx and cy.
         */
        x: point6.x,
        /*
         * Scatter label uses x and y as the reference point for the label,
         * not cx and cy.
         */
        y: point6.y,
        width: point6.width,
        height: point6.height
      };
      return _objectSpread53(_objectSpread53({}, viewBox), {}, {
        /*
         * Here we put undefined because Scatter shows two values usually, one for X and one for Y.
         * LabelList will see this undefined and will use its own `dataKey` prop to determine which value to show,
         * using the payload below.
         */
        value: void 0,
        payload: point6.payload,
        viewBox,
        parentViewBox: chartViewBox,
        fill: void 0
      });
    });
  }, [chartViewBox, points]);
  return React49.createElement(CartesianLabelListContextProvider, {
    value: showLabels ? labelListEntries : null
  }, children);
}
function ScatterSymbols(props) {
  const {
    points,
    allOtherScatterProps
  } = props;
  const {
    shape,
    activeShape,
    dataKey
  } = allOtherScatterProps;
  const activeIndex = useAppSelector(selectActiveTooltipIndex);
  let {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = allOtherScatterProps, restOfAllOtherProps = _objectWithoutProperties27(allOtherScatterProps, _excluded40);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherScatterProps.dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherScatterProps.dataKey);
  if (points == null) {
    return null;
  }
  let {
    id
  } = allOtherScatterProps, allOtherPropsWithoutId = _objectWithoutProperties27(allOtherScatterProps, _excluded213);
  const baseProps = svgPropertiesNoEvents(allOtherPropsWithoutId);
  return React49.createElement(React49.Fragment, null, React49.createElement(ScatterLine, {
    points,
    props: allOtherPropsWithoutId
  }), points.map((entry, i) => {
    const isActive = activeShape && activeIndex === String(i);
    const option = isActive ? activeShape : shape;
    const symbolProps = _objectSpread53(_objectSpread53(_objectSpread53({
      key: "symbol-".concat(i)
    }, baseProps), entry), {}, {
      [DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
      [DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: String(dataKey)
    });
    return React49.createElement(Layer, _extends36({
      className: "recharts-scatter-symbol"
    }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: onMouseEnterFromContext(entry, i),
      onMouseLeave: onMouseLeaveFromContext(entry, i),
      onClick: onClickFromContext(entry, i),
      key: "symbol-".concat(entry === null || entry === void 0 ? void 0 : entry.cx, "-").concat(entry === null || entry === void 0 ? void 0 : entry.cy, "-").concat(entry === null || entry === void 0 ? void 0 : entry.size, "-").concat(i)
    }), React49.createElement(ScatterSymbol, _extends36({
      option,
      isActive
    }, symbolProps)));
  }));
}
function SymbolsWithAnimation(_ref3) {
  const {
    previousPointsRef,
    props
  } = _ref3;
  const {
    points,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing
  } = props;
  const prevPoints = previousPointsRef.current;
  const animationId = useAnimationId(props, "recharts-scatter-");
  const [isAnimating, setIsAnimating] = (0, import_react52.useState)(false);
  const handleAnimationEnd = (0, import_react52.useCallback)(() => {
    setIsAnimating(false);
  }, []);
  const handleAnimationStart = (0, import_react52.useCallback)(() => {
    setIsAnimating(true);
  }, []);
  const showLabels = !isAnimating;
  return React49.createElement(ScatterLabelListProvider, {
    showLabels,
    points
  }, props.children, React49.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    onAnimationEnd: handleAnimationEnd,
    onAnimationStart: handleAnimationStart,
    key: animationId
  }, (t) => {
    const stepData = t === 1 ? points : points === null || points === void 0 ? void 0 : points.map((entry, index2) => {
      const prev = prevPoints && prevPoints[index2];
      if (prev) {
        const interpolatorCx = interpolateNumber(prev.cx, entry.cx);
        const interpolatorCy = interpolateNumber(prev.cy, entry.cy);
        const interpolatorSize = interpolateNumber(prev.size, entry.size);
        return _objectSpread53(_objectSpread53({}, entry), {}, {
          cx: interpolatorCx(t),
          cy: interpolatorCy(t),
          size: interpolatorSize(t)
        });
      }
      const interpolator = interpolateNumber(0, entry.size);
      return _objectSpread53(_objectSpread53({}, entry), {}, {
        size: interpolator(t)
      });
    });
    if (t > 0) {
      previousPointsRef.current = stepData;
    }
    return React49.createElement(Layer, null, React49.createElement(ScatterSymbols, {
      points: stepData,
      allOtherScatterProps: props,
      showLabels
    }));
  }), React49.createElement(LabelListFromLabelProp, {
    label: props.label
  }));
}
function getTooltipEntrySettings7(props) {
  const {
    dataKey,
    points,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    tooltipType
  } = props;
  return {
    dataDefinedOnItem: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPayload),
    positions: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPosition),
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      nameKey: void 0,
      dataKey,
      name: getTooltipNameProp(name, dataKey),
      hide,
      type: tooltipType,
      color: fill2,
      unit: ""
      // why doesn't Scatter support unit?
    }
  };
}
function computeScatterPoints(_ref4) {
  const {
    displayedData,
    xAxis,
    yAxis,
    zAxis,
    scatterSettings,
    xAxisTicks,
    yAxisTicks,
    cells
  } = _ref4;
  const xAxisDataKey = isNullish(xAxis.dataKey) ? scatterSettings.dataKey : xAxis.dataKey;
  const yAxisDataKey = isNullish(yAxis.dataKey) ? scatterSettings.dataKey : yAxis.dataKey;
  const zAxisDataKey = zAxis && zAxis.dataKey;
  const defaultRangeZ = zAxis ? zAxis.range : ZAxis.defaultProps.range;
  const defaultZ = defaultRangeZ && defaultRangeZ[0];
  const xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;
  const yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;
  return displayedData.map((entry, index2) => {
    const x2 = getValueByDataKey(entry, xAxisDataKey);
    const y2 = getValueByDataKey(entry, yAxisDataKey);
    const z = !isNullish(zAxisDataKey) && getValueByDataKey(entry, zAxisDataKey) || "-";
    const tooltipPayload = [{
      // @ts-expect-error name prop should not have dataKey in it
      name: isNullish(xAxis.dataKey) ? scatterSettings.name : xAxis.name || xAxis.dataKey,
      unit: xAxis.unit || "",
      // @ts-expect-error getValueByDataKey does not validate the output type
      value: x2,
      payload: entry,
      dataKey: xAxisDataKey,
      type: scatterSettings.tooltipType
    }, {
      // @ts-expect-error name prop should not have dataKey in it
      name: isNullish(yAxis.dataKey) ? scatterSettings.name : yAxis.name || yAxis.dataKey,
      unit: yAxis.unit || "",
      // @ts-expect-error getValueByDataKey does not validate the output type
      value: y2,
      payload: entry,
      dataKey: yAxisDataKey,
      type: scatterSettings.tooltipType
    }];
    if (z !== "-") {
      tooltipPayload.push({
        // @ts-expect-error name prop should not have dataKey in it
        name: zAxis.name || zAxis.dataKey,
        unit: zAxis.unit || "",
        // @ts-expect-error getValueByDataKey does not validate the output type
        value: z,
        payload: entry,
        dataKey: zAxisDataKey,
        type: scatterSettings.tooltipType
      });
    }
    const cx = getCateCoordinateOfLine({
      axis: xAxis,
      ticks: xAxisTicks,
      bandSize: xBandSize,
      entry,
      index: index2,
      dataKey: xAxisDataKey
    });
    const cy = getCateCoordinateOfLine({
      axis: yAxis,
      ticks: yAxisTicks,
      bandSize: yBandSize,
      entry,
      index: index2,
      dataKey: yAxisDataKey
    });
    const size = z !== "-" ? zAxis.scale(z) : defaultZ;
    const radius = Math.sqrt(Math.max(size, 0) / Math.PI);
    return _objectSpread53(_objectSpread53({}, entry), {}, {
      cx,
      cy,
      x: cx - radius,
      y: cy - radius,
      width: 2 * radius,
      height: 2 * radius,
      size,
      node: {
        x: x2,
        y: y2,
        z
      },
      tooltipPayload,
      tooltipPosition: {
        x: cx,
        y: cy
      },
      payload: entry
    }, cells && cells[index2] && cells[index2].props);
  });
}
const errorBarDataPointFormatter3 = (dataPoint, dataKey, direction) => {
  return {
    x: dataPoint.cx,
    y: dataPoint.cy,
    value: direction === "x" ? +dataPoint.node.x : +dataPoint.node.y,
    // @ts-expect-error getValueByDataKey does not validate the output type
    errorVal: getValueByDataKey(dataPoint, dataKey)
  };
};
function ScatterWithId(props) {
  const {
    hide,
    points,
    className,
    needClip,
    xAxisId,
    yAxisId,
    id
  } = props;
  const previousPointsRef = (0, import_react52.useRef)(null);
  if (hide) {
    return null;
  }
  const layerClass = clsx("recharts-scatter", className);
  const clipPathId = id;
  return React49.createElement(Layer, {
    className: layerClass,
    clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
    id
  }, needClip && React49.createElement("defs", null, React49.createElement(GraphicalItemClipPath, {
    clipPathId,
    xAxisId,
    yAxisId
  })), React49.createElement(SetErrorBarContext, {
    xAxisId,
    yAxisId,
    data: points,
    dataPointFormatter: errorBarDataPointFormatter3,
    errorBarOffset: 0
  }, React49.createElement(Layer, {
    key: "recharts-scatter-symbols"
  }, React49.createElement(SymbolsWithAnimation, {
    props,
    previousPointsRef
  }))));
}
const defaultScatterProps = {
  xAxisId: 0,
  yAxisId: 0,
  zAxisId: 0,
  legendType: "circle",
  lineType: "joint",
  lineJointType: "linear",
  data: [],
  shape: "circle",
  hide: false,
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "linear"
};
function ScatterImpl(props) {
  const _resolveDefaultProps = resolveDefaultProps(props, defaultScatterProps), {
    animationBegin,
    animationDuration,
    animationEasing,
    hide,
    isAnimationActive,
    legendType,
    lineJointType,
    lineType,
    shape,
    xAxisId,
    yAxisId,
    zAxisId
  } = _resolveDefaultProps, everythingElse = _objectWithoutProperties27(_resolveDefaultProps, _excluded310);
  const {
    needClip
  } = useNeedsClip(xAxisId, yAxisId);
  const cells = (0, import_react52.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
  const isPanorama = useIsPanorama();
  const points = useAppSelector((state) => {
    return selectScatterPoints(state, xAxisId, yAxisId, zAxisId, props.id, cells, isPanorama);
  });
  if (needClip == null) {
    return null;
  }
  if (points == null) {
    return null;
  }
  return React49.createElement(React49.Fragment, null, React49.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings7,
    args: _objectSpread53(_objectSpread53({}, props), {}, {
      points
    })
  }), React49.createElement(ScatterWithId, _extends36({}, everythingElse, {
    xAxisId,
    yAxisId,
    zAxisId,
    lineType,
    lineJointType,
    legendType,
    shape,
    hide,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    points,
    needClip
  })));
}
function ScatterFn(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultScatterProps);
  const isPanorama = useIsPanorama();
  return React49.createElement(RegisterGraphicalItemId, {
    id: props.id,
    type: "scatter"
  }, (id) => React49.createElement(React49.Fragment, null, React49.createElement(SetLegendPayload, {
    legendPayload: computeLegendPayloadFromScatterProps(props)
  }), React49.createElement(SetCartesianGraphicalItem, {
    type: "scatter",
    id,
    data: props.data,
    xAxisId: props.xAxisId,
    yAxisId: props.yAxisId,
    zAxisId: props.zAxisId,
    dataKey: props.dataKey,
    hide: props.hide,
    name: props.name,
    tooltipType: props.tooltipType,
    isPanorama
  }), React49.createElement(ScatterImpl, _extends36({}, props, {
    id
  }))));
}
const Scatter = React49.memo(ScatterFn);
Scatter.displayName = "Scatter";

// node_modules/recharts/es6/cartesian/XAxis.js
const React50 = __toESM(require_react());
const import_react53 = __toESM(require_react());
const _excluded41 = ["dangerouslySetInnerHTML", "ticks"];
const _excluded214 = ["id"];
const _excluded311 = ["domain"];
const _excluded44 = ["domain"];
function _extends37() {
  return _extends37 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends37.apply(null, arguments);
}
function _objectWithoutProperties28(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose28(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose28(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function SetXAxisSettings(settings) {
  const dispatch = useAppDispatch();
  (0, import_react53.useEffect)(() => {
    dispatch(addXAxis(settings));
    return () => {
      dispatch(removeXAxis(settings));
    };
  }, [settings, dispatch]);
  return null;
}
const XAxisImpl = (props) => {
  const {
    xAxisId,
    className
  } = props;
  const viewBox = useAppSelector(selectAxisViewBox);
  const isPanorama = useIsPanorama();
  const axisType = "xAxis";
  const scale = useAppSelector((state) => selectAxisScale(state, axisType, xAxisId, isPanorama));
  const cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, xAxisId, isPanorama));
  const axisSize = useAppSelector((state) => selectXAxisSize(state, xAxisId));
  const position2 = useAppSelector((state) => selectXAxisPosition(state, xAxisId));
  const synchronizedSettings = useAppSelector((state) => selectXAxisSettingsNoDefaults(state, xAxisId));
  if (axisSize == null || position2 == null || synchronizedSettings == null) {
    return null;
  }
  let {
    dangerouslySetInnerHTML,
    ticks: ticks2
  } = props, allOtherProps = _objectWithoutProperties28(props, _excluded41);
  let {
    id
  } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties28(synchronizedSettings, _excluded214);
  return React50.createElement(CartesianAxis, _extends37({}, allOtherProps, restSynchronizedSettings, {
    scale,
    x: position2.x,
    y: position2.y,
    width: axisSize.width,
    height: axisSize.height,
    className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
    viewBox,
    ticks: cartesianTickItems
  }));
};
const xAxisDefaultProps = {
  allowDataOverflow: implicitXAxis.allowDataOverflow,
  allowDecimals: implicitXAxis.allowDecimals,
  allowDuplicatedCategory: implicitXAxis.allowDuplicatedCategory,
  height: implicitXAxis.height,
  hide: false,
  mirror: implicitXAxis.mirror,
  orientation: implicitXAxis.orientation,
  padding: implicitXAxis.padding,
  reversed: implicitXAxis.reversed,
  scale: implicitXAxis.scale,
  tickCount: implicitXAxis.tickCount,
  type: implicitXAxis.type,
  xAxisId: 0
};
const XAxisSettingsDispatcher = (outsideProps) => {
  let _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
  const props = resolveDefaultProps(outsideProps, xAxisDefaultProps);
  return React50.createElement(React50.Fragment, null, React50.createElement(SetXAxisSettings, {
    interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
    id: props.xAxisId,
    scale: props.scale,
    type: props.type,
    padding: props.padding,
    allowDataOverflow: props.allowDataOverflow,
    domain: props.domain,
    dataKey: props.dataKey,
    allowDuplicatedCategory: props.allowDuplicatedCategory,
    allowDecimals: props.allowDecimals,
    tickCount: props.tickCount,
    includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
    reversed: props.reversed,
    ticks: props.ticks,
    height: props.height,
    orientation: props.orientation,
    mirror: props.mirror,
    hide: props.hide,
    unit: props.unit,
    name: props.name,
    angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
    minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
    tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
    tickFormatter: props.tickFormatter
  }), React50.createElement(XAxisImpl, props));
};
const XAxisMemoComparator = (prevProps, nextProps) => {
  let {
    domain: prevDomain
  } = prevProps, prevRest = _objectWithoutProperties28(prevProps, _excluded311);
  let {
    domain: nextDomain
  } = nextProps, nextRest = _objectWithoutProperties28(nextProps, _excluded44);
  if (!shallowEqual(prevRest, nextRest)) {
    return false;
  }
  if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) {
    return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
  }
  return shallowEqual({
    domain: prevDomain
  }, {
    domain: nextDomain
  });
};
const XAxis = React50.memo(XAxisSettingsDispatcher, XAxisMemoComparator);
XAxis.displayName = "XAxis";

// node_modules/recharts/es6/cartesian/YAxis.js
const React51 = __toESM(require_react());
const import_react54 = __toESM(require_react());
const _excluded45 = ["dangerouslySetInnerHTML", "ticks"];
const _excluded215 = ["id"];
const _excluded312 = ["domain"];
const _excluded46 = ["domain"];
function _extends38() {
  return _extends38 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends38.apply(null, arguments);
}
function _objectWithoutProperties29(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose29(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose29(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function SetYAxisSettings(settings) {
  const dispatch = useAppDispatch();
  (0, import_react54.useEffect)(() => {
    dispatch(addYAxis(settings));
    return () => {
      dispatch(removeYAxis(settings));
    };
  }, [settings, dispatch]);
  return null;
}
const YAxisImpl = (props) => {
  const {
    yAxisId,
    className,
    width,
    label
  } = props;
  const cartesianAxisRef = (0, import_react54.useRef)(null);
  const labelRef = (0, import_react54.useRef)(null);
  const viewBox = useAppSelector(selectAxisViewBox);
  const isPanorama = useIsPanorama();
  const dispatch = useAppDispatch();
  const axisType = "yAxis";
  const scale = useAppSelector((state) => selectAxisScale(state, axisType, yAxisId, isPanorama));
  const axisSize = useAppSelector((state) => selectYAxisSize(state, yAxisId));
  const position2 = useAppSelector((state) => selectYAxisPosition(state, yAxisId));
  const cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, yAxisId, isPanorama));
  const synchronizedSettings = useAppSelector((state) => selectYAxisSettingsNoDefaults(state, yAxisId));
  (0, import_react54.useLayoutEffect)(() => {
    if (width !== "auto" || !axisSize || isLabelContentAFunction(label) || (0, import_react54.isValidElement)(label) || synchronizedSettings == null) {
      return;
    }
    const axisComponent = cartesianAxisRef.current;
    if (!axisComponent) {
      return;
    }
    const updatedYAxisWidth = axisComponent.getCalculatedWidth();
    if (Math.round(axisSize.width) !== Math.round(updatedYAxisWidth)) {
      dispatch(updateYAxisWidth({
        id: yAxisId,
        width: updatedYAxisWidth
      }));
    }
  }, [
    // The dependency on cartesianAxisRef.current is not needed because useLayoutEffect will run after every render.
    // The ref will be populated by then.
    // To re-run this effect when ticks change, we can depend on the ticks array from the store.
    cartesianTickItems,
    axisSize,
    dispatch,
    label,
    yAxisId,
    width,
    synchronizedSettings
  ]);
  if (axisSize == null || position2 == null || synchronizedSettings == null) {
    return null;
  }
  let {
    dangerouslySetInnerHTML,
    ticks: ticks2
  } = props, allOtherProps = _objectWithoutProperties29(props, _excluded45);
  let {
    id
  } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties29(synchronizedSettings, _excluded215);
  return React51.createElement(CartesianAxis, _extends38({}, allOtherProps, restSynchronizedSettings, {
    ref: cartesianAxisRef,
    labelRef,
    scale,
    x: position2.x,
    y: position2.y,
    tickTextProps: width === "auto" ? {
      width: void 0
    } : {
      width
    },
    width: axisSize.width,
    height: axisSize.height,
    className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
    viewBox,
    ticks: cartesianTickItems
  }));
};
const yAxisDefaultProps = {
  allowDataOverflow: implicitYAxis.allowDataOverflow,
  allowDecimals: implicitYAxis.allowDecimals,
  allowDuplicatedCategory: implicitYAxis.allowDuplicatedCategory,
  hide: false,
  mirror: implicitYAxis.mirror,
  orientation: implicitYAxis.orientation,
  padding: implicitYAxis.padding,
  reversed: implicitYAxis.reversed,
  scale: implicitYAxis.scale,
  tickCount: implicitYAxis.tickCount,
  type: implicitYAxis.type,
  width: implicitYAxis.width,
  yAxisId: 0
};
const YAxisSettingsDispatcher = (outsideProps) => {
  let _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
  const props = resolveDefaultProps(outsideProps, yAxisDefaultProps);
  return React51.createElement(React51.Fragment, null, React51.createElement(SetYAxisSettings, {
    interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
    id: props.yAxisId,
    scale: props.scale,
    type: props.type,
    domain: props.domain,
    allowDataOverflow: props.allowDataOverflow,
    dataKey: props.dataKey,
    allowDuplicatedCategory: props.allowDuplicatedCategory,
    allowDecimals: props.allowDecimals,
    tickCount: props.tickCount,
    padding: props.padding,
    includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
    reversed: props.reversed,
    ticks: props.ticks,
    width: props.width,
    orientation: props.orientation,
    mirror: props.mirror,
    hide: props.hide,
    unit: props.unit,
    name: props.name,
    angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
    minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
    tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
    tickFormatter: props.tickFormatter
  }), React51.createElement(YAxisImpl, props));
};
const YAxisMemoComparator = (prevProps, nextProps) => {
  let {
    domain: prevDomain
  } = prevProps, prevRest = _objectWithoutProperties29(prevProps, _excluded312);
  let {
    domain: nextDomain
  } = nextProps, nextRest = _objectWithoutProperties29(nextProps, _excluded46);
  if (!shallowEqual(prevRest, nextRest)) {
    return false;
  }
  if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) {
    return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
  }
  return shallowEqual({
    domain: prevDomain
  }, {
    domain: nextDomain
  });
};
const YAxis = React51.memo(YAxisSettingsDispatcher, YAxisMemoComparator);
YAxis.displayName = "YAxis";

// node_modules/recharts/es6/cartesian/ErrorBar.js
const React52 = __toESM(require_react());
const import_react56 = __toESM(require_react());

// node_modules/recharts/es6/animation/CSSTransitionAnimate.js
const import_react55 = __toESM(require_react());
const defaultProps5 = {
  begin: 0,
  duration: 1e3,
  easing: "ease",
  isActive: true,
  canBegin: true,
  onAnimationEnd: () => {
  },
  onAnimationStart: () => {
  }
};
function CSSTransitionAnimate(outsideProps) {
  const props = resolveDefaultProps(outsideProps, defaultProps5);
  const {
    animationId,
    from: from2,
    to: to2,
    attributeName,
    isActive,
    canBegin,
    duration,
    easing,
    begin,
    onAnimationEnd,
    onAnimationStart: onAnimationStartFromProps,
    children
  } = props;
  const animationManager = useAnimationManager(animationId + attributeName, props.animationManager);
  const [style, setStyle] = (0, import_react55.useState)(() => {
    if (!isActive) {
      return to2;
    }
    return from2;
  });
  const initialized = (0, import_react55.useRef)(false);
  const onAnimationStart = (0, import_react55.useCallback)(() => {
    setStyle(from2);
    onAnimationStartFromProps();
  }, [from2, onAnimationStartFromProps]);
  (0, import_react55.useEffect)(() => {
    if (!isActive || !canBegin) {
      return noop3;
    }
    initialized.current = true;
    const unsubscribe = animationManager.subscribe(setStyle);
    animationManager.start([onAnimationStart, begin, to2, duration, onAnimationEnd]);
    return () => {
      animationManager.stop();
      if (unsubscribe) {
        unsubscribe();
      }
      onAnimationEnd();
    };
  }, [isActive, canBegin, duration, easing, begin, onAnimationStart, onAnimationEnd, animationManager, to2, from2]);
  if (!isActive) {
    return children({
      [attributeName]: to2
    });
  }
  if (!canBegin) {
    return children({
      [attributeName]: from2
    });
  }
  if (initialized.current) {
    const transition = getTransitionVal([attributeName], duration, easing);
    return children({
      transition,
      [attributeName]: style
    });
  }
  return children({
    [attributeName]: from2
  });
}

// node_modules/recharts/es6/cartesian/ErrorBar.js
const _excluded47 = ["direction", "width", "dataKey", "isAnimationActive", "animationBegin", "animationDuration", "animationEasing"];
function _extends39() {
  return _extends39 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends39.apply(null, arguments);
}
function ownKeys54(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread54(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys54(Object(t), true).forEach(function(r2) {
      _defineProperty56(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys54(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty56(e, r, t) {
  return (r = _toPropertyKey56(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey56(t) {
  const i = _toPrimitive56(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive56(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties30(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose30(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose30(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ErrorBarImpl(props) {
  let {
    direction,
    width,
    dataKey,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing
  } = props, others = _objectWithoutProperties30(props, _excluded47);
  const svgProps = svgPropertiesNoEvents(others);
  const {
    data,
    dataPointFormatter,
    xAxisId,
    yAxisId,
    errorBarOffset: offset
  } = useErrorBarContext();
  const xAxis = useXAxis(xAxisId);
  const yAxis = useYAxis(yAxisId);
  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) == null || (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) == null || data == null) {
    return null;
  }
  if (direction === "x" && xAxis.type !== "number") {
    return null;
  }
  const errorBars = data.map((entry) => {
    const {
      x: x2,
      y: y2,
      value,
      errorVal
    } = dataPointFormatter(entry, dataKey, direction);
    if (!errorVal || x2 == null || y2 == null) {
      return null;
    }
    const lineCoordinates = [];
    let lowBound, highBound;
    if (Array.isArray(errorVal)) {
      [lowBound, highBound] = errorVal;
    } else {
      lowBound = highBound = errorVal;
    }
    if (direction === "x") {
      const {
        scale
      } = xAxis;
      const yMid = y2 + offset;
      const yMin = yMid + width;
      const yMax = yMid - width;
      const xMin = scale(value - lowBound);
      const xMax = scale(value + highBound);
      lineCoordinates.push({
        x1: xMax,
        y1: yMin,
        x2: xMax,
        y2: yMax
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMid,
        x2: xMax,
        y2: yMid
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMin,
        x2: xMin,
        y2: yMax
      });
    } else if (direction === "y") {
      const {
        scale: _scale
      } = yAxis;
      const xMid = x2 + offset;
      const _xMin = xMid - width;
      const _xMax = xMid + width;
      const _yMin = _scale(value - lowBound);
      const _yMax = _scale(value + highBound);
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMax,
        x2: _xMax,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: xMid,
        y1: _yMin,
        x2: xMid,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMin,
        x2: _xMax,
        y2: _yMin
      });
    }
    const scaleDirection = direction === "x" ? "scaleX" : "scaleY";
    const transformOrigin = "".concat(x2 + offset, "px ").concat(y2 + offset, "px");
    return React52.createElement(Layer, _extends39({
      className: "recharts-errorBar",
      key: "bar-".concat(lineCoordinates.map((c2) => "".concat(c2.x1, "-").concat(c2.x2, "-").concat(c2.y1, "-").concat(c2.y2)))
    }, svgProps), lineCoordinates.map((coordinates) => {
      const lineStyle = isAnimationActive ? {
        transformOrigin
      } : void 0;
      return React52.createElement(CSSTransitionAnimate, {
        animationId: "error-bar-".concat(direction),
        from: "".concat(scaleDirection, "(0)"),
        to: "".concat(scaleDirection, "(1)"),
        attributeName: "transform",
        begin: animationBegin,
        easing: animationEasing,
        isActive: isAnimationActive,
        duration: animationDuration,
        key: "errorbar-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2)
      }, (style) => React52.createElement("line", _extends39({}, coordinates, {
        style: _objectSpread54(_objectSpread54({}, lineStyle), style)
      })));
    }));
  });
  return React52.createElement(Layer, {
    className: "recharts-errorBars"
  }, errorBars);
}
function useErrorBarDirection(directionFromProps) {
  const layout = useChartLayout();
  if (directionFromProps != null) {
    return directionFromProps;
  }
  if (layout != null) {
    return layout === "horizontal" ? "y" : "x";
  }
  return "x";
}
const errorBarDefaultProps = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  isAnimationActive: true,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease-in-out"
};
function ErrorBarInternal(props) {
  const realDirection = useErrorBarDirection(props.direction);
  const {
    width,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing
  } = resolveDefaultProps(props, errorBarDefaultProps);
  return React52.createElement(React52.Fragment, null, React52.createElement(ReportErrorBarSettings, {
    dataKey: props.dataKey,
    direction: realDirection
  }), React52.createElement(ErrorBarImpl, _extends39({}, props, {
    direction: realDirection,
    width,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing
  })));
}
const ErrorBar = class extends import_react56.Component {
  render() {
    return React52.createElement(ErrorBarInternal, this.props);
  }
};
_defineProperty56(ErrorBar, "defaultProps", errorBarDefaultProps);
_defineProperty56(ErrorBar, "displayName", "ErrorBar");

// node_modules/recharts/es6/chart/LineChart.js
const React59 = __toESM(require_react());
const import_react65 = __toESM(require_react());

// node_modules/recharts/es6/chart/CartesianChart.js
const React58 = __toESM(require_react());
const import_react64 = __toESM(require_react());

// node_modules/recharts/es6/state/RechartsStoreProvider.js
const React54 = __toESM(require_react());
const import_react57 = __toESM(require_react());

// node_modules/react-redux/dist/react-redux.mjs
const React53 = __toESM(require_react(), 1);
const import_with_selector2 = __toESM(require_with_selector2(), 1);
const IS_REACT_19 = React53.version.startsWith("19");
const REACT_ELEMENT_TYPE = Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
const REACT_PORTAL_TYPE = Symbol.for("react.portal");
const REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
const REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
const REACT_PROFILER_TYPE = Symbol.for("react.profiler");
const REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
const REACT_CONTEXT_TYPE = Symbol.for("react.context");
const REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
const REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
const REACT_SUSPENSE_LIST_TYPE = Symbol.for(
  "react.suspense_list"
);
const REACT_MEMO_TYPE = Symbol.for("react.memo");
const REACT_LAZY_TYPE = Symbol.for("react.lazy");
const REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
const REACT_CLIENT_REFERENCE = Symbol.for(
  "react.client.reference"
);
const ForwardRef = REACT_FORWARD_REF_TYPE;
const Memo = REACT_MEMO_TYPE;
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last4 = null;
  return {
    clear() {
      first = null;
      last4 = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener2 = first;
        while (listener2) {
          listener2.callback();
          listener2 = listener2.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener2 = first;
      while (listener2) {
        listeners.push(listener2);
        listener2 = listener2.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener2 = last4 = {
        callback,
        next: null,
        prev: last4
      };
      if (listener2.prev) {
        listener2.prev.next = listener2;
      } else {
        first = listener2;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener2.next) {
          listener2.next.prev = listener2.prev;
        } else {
          last4 = listener2.prev;
        }
        if (listener2.prev) {
          listener2.prev.next = listener2.next;
        } else {
          first = listener2.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener2) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener2);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isDOM = canUseDOM();
const isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
const isReactNative = isRunningInReactNative();
const getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React53.useLayoutEffect : React53.useEffect;
const useIsomorphicLayoutEffect = getUseIsomorphicLayoutEffect();
const FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
const MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
const TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
const objectPrototype = Object.prototype;
const ContextKey = Symbol.for(`react-redux-context`);
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React53.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(React53.createContext);
  if (!realContext) {
    realContext = React53.createContext(
      null
    );
    if (true) {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React53.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = getContext();
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React53.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (false) {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store, serverState]);
  const previousState = React53.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return React53.createElement(Context.Provider, { value: contextValue }, children);
}
const Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = React53.useContext(context);
    if (!contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
const useReduxContext = createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
const useStore = createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
const useDispatch = createDispatchHook();
const refEquality2 = (a2, b) => a2 === b;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality2 } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (true) {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const reduxContext = useReduxContext2();
    const { store, subscription, getServerState } = reduxContext;
    const firstRun = React53.useRef(true);
    const wrappedSelector = React53.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          if (true) {
            const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
            const { identityFunctionCheck, stabilityCheck } = reduxContext;
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e) {
                  
                  ({ stack } = e);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e) {
                  
                  ({ stack } = e);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current) firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = (0, import_with_selector2.useSyncExternalStoreWithSelector)(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    React53.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
const useSelector = createSelectorHook();

// node_modules/recharts/es6/state/selectors/selectActivePropsFromChartPointer.js
const pickChartPointer = (_state, chartPointer) => chartPointer;
const selectActivePropsFromChartPointer = createSelector([pickChartPointer, selectChartLayout, selectPolarViewBox, selectTooltipAxisType, selectTooltipAxisRangeWithReverse, selectTooltipAxisTicks, selectOrderedTooltipTicks, selectChartOffsetInternal], combineActiveProps);

// node_modules/recharts/es6/util/getChartPointer.js
const getChartPointer = (event) => {
  const rect = event.currentTarget.getBoundingClientRect();
  const scaleX = rect.width / event.currentTarget.offsetWidth;
  const scaleY = rect.height / event.currentTarget.offsetHeight;
  return {
    /*
     * Here it's important to use:
     * - event.clientX and event.clientY to get the mouse position relative to the viewport, including scroll.
     * - pageX and pageY are not used because they are relative to the whole document, and ignore scroll.
     * - rect.left and rect.top are used to get the position of the chart relative to the viewport.
     * - offsetX and offsetY are not used because they are relative to the offset parent
     *  which may or may not be the same as the clientX and clientY, depending on the position of the chart in the DOM
     *  and surrounding element styles. CSS position: relative, absolute, fixed, will change the offset parent.
     * - scaleX and scaleY are necessary for when the chart element is scaled using CSS `transform: scale(N)`.
     */
    chartX: Math.round((event.clientX - rect.left) / scaleX),
    chartY: Math.round((event.clientY - rect.top) / scaleY)
  };
};

// node_modules/recharts/es6/state/mouseEventsMiddleware.js
const mouseClickAction = createAction("mouseClick");
const mouseClickMiddleware = createListenerMiddleware();
mouseClickMiddleware.startListening({
  actionCreator: mouseClickAction,
  effect: (action, listenerApi) => {
    const mousePointer = action.payload;
    const activeProps = selectActivePropsFromChartPointer(listenerApi.getState(), getChartPointer(mousePointer));
    if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
      listenerApi.dispatch(setMouseClickAxisIndex({
        activeIndex: activeProps.activeIndex,
        activeDataKey: void 0,
        activeCoordinate: activeProps.activeCoordinate
      }));
    }
  }
});
const mouseMoveAction = createAction("mouseMove");
const mouseMoveMiddleware = createListenerMiddleware();
mouseMoveMiddleware.startListening({
  actionCreator: mouseMoveAction,
  effect: (action, listenerApi) => {
    const mousePointer = action.payload;
    const state = listenerApi.getState();
    const tooltipEventType = selectTooltipEventType(state, state.tooltip.settings.shared);
    const activeProps = selectActivePropsFromChartPointer(state, getChartPointer(mousePointer));
    if (tooltipEventType === "axis") {
      if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
        listenerApi.dispatch(setMouseOverAxisIndex({
          activeIndex: activeProps.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: activeProps.activeCoordinate
        }));
      } else {
        listenerApi.dispatch(mouseLeaveChart());
      }
    }
  }
});

// node_modules/recharts/es6/state/reduxDevtoolsJsonStringifyReplacer.js
function reduxDevtoolsJsonStringifyReplacer(_key, value) {
  if (value instanceof HTMLElement) {
    return "HTMLElement <".concat(value.tagName, ' class="').concat(value.className, '">');
  }
  if (value === window) {
    return "global.window";
  }
  return value;
}

// node_modules/recharts/es6/state/rootPropsSlice.js
const initialState11 = {
  accessibilityLayer: true,
  barCategoryGap: "10%",
  barGap: 4,
  barSize: void 0,
  className: void 0,
  maxBarSize: void 0,
  stackOffset: "none",
  syncId: void 0,
  syncMethod: "index"
};
const rootPropsSlice = createSlice({
  name: "rootProps",
  initialState: initialState11,
  reducers: {
    updateOptions: (state, action) => {
      let _action$payload$barGa;
      state.accessibilityLayer = action.payload.accessibilityLayer;
      state.barCategoryGap = action.payload.barCategoryGap;
      state.barGap = (_action$payload$barGa = action.payload.barGap) !== null && _action$payload$barGa !== void 0 ? _action$payload$barGa : initialState11.barGap;
      state.barSize = action.payload.barSize;
      state.maxBarSize = action.payload.maxBarSize;
      state.stackOffset = action.payload.stackOffset;
      state.syncId = action.payload.syncId;
      state.syncMethod = action.payload.syncMethod;
      state.className = action.payload.className;
    }
  }
});
const rootPropsReducer = rootPropsSlice.reducer;
const {
  updateOptions
} = rootPropsSlice.actions;

// node_modules/recharts/es6/state/polarOptionsSlice.js
const polarOptionsSlice = createSlice({
  name: "polarOptions",
  initialState: null,
  reducers: {
    updatePolarOptions: (_state, action) => {
      return action.payload;
    }
  }
});
const {
  updatePolarOptions
} = polarOptionsSlice.actions;
const polarOptionsReducer = polarOptionsSlice.reducer;

// node_modules/recharts/es6/state/keyboardEventsMiddleware.js
const keyDownAction = createAction("keyDown");
const focusAction = createAction("focus");
const keyboardEventsMiddleware = createListenerMiddleware();
keyboardEventsMiddleware.startListening({
  actionCreator: keyDownAction,
  effect: (action, listenerApi) => {
    const state = listenerApi.getState();
    const accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
    if (!accessibilityLayerIsActive) {
      return;
    }
    const {
      keyboardInteraction
    } = state.tooltip;
    const key = action.payload;
    if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Enter") {
      return;
    }
    const currentIndex = Number(combineActiveTooltipIndex(keyboardInteraction, selectTooltipDisplayedData(state)));
    const tooltipTicks = selectTooltipAxisTicks(state);
    if (key === "Enter") {
      const _coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(keyboardInteraction.index));
      listenerApi.dispatch(setKeyboardInteraction({
        active: !keyboardInteraction.active,
        activeIndex: keyboardInteraction.index,
        activeDataKey: keyboardInteraction.dataKey,
        activeCoordinate: _coordinate
      }));
      return;
    }
    const direction = selectChartDirection(state);
    const directionMultiplier = direction === "left-to-right" ? 1 : -1;
    const movement = key === "ArrowRight" ? 1 : -1;
    const nextIndex = currentIndex + movement * directionMultiplier;
    if (tooltipTicks == null || nextIndex >= tooltipTicks.length || nextIndex < 0) {
      return;
    }
    const coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
    listenerApi.dispatch(setKeyboardInteraction({
      active: true,
      activeIndex: nextIndex.toString(),
      activeDataKey: void 0,
      activeCoordinate: coordinate
    }));
  }
});
keyboardEventsMiddleware.startListening({
  actionCreator: focusAction,
  effect: (_action, listenerApi) => {
    const state = listenerApi.getState();
    const accessibilityLayerIsActive = state.rootProps.accessibilityLayer !== false;
    if (!accessibilityLayerIsActive) {
      return;
    }
    const {
      keyboardInteraction
    } = state.tooltip;
    if (keyboardInteraction.active) {
      return;
    }
    if (keyboardInteraction.index == null) {
      const nextIndex = "0";
      const coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
      listenerApi.dispatch(setKeyboardInteraction({
        activeDataKey: void 0,
        active: true,
        activeIndex: nextIndex,
        activeCoordinate: coordinate
      }));
    }
  }
});

// node_modules/recharts/es6/state/externalEventsMiddleware.js
const externalEventAction = createAction("externalEvent");
const externalEventsMiddleware = createListenerMiddleware();
externalEventsMiddleware.startListening({
  actionCreator: externalEventAction,
  effect: (action, listenerApi) => {
    if (action.payload.handler == null) {
      return;
    }
    const state = listenerApi.getState();
    const nextState = {
      activeCoordinate: selectActiveTooltipCoordinate(state),
      activeDataKey: selectActiveTooltipDataKey(state),
      activeIndex: selectActiveTooltipIndex(state),
      activeLabel: selectActiveLabel(state),
      activeTooltipIndex: selectActiveTooltipIndex(state),
      isTooltipActive: selectIsTooltipActive(state)
    };
    action.payload.handler(nextState, action.payload.reactEvent);
  }
});

// node_modules/recharts/es6/state/selectors/touchSelectors.js
const selectAllTooltipPayloadConfiguration = createSelector([selectTooltipState], (tooltipState) => tooltipState.tooltipItemPayloads);
const selectTooltipCoordinate = createSelector([selectAllTooltipPayloadConfiguration, selectTooltipPayloadSearcher, (_state, tooltipIndex, _dataKey) => tooltipIndex, (_state, _tooltipIndex, dataKey) => dataKey], (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, dataKey) => {
  const mostRelevantTooltipConfiguration = allTooltipConfigurations.find((tooltipConfiguration) => {
    return tooltipConfiguration.settings.dataKey === dataKey;
  });
  if (mostRelevantTooltipConfiguration == null) {
    return void 0;
  }
  const {
    positions
  } = mostRelevantTooltipConfiguration;
  if (positions == null) {
    return void 0;
  }
  const maybePosition = tooltipPayloadSearcher(positions, tooltipIndex);
  return maybePosition;
});

// node_modules/recharts/es6/state/touchEventsMiddleware.js
const touchEventAction = createAction("touchMove");
const touchEventMiddleware = createListenerMiddleware();
touchEventMiddleware.startListening({
  actionCreator: touchEventAction,
  effect: (action, listenerApi) => {
    const touchEvent = action.payload;
    const state = listenerApi.getState();
    const tooltipEventType = selectTooltipEventType(state, state.tooltip.settings.shared);
    if (tooltipEventType === "axis") {
      const activeProps = selectActivePropsFromChartPointer(state, getChartPointer({
        clientX: touchEvent.touches[0].clientX,
        clientY: touchEvent.touches[0].clientY,
        currentTarget: touchEvent.currentTarget
      }));
      if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) {
        listenerApi.dispatch(setMouseOverAxisIndex({
          activeIndex: activeProps.activeIndex,
          activeDataKey: void 0,
          activeCoordinate: activeProps.activeCoordinate
        }));
      }
    } else if (tooltipEventType === "item") {
      let _target$getAttribute;
      const touch = touchEvent.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (!target || !target.getAttribute) {
        return;
      }
      const itemIndex = target.getAttribute(DATA_ITEM_INDEX_ATTRIBUTE_NAME);
      const dataKey = (_target$getAttribute = target.getAttribute(DATA_ITEM_DATAKEY_ATTRIBUTE_NAME)) !== null && _target$getAttribute !== void 0 ? _target$getAttribute : void 0;
      const coordinate = selectTooltipCoordinate(listenerApi.getState(), itemIndex, dataKey);
      listenerApi.dispatch(setActiveMouseOverItemIndex({
        activeDataKey: dataKey,
        activeIndex: itemIndex,
        activeCoordinate: coordinate
      }));
    }
  }
});

// node_modules/recharts/es6/state/store.js
const rootReducer = combineReducers({
  brush: brushReducer,
  cartesianAxis: cartesianAxisReducer,
  chartData: chartDataReducer,
  errorBars: errorBarReducer,
  graphicalItems: graphicalItemsReducer,
  layout: chartLayoutReducer,
  legend: legendReducer,
  options: optionsReducer,
  polarAxis: polarAxisReducer,
  polarOptions: polarOptionsReducer,
  referenceElements: referenceElementsReducer,
  rootProps: rootPropsReducer,
  tooltip: tooltipReducer
});
const createRechartsStore = function createRechartsStore2(preloadedState2) {
  const chartName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Chart";
  return configureStore({
    reducer: rootReducer,
    // redux-toolkit v1 types are unhappy with the preloadedState type. Remove the `as any` when bumping to v2
    preloadedState: preloadedState2,
    // @ts-expect-error redux-toolkit v1 types are unhappy with the middleware array. Remove this comment when bumping to v2
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({
      serializableCheck: false
    }).concat([mouseClickMiddleware.middleware, mouseMoveMiddleware.middleware, keyboardEventsMiddleware.middleware, externalEventsMiddleware.middleware, touchEventMiddleware.middleware]),
    devTools: Global.devToolsEnabled && {
      serialize: {
        replacer: reduxDevtoolsJsonStringifyReplacer
      },
      name: "recharts-".concat(chartName)
    }
  });
};

// node_modules/recharts/es6/state/RechartsStoreProvider.js
function RechartsStoreProvider(_ref2) {
  const {
    preloadedState: preloadedState2,
    children,
    reduxStoreName
  } = _ref2;
  const isPanorama = useIsPanorama();
  const storeRef = (0, import_react57.useRef)(null);
  if (isPanorama) {
    return children;
  }
  if (storeRef.current == null) {
    storeRef.current = createRechartsStore(preloadedState2, reduxStoreName);
  }
  const nonNullContext = RechartsReduxContext;
  return React54.createElement(Provider_default, {
    context: nonNullContext,
    store: storeRef.current
  }, children);
}

// node_modules/recharts/es6/state/ReportMainChartProps.js
const import_react58 = __toESM(require_react());
function ReportMainChartProps(_ref2) {
  const {
    layout,
    width,
    height,
    margin
  } = _ref2;
  const dispatch = useAppDispatch();
  const isPanorama = useIsPanorama();
  (0, import_react58.useEffect)(() => {
    if (!isPanorama) {
      dispatch(setLayout(layout));
      dispatch(setChartSize({
        width,
        height
      }));
      dispatch(setMargin(margin));
    }
  }, [dispatch, isPanorama, layout, width, height, margin]);
  return null;
}

// node_modules/recharts/es6/state/ReportChartProps.js
const import_react59 = __toESM(require_react());
function ReportChartProps(props) {
  const dispatch = useAppDispatch();
  (0, import_react59.useEffect)(() => {
    dispatch(updateOptions(props));
  }, [dispatch, props]);
  return null;
}

// node_modules/recharts/es6/chart/CategoricalChart.js
const React57 = __toESM(require_react());
const import_react63 = __toESM(require_react());

// node_modules/recharts/es6/container/RootSurface.js
const React55 = __toESM(require_react());
const import_react60 = __toESM(require_react());
const _excluded48 = ["children"];
function _objectWithoutProperties31(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose31(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose31(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends40() {
  return _extends40 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends40.apply(null, arguments);
}
const FULL_WIDTH_AND_HEIGHT = {
  width: "100%",
  height: "100%"
};
const MainChartSurface = (0, import_react60.forwardRef)((props, ref) => {
  const width = useChartWidth();
  const height = useChartHeight();
  const hasAccessibilityLayer = useAccessibilityLayer();
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  const {
    children,
    otherAttributes,
    title,
    desc
  } = props;
  let tabIndex, role;
  if (typeof otherAttributes.tabIndex === "number") {
    tabIndex = otherAttributes.tabIndex;
  } else {
    tabIndex = hasAccessibilityLayer ? 0 : void 0;
  }
  if (typeof otherAttributes.role === "string") {
    role = otherAttributes.role;
  } else {
    role = hasAccessibilityLayer ? "application" : void 0;
  }
  return React55.createElement(Surface, _extends40({}, otherAttributes, {
    title,
    desc,
    role,
    tabIndex,
    width,
    height,
    style: FULL_WIDTH_AND_HEIGHT,
    ref
  }), children);
});
const BrushPanoramaSurface = (_ref2) => {
  const {
    children
  } = _ref2;
  const brushDimensions = useAppSelector(selectBrushDimensions);
  if (!brushDimensions) {
    return null;
  }
  const {
    width,
    height,
    y: y2,
    x: x2
  } = brushDimensions;
  return React55.createElement(Surface, {
    width,
    height,
    x: x2,
    y: y2
  }, children);
};
const RootSurface = (0, import_react60.forwardRef)((_ref2, ref) => {
  let {
    children
  } = _ref2, rest2 = _objectWithoutProperties31(_ref2, _excluded48);
  const isPanorama = useIsPanorama();
  if (isPanorama) {
    return React55.createElement(BrushPanoramaSurface, null, children);
  }
  return React55.createElement(MainChartSurface, _extends40({
    ref
  }, rest2), children);
});

// node_modules/recharts/es6/chart/RechartsWrapper.js
const React56 = __toESM(require_react());
const import_react62 = __toESM(require_react());

// node_modules/recharts/es6/util/useReportScale.js
const import_react61 = __toESM(require_react());
function useReportScale() {
  const dispatch = useAppDispatch();
  const [ref, setRef] = (0, import_react61.useState)(null);
  const scale = useAppSelector(selectContainerScale);
  (0, import_react61.useEffect)(() => {
    if (ref == null) {
      return;
    }
    const rect = ref.getBoundingClientRect();
    const newScale = rect.width / ref.offsetWidth;
    if (isWellBehavedNumber(newScale) && newScale !== scale) {
      dispatch(setScale(newScale));
    }
  }, [ref, dispatch, scale]);
  return setRef;
}

// node_modules/recharts/es6/chart/RechartsWrapper.js
function ownKeys55(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread55(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys55(Object(t), true).forEach(function(r2) {
      _defineProperty57(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys55(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty57(e, r, t) {
  return (r = _toPropertyKey57(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey57(t) {
  const i = _toPrimitive57(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive57(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const RechartsWrapper = (0, import_react62.forwardRef)((_ref2, ref) => {
  const {
    children,
    className,
    height,
    onClick,
    onContextMenu,
    onDoubleClick,
    onMouseDown,
    onMouseEnter,
    onMouseLeave,
    onMouseMove,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    style,
    width
  } = _ref2;
  const dispatch = useAppDispatch();
  const [tooltipPortal, setTooltipPortal] = (0, import_react62.useState)(null);
  const [legendPortal, setLegendPortal] = (0, import_react62.useState)(null);
  useSynchronisedEventsFromOtherCharts();
  const setScaleRef = useReportScale();
  const innerRef = (0, import_react62.useCallback)((node) => {
    setScaleRef(node);
    if (typeof ref === "function") {
      ref(node);
    }
    setTooltipPortal(node);
    setLegendPortal(node);
  }, [setScaleRef, ref, setTooltipPortal, setLegendPortal]);
  const myOnClick = (0, import_react62.useCallback)((e) => {
    dispatch(mouseClickAction(e));
    dispatch(externalEventAction({
      handler: onClick,
      reactEvent: e
    }));
  }, [dispatch, onClick]);
  const myOnMouseEnter = (0, import_react62.useCallback)((e) => {
    dispatch(mouseMoveAction(e));
    dispatch(externalEventAction({
      handler: onMouseEnter,
      reactEvent: e
    }));
  }, [dispatch, onMouseEnter]);
  const myOnMouseLeave = (0, import_react62.useCallback)((e) => {
    dispatch(mouseLeaveChart());
    dispatch(externalEventAction({
      handler: onMouseLeave,
      reactEvent: e
    }));
  }, [dispatch, onMouseLeave]);
  const myOnMouseMove = (0, import_react62.useCallback)((e) => {
    dispatch(mouseMoveAction(e));
    dispatch(externalEventAction({
      handler: onMouseMove,
      reactEvent: e
    }));
  }, [dispatch, onMouseMove]);
  const onFocus = (0, import_react62.useCallback)(() => {
    dispatch(focusAction());
  }, [dispatch]);
  const onKeyDown = (0, import_react62.useCallback)((e) => {
    dispatch(keyDownAction(e.key));
  }, [dispatch]);
  const myOnContextMenu = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onContextMenu,
      reactEvent: e
    }));
  }, [dispatch, onContextMenu]);
  const myOnDoubleClick = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onDoubleClick,
      reactEvent: e
    }));
  }, [dispatch, onDoubleClick]);
  const myOnMouseDown = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onMouseDown,
      reactEvent: e
    }));
  }, [dispatch, onMouseDown]);
  const myOnMouseUp = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onMouseUp,
      reactEvent: e
    }));
  }, [dispatch, onMouseUp]);
  const myOnTouchStart = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onTouchStart,
      reactEvent: e
    }));
  }, [dispatch, onTouchStart]);
  const myOnTouchMove = (0, import_react62.useCallback)((e) => {
    dispatch(touchEventAction(e));
    dispatch(externalEventAction({
      handler: onTouchMove,
      reactEvent: e
    }));
  }, [dispatch, onTouchMove]);
  const myOnTouchEnd = (0, import_react62.useCallback)((e) => {
    dispatch(externalEventAction({
      handler: onTouchEnd,
      reactEvent: e
    }));
  }, [dispatch, onTouchEnd]);
  return React56.createElement(TooltipPortalContext.Provider, {
    value: tooltipPortal
  }, React56.createElement(LegendPortalContext.Provider, {
    value: legendPortal
  }, React56.createElement("div", {
    className: clsx("recharts-wrapper", className),
    style: _objectSpread55({
      position: "relative",
      cursor: "default",
      width,
      height
    }, style),
    onClick: myOnClick,
    onContextMenu: myOnContextMenu,
    onDoubleClick: myOnDoubleClick,
    onFocus,
    onKeyDown,
    onMouseDown: myOnMouseDown,
    onMouseEnter: myOnMouseEnter,
    onMouseLeave: myOnMouseLeave,
    onMouseMove: myOnMouseMove,
    onMouseUp: myOnMouseUp,
    onTouchEnd: myOnTouchEnd,
    onTouchMove: myOnTouchMove,
    onTouchStart: myOnTouchStart,
    ref: innerRef
  }, children)));
});

// node_modules/recharts/es6/chart/CategoricalChart.js
const _excluded49 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _objectWithoutProperties32(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose32(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose32(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const CategoricalChart = (0, import_react63.forwardRef)((props, ref) => {
  let {
    children,
    className,
    width,
    height,
    style,
    compact: compact2,
    title,
    desc
  } = props, others = _objectWithoutProperties32(props, _excluded49);
  const attrs = svgPropertiesNoEvents(others);
  if (compact2) {
    return React57.createElement(RootSurface, {
      otherAttributes: attrs,
      title,
      desc
    }, children);
  }
  return React57.createElement(RechartsWrapper, {
    className,
    style,
    width,
    height,
    onClick: props.onClick,
    onMouseLeave: props.onMouseLeave,
    onMouseEnter: props.onMouseEnter,
    onMouseMove: props.onMouseMove,
    onMouseDown: props.onMouseDown,
    onMouseUp: props.onMouseUp,
    onContextMenu: props.onContextMenu,
    onDoubleClick: props.onDoubleClick,
    onTouchStart: props.onTouchStart,
    onTouchMove: props.onTouchMove,
    onTouchEnd: props.onTouchEnd
  }, React57.createElement(RootSurface, {
    otherAttributes: attrs,
    title,
    desc,
    ref
  }, React57.createElement(ClipPathProvider, null, children)));
});

// node_modules/recharts/es6/chart/CartesianChart.js
const _excluded50 = ["width", "height"];
function _extends41() {
  return _extends41 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends41.apply(null, arguments);
}
function _objectWithoutProperties33(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose33(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose33(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const defaultMargin = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
};
const defaultProps6 = {
  accessibilityLayer: true,
  layout: "horizontal",
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: defaultMargin,
  reverseStackOrder: false,
  syncMethod: "index"
};
const CartesianChart = (0, import_react64.forwardRef)(function CartesianChart2(props, ref) {
  let _categoricalChartProp;
  const rootChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps6);
  let {
    width,
    height
  } = rootChartProps, otherCategoricalProps = _objectWithoutProperties33(rootChartProps, _excluded50);
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  const {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    categoricalChartProps
  } = props;
  const options3 = {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    eventEmitter: void 0
  };
  return React58.createElement(RechartsStoreProvider, {
    preloadedState: {
      options: options3
    },
    reduxStoreName: (_categoricalChartProp = categoricalChartProps.id) !== null && _categoricalChartProp !== void 0 ? _categoricalChartProp : chartName
  }, React58.createElement(ChartDataContextProvider, {
    chartData: categoricalChartProps.data
  }), React58.createElement(ReportMainChartProps, {
    width,
    height,
    layout: rootChartProps.layout,
    margin: rootChartProps.margin
  }), React58.createElement(ReportChartProps, {
    accessibilityLayer: rootChartProps.accessibilityLayer,
    barCategoryGap: rootChartProps.barCategoryGap,
    maxBarSize: rootChartProps.maxBarSize,
    stackOffset: rootChartProps.stackOffset,
    barGap: rootChartProps.barGap,
    barSize: rootChartProps.barSize,
    syncId: rootChartProps.syncId,
    syncMethod: rootChartProps.syncMethod,
    className: rootChartProps.className
  }), React58.createElement(CategoricalChart, _extends41({}, otherCategoricalProps, {
    width,
    height,
    ref
  })));
});

// node_modules/recharts/es6/chart/LineChart.js
const allowedTooltipTypes = ["axis"];
const LineChart = (0, import_react65.forwardRef)((props, ref) => {
  return React59.createElement(CartesianChart, {
    chartName: "LineChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});

// node_modules/recharts/es6/chart/BarChart.js
const React60 = __toESM(require_react());
const import_react66 = __toESM(require_react());
const allowedTooltipTypes2 = ["axis", "item"];
const BarChart = (0, import_react66.forwardRef)((props, ref) => {
  return React60.createElement(CartesianChart, {
    chartName: "BarChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes2,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});

// node_modules/recharts/es6/chart/PieChart.js
const React62 = __toESM(require_react());
const import_react69 = __toESM(require_react());

// node_modules/recharts/es6/chart/PolarChart.js
const import_react68 = __toESM(require_react());
const React61 = __toESM(require_react());

// node_modules/recharts/es6/state/ReportPolarOptions.js
const import_react67 = __toESM(require_react());
function ReportPolarOptions(props) {
  const dispatch = useAppDispatch();
  (0, import_react67.useEffect)(() => {
    dispatch(updatePolarOptions(props));
  }, [dispatch, props]);
  return null;
}

// node_modules/recharts/es6/chart/PolarChart.js
const _excluded51 = ["width", "height", "layout"];
function _extends42() {
  return _extends42 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends42.apply(null, arguments);
}
function _objectWithoutProperties34(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose34(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose34(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
const defaultMargin2 = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
};
const defaultProps7 = {
  accessibilityLayer: true,
  stackOffset: "none",
  barCategoryGap: "10%",
  barGap: 4,
  margin: defaultMargin2,
  reverseStackOrder: false,
  syncMethod: "index",
  layout: "radial"
};
const PolarChart = (0, import_react68.forwardRef)(function PolarChart2(props, ref) {
  let _polarChartProps$id;
  const polarChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps7);
  let {
    width,
    height,
    layout
  } = polarChartProps, otherCategoricalProps = _objectWithoutProperties34(polarChartProps, _excluded51);
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  const {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher
  } = props;
  const options3 = {
    chartName,
    defaultTooltipEventType,
    validateTooltipEventTypes,
    tooltipPayloadSearcher,
    eventEmitter: void 0
  };
  return React61.createElement(RechartsStoreProvider, {
    preloadedState: {
      options: options3
    },
    reduxStoreName: (_polarChartProps$id = polarChartProps.id) !== null && _polarChartProps$id !== void 0 ? _polarChartProps$id : chartName
  }, React61.createElement(ChartDataContextProvider, {
    chartData: polarChartProps.data
  }), React61.createElement(ReportMainChartProps, {
    width,
    height,
    layout,
    margin: polarChartProps.margin
  }), React61.createElement(ReportChartProps, {
    accessibilityLayer: polarChartProps.accessibilityLayer,
    barCategoryGap: polarChartProps.barCategoryGap,
    maxBarSize: polarChartProps.maxBarSize,
    stackOffset: polarChartProps.stackOffset,
    barGap: polarChartProps.barGap,
    barSize: polarChartProps.barSize,
    syncId: polarChartProps.syncId,
    syncMethod: polarChartProps.syncMethod,
    className: polarChartProps.className
  }), React61.createElement(ReportPolarOptions, {
    cx: polarChartProps.cx,
    cy: polarChartProps.cy,
    startAngle: polarChartProps.startAngle,
    endAngle: polarChartProps.endAngle,
    innerRadius: polarChartProps.innerRadius,
    outerRadius: polarChartProps.outerRadius
  }), React61.createElement(CategoricalChart, _extends42({
    width,
    height
  }, otherCategoricalProps, {
    ref
  })));
});

// node_modules/recharts/es6/chart/PieChart.js
const allowedTooltipTypes3 = ["item"];
const defaultProps8 = {
  layout: "centric",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
};
const PieChart = (0, import_react69.forwardRef)((props, ref) => {
  const propsWithDefaults = resolveDefaultProps(props, defaultProps8);
  return React62.createElement(PolarChart, {
    chartName: "PieChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: allowedTooltipTypes3,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: propsWithDefaults,
    ref
  });
});

// node_modules/recharts/es6/chart/Treemap.js
const React63 = __toESM(require_react());
const import_react70 = __toESM(require_react());
const import_omit2 = __toESM(require_omit2());
const import_get6 = __toESM(require_get2());
const _excluded52 = ["width", "height", "className", "style", "children", "type"];
function _objectWithoutProperties35(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose35(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose35(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _extends43() {
  return _extends43 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends43.apply(null, arguments);
}
function ownKeys56(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread56(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys56(Object(t), true).forEach(function(r2) {
      _defineProperty58(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys56(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty58(e, r, t) {
  return (r = _toPropertyKey58(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey58(t) {
  const i = _toPrimitive58(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive58(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const NODE_VALUE_KEY = "value";
const treemapPayloadSearcher = (data, activeIndex) => {
  return (0, import_get6.default)(data, activeIndex);
};
const addToTreemapNodeIndex = function addToTreemapNodeIndex2(indexInChildrenArr) {
  const activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
const options = {
  chartName: "Treemap",
  defaultTooltipEventType: "item",
  validateTooltipEventTypes: ["item"],
  tooltipPayloadSearcher: treemapPayloadSearcher,
  eventEmitter: void 0
};
const computeNode = (_ref2) => {
  const {
    depth,
    node,
    index: index2,
    dataKey,
    nameKey,
    nestedActiveTooltipIndex
  } = _ref2;
  const currentTooltipIndex = depth === 0 ? "" : addToTreemapNodeIndex(index2, nestedActiveTooltipIndex);
  const {
    children
  } = node;
  const childDepth = depth + 1;
  const computedChildren = children && children.length ? children.map((child, i) => computeNode({
    depth: childDepth,
    node: child,
    index: i,
    dataKey,
    nameKey,
    nestedActiveTooltipIndex: currentTooltipIndex
  })) : null;
  let nodeValue;
  if (children && children.length) {
    nodeValue = computedChildren.reduce((result, child) => result + child[NODE_VALUE_KEY], 0);
  } else {
    nodeValue = isNan(node[dataKey]) || node[dataKey] <= 0 ? 0 : node[dataKey];
  }
  return _objectSpread56(_objectSpread56({}, node), {}, {
    children: computedChildren,
    // @ts-expect-error getValueByDataKey does not validate the output type
    name: getValueByDataKey(node, nameKey, ""),
    [NODE_VALUE_KEY]: nodeValue,
    depth,
    index: index2,
    tooltipIndex: currentTooltipIndex
  });
};
const filterRect = (node) => ({
  x: node.x,
  y: node.y,
  width: node.width,
  height: node.height
});
const getAreaOfChildren = (children, areaValueRatio) => {
  const ratio = areaValueRatio < 0 ? 0 : areaValueRatio;
  return children.map((child) => {
    const area = child[NODE_VALUE_KEY] * ratio;
    return _objectSpread56(_objectSpread56({}, child), {}, {
      area: isNan(area) || area <= 0 ? 0 : area
    });
  });
};
const getWorstScore = (row, parentSize, aspectRatio) => {
  const parentArea = parentSize * parentSize;
  const rowArea = row.area * row.area;
  const {
    min: min3,
    max: max3
  } = row.reduce((result, child) => ({
    min: Math.min(result.min, child.area),
    max: Math.max(result.max, child.area)
  }), {
    min: Infinity,
    max: 0
  });
  return rowArea ? Math.max(parentArea * max3 * aspectRatio / rowArea, rowArea / (parentArea * min3 * aspectRatio)) : Infinity;
};
const horizontalPosition = (row, parentSize, parentRect, isFlush) => {
  let rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;
  if (isFlush || rowHeight > parentRect.height) {
    rowHeight = parentRect.height;
  }
  let curX = parentRect.x;
  let child;
  for (let i = 0, len = row.length; i < len; i++) {
    child = row[i];
    child.x = curX;
    child.y = parentRect.y;
    child.height = rowHeight;
    child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);
    curX += child.width;
  }
  child.width += parentRect.x + parentRect.width - curX;
  return _objectSpread56(_objectSpread56({}, parentRect), {}, {
    y: parentRect.y + rowHeight,
    height: parentRect.height - rowHeight
  });
};
const verticalPosition = (row, parentSize, parentRect, isFlush) => {
  let rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;
  if (isFlush || rowWidth > parentRect.width) {
    rowWidth = parentRect.width;
  }
  let curY = parentRect.y;
  let child;
  for (let i = 0, len = row.length; i < len; i++) {
    child = row[i];
    child.x = parentRect.x;
    child.y = curY;
    child.width = rowWidth;
    child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);
    curY += child.height;
  }
  if (child) {
    child.height += parentRect.y + parentRect.height - curY;
  }
  return _objectSpread56(_objectSpread56({}, parentRect), {}, {
    x: parentRect.x + rowWidth,
    width: parentRect.width - rowWidth
  });
};
const position = (row, parentSize, parentRect, isFlush) => {
  if (parentSize === parentRect.width) {
    return horizontalPosition(row, parentSize, parentRect, isFlush);
  }
  return verticalPosition(row, parentSize, parentRect, isFlush);
};
const squarify = (node, aspectRatio) => {
  const {
    children
  } = node;
  if (children && children.length) {
    let rect = filterRect(node);
    const row = [];
    let best = Infinity;
    let child, score;
    let size = Math.min(rect.width, rect.height);
    const scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);
    const tempChildren = scaleChildren.slice();
    row.area = 0;
    while (tempChildren.length > 0) {
      row.push(child = tempChildren[0]);
      row.area += child.area;
      score = getWorstScore(row, size, aspectRatio);
      if (score <= best) {
        tempChildren.shift();
        best = score;
      } else {
        row.area -= row.pop().area;
        rect = position(row, size, rect, false);
        size = Math.min(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      rect = position(row, size, rect, true);
      row.length = row.area = 0;
    }
    return _objectSpread56(_objectSpread56({}, node), {}, {
      children: scaleChildren.map((c2) => squarify(c2, aspectRatio))
    });
  }
  return node;
};
const defaultState = {
  isAnimationFinished: false,
  formatRoot: null,
  currentRoot: null,
  nestIndex: []
};
function ContentItem(_ref2) {
  const {
    content,
    nodeProps,
    type,
    colorPanel,
    onMouseEnter,
    onMouseLeave,
    onClick
  } = _ref2;
  if (React63.isValidElement(content)) {
    return React63.createElement(Layer, {
      onMouseEnter,
      onMouseLeave,
      onClick
    }, React63.cloneElement(content, nodeProps));
  }
  if (typeof content === "function") {
    return React63.createElement(Layer, {
      onMouseEnter,
      onMouseLeave,
      onClick
    }, content(nodeProps));
  }
  const {
    x: x2,
    y: y2,
    width,
    height,
    index: index2
  } = nodeProps;
  let arrow = null;
  if (width > 10 && height > 10 && nodeProps.children && type === "nest") {
    arrow = React63.createElement(Polygon, {
      points: [{
        x: x2 + 2,
        y: y2 + height / 2
      }, {
        x: x2 + 6,
        y: y2 + height / 2 + 3
      }, {
        x: x2 + 2,
        y: y2 + height / 2 + 6
      }]
    });
  }
  let text = null;
  const nameSize = getStringSize(nodeProps.name);
  if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {
    text = React63.createElement("text", {
      x: x2 + 8,
      y: y2 + height / 2 + 7,
      fontSize: 14
    }, nodeProps.name);
  }
  const colors = colorPanel || COLOR_PANEL;
  return React63.createElement("g", null, React63.createElement(Rectangle, _extends43({
    fill: nodeProps.depth < 2 ? colors[index2 % colors.length] : "rgba(255,255,255,0)",
    stroke: "#fff"
  }, (0, import_omit2.default)(nodeProps, ["children"]), {
    onMouseEnter,
    onMouseLeave,
    onClick,
    "data-recharts-item-index": nodeProps.tooltipIndex
  })), arrow, text);
}
function ContentItemWithEvents(props) {
  const dispatch = useAppDispatch();
  const activeCoordinate = props.nodeProps ? {
    x: props.nodeProps.x + props.nodeProps.width / 2,
    y: props.nodeProps.y + props.nodeProps.height / 2
  } : null;
  const onMouseEnter = () => {
    dispatch(setActiveMouseOverItemIndex({
      activeIndex: props.nodeProps.tooltipIndex,
      activeDataKey: props.dataKey,
      activeCoordinate
    }));
  };
  const onMouseLeave = () => {
  };
  const onClick = () => {
    dispatch(setActiveClickItemIndex({
      activeIndex: props.nodeProps.tooltipIndex,
      activeDataKey: props.dataKey,
      activeCoordinate
    }));
  };
  return React63.createElement(ContentItem, _extends43({}, props, {
    onMouseEnter,
    onMouseLeave,
    onClick
  }));
}
function getTooltipEntrySettings8(_ref3) {
  const {
    props,
    currentRoot
  } = _ref3;
  const {
    dataKey,
    nameKey,
    stroke,
    fill: fill2
  } = props;
  return {
    dataDefinedOnItem: currentRoot,
    positions: void 0,
    // TODO I think Treemap has the capability of computing positions and supporting defaultIndex? Except it doesn't yet
    settings: {
      stroke,
      strokeWidth: void 0,
      fill: fill2,
      dataKey,
      nameKey,
      name: void 0,
      // Each TreemapNode has its own name
      hide: false,
      type: void 0,
      color: fill2,
      unit: ""
    }
  };
}
const defaultTreemapMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
const TreemapWithState = class extends import_react70.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty58(this, "state", _objectSpread56({}, defaultState));
    _defineProperty58(this, "handleAnimationEnd", () => {
      const {
        onAnimationEnd
      } = this.props;
      this.setState({
        isAnimationFinished: true
      });
      if (typeof onAnimationEnd === "function") {
        onAnimationEnd();
      }
    });
    _defineProperty58(this, "handleAnimationStart", () => {
      const {
        onAnimationStart
      } = this.props;
      this.setState({
        isAnimationFinished: false
      });
      if (typeof onAnimationStart === "function") {
        onAnimationStart();
      }
    });
    _defineProperty58(this, "handleTouchMove", (_state, e) => {
      const touchEvent = e.touches[0];
      const target = document.elementFromPoint(touchEvent.clientX, touchEvent.clientY);
      if (!target || !target.getAttribute) {
        return;
      }
      const itemIndex = target.getAttribute("data-recharts-item-index");
      const activeNode = treemapPayloadSearcher(this.state.formatRoot, itemIndex);
      if (!activeNode) {
        return;
      }
      const {
        dataKey,
        dispatch
      } = this.props;
      const activeCoordinate = {
        x: activeNode.x + activeNode.width / 2,
        y: activeNode.y + activeNode.height / 2
      };
      dispatch(setActiveMouseOverItemIndex({
        activeIndex: itemIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
    });
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {
      const root = computeNode({
        depth: 0,
        // @ts-expect-error missing properties
        node: {
          children: nextProps.data,
          x: 0,
          y: 0,
          width: nextProps.width,
          height: nextProps.height
        },
        index: 0,
        dataKey: nextProps.dataKey,
        nameKey: nextProps.nameKey
      });
      const formatRoot = squarify(root, nextProps.aspectRatio);
      return _objectSpread56(_objectSpread56({}, prevState), {}, {
        formatRoot,
        currentRoot: root,
        nestIndex: [root],
        prevAspectRatio: nextProps.aspectRatio,
        prevData: nextProps.data,
        prevWidth: nextProps.width,
        prevHeight: nextProps.height,
        prevDataKey: nextProps.dataKey,
        prevType: nextProps.type
      });
    }
    return null;
  }
  handleMouseEnter(node, e) {
    e.persist();
    const {
      onMouseEnter
    } = this.props;
    if (onMouseEnter) {
      onMouseEnter(node, e);
    }
  }
  handleMouseLeave(node, e) {
    e.persist();
    const {
      onMouseLeave
    } = this.props;
    if (onMouseLeave) {
      onMouseLeave(node, e);
    }
  }
  handleClick(node) {
    const {
      onClick,
      type
    } = this.props;
    if (type === "nest" && node.children) {
      const {
        width,
        height,
        dataKey,
        nameKey,
        aspectRatio
      } = this.props;
      const root = computeNode({
        depth: 0,
        node: _objectSpread56(_objectSpread56({}, node), {}, {
          x: 0,
          y: 0,
          width,
          height
        }),
        index: 0,
        dataKey,
        nameKey,
        // with Treemap nesting, should this continue nesting the index or start from empty string?
        nestedActiveTooltipIndex: node.tooltipIndex
      });
      const formatRoot = squarify(root, aspectRatio);
      const {
        nestIndex
      } = this.state;
      nestIndex.push(node);
      this.setState({
        formatRoot,
        currentRoot: root,
        nestIndex
      });
    }
    if (onClick) {
      onClick(node);
    }
  }
  handleNestIndex(node, i) {
    let {
      nestIndex
    } = this.state;
    const {
      width,
      height,
      dataKey,
      nameKey,
      aspectRatio
    } = this.props;
    const root = computeNode({
      depth: 0,
      node: _objectSpread56(_objectSpread56({}, node), {}, {
        x: 0,
        y: 0,
        width,
        height
      }),
      index: 0,
      dataKey,
      nameKey,
      // with Treemap nesting, should this continue nesting the index or start from empty string?
      nestedActiveTooltipIndex: node.tooltipIndex
    });
    const formatRoot = squarify(root, aspectRatio);
    nestIndex = nestIndex.slice(0, i + 1);
    this.setState({
      formatRoot,
      currentRoot: node,
      nestIndex
    });
  }
  renderItem(content, nodeProps, isLeaf) {
    const {
      isAnimationActive,
      animationBegin,
      animationDuration,
      animationEasing,
      isUpdateAnimationActive,
      type,
      colorPanel,
      dataKey
    } = this.props;
    const {
      isAnimationFinished
    } = this.state;
    const {
      width,
      height,
      x: x2,
      y: y2,
      depth
    } = nodeProps;
    const translateX = parseInt("".concat((Math.random() * 2 - 1) * width), 10);
    let event = {};
    if (isLeaf || type === "nest") {
      event = {
        onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),
        onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),
        onClick: this.handleClick.bind(this, nodeProps)
      };
    }
    if (!isAnimationActive) {
      return React63.createElement(Layer, event, React63.createElement(ContentItemWithEvents, {
        content,
        dataKey,
        nodeProps: _objectSpread56(_objectSpread56({}, nodeProps), {}, {
          isAnimationActive: false,
          isUpdateAnimationActive: false,
          width,
          height,
          x: x2,
          y: y2
        }),
        type,
        colorPanel
      }));
    }
    return React63.createElement(CSSTransitionAnimate, {
      animationId: "treemap-".concat(nodeProps.tooltipIndex),
      from: "translate(".concat(translateX, "px, ").concat(translateX, "px)"),
      to: "translate(0, 0)",
      attributeName: "transform",
      begin: animationBegin,
      easing: animationEasing,
      isActive: isAnimationActive,
      duration: animationDuration,
      onAnimationStart: this.handleAnimationStart,
      onAnimationEnd: this.handleAnimationEnd
    }, (style) => React63.createElement(Layer, _extends43({}, event, {
      style
    }), depth > 2 && !isAnimationFinished ? null : React63.createElement(ContentItemWithEvents, {
      content,
      dataKey,
      nodeProps: _objectSpread56(_objectSpread56({}, nodeProps), {}, {
        isAnimationActive,
        isUpdateAnimationActive: !isUpdateAnimationActive,
        width,
        height,
        x: x2,
        y: y2
      }),
      type,
      colorPanel
    })));
  }
  renderNode(root, node) {
    const {
      content,
      type
    } = this.props;
    const nodeProps = _objectSpread56(_objectSpread56(_objectSpread56({}, svgPropertiesNoEvents(this.props)), node), {}, {
      root
    });
    const isLeaf = !node.children || !node.children.length;
    const {
      currentRoot
    } = this.state;
    const isCurrentRootChild = (currentRoot.children || []).filter((item) => item.depth === node.depth && item.name === node.name);
    if (!isCurrentRootChild.length && root.depth && type === "nest") {
      return null;
    }
    return React63.createElement(Layer, {
      key: "recharts-treemap-node-".concat(nodeProps.x, "-").concat(nodeProps.y, "-").concat(nodeProps.name),
      className: "recharts-treemap-depth-".concat(node.depth)
    }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map((child) => this.renderNode(node, child)) : null);
  }
  renderAllNodes() {
    const {
      formatRoot
    } = this.state;
    if (!formatRoot) {
      return null;
    }
    return this.renderNode(formatRoot, formatRoot);
  }
  // render nest treemap
  renderNestIndex() {
    const {
      nameKey,
      nestIndexContent
    } = this.props;
    const {
      nestIndex
    } = this.state;
    return React63.createElement("div", {
      className: "recharts-treemap-nest-index-wrapper",
      style: {
        marginTop: "8px",
        textAlign: "center"
      }
    }, nestIndex.map((item, i) => {
      const name = (0, import_get6.default)(item, nameKey, "root");
      let content = null;
      if (React63.isValidElement(nestIndexContent)) {
        content = React63.cloneElement(nestIndexContent, item, i);
      }
      if (typeof nestIndexContent === "function") {
        content = nestIndexContent(item, i);
      } else {
        content = name;
      }
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        React63.createElement("div", {
          onClick: this.handleNestIndex.bind(this, item, i),
          key: "nest-index-".concat(uniqueId()),
          className: "recharts-treemap-nest-index-box",
          style: {
            cursor: "pointer",
            display: "inline-block",
            padding: "0 7px",
            background: "#000",
            color: "#fff",
            marginRight: "3px"
          }
        }, content)
      );
    }));
  }
  render() {
    const _this$props = this.props, {
      width,
      height,
      className,
      style,
      children,
      type
    } = _this$props, others = _objectWithoutProperties35(_this$props, _excluded52);
    const attrs = svgPropertiesNoEvents(others);
    return React63.createElement(TooltipPortalContext.Provider, {
      value: this.state.tooltipPortal
    }, React63.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings8,
      args: {
        props: this.props,
        currentRoot: this.state.currentRoot
      }
    }), React63.createElement(RechartsWrapper, {
      className,
      style,
      width,
      height,
      ref: (node) => {
        if (this.state.tooltipPortal == null) {
          this.setState({
            tooltipPortal: node
          });
        }
      },
      onMouseEnter: void 0,
      onMouseLeave: void 0,
      onClick: void 0,
      onMouseMove: void 0,
      onMouseDown: void 0,
      onMouseUp: void 0,
      onContextMenu: void 0,
      onDoubleClick: void 0,
      onTouchStart: void 0,
      onTouchMove: this.handleTouchMove,
      onTouchEnd: void 0
    }, React63.createElement(Surface, _extends43({}, attrs, {
      width,
      height: type === "nest" ? height - 30 : height
    }), this.renderAllNodes(), children), type === "nest" && this.renderNestIndex()));
  }
};
_defineProperty58(TreemapWithState, "displayName", "Treemap");
_defineProperty58(TreemapWithState, "defaultProps", {
  aspectRatio: 0.5 * (1 + Math.sqrt(5)),
  dataKey: "value",
  nameKey: "name",
  type: "flat",
  isAnimationActive: !Global.isSsr,
  isUpdateAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "linear"
});
function TreemapDispatchInject(props) {
  const dispatch = useAppDispatch();
  return React63.createElement(TreemapWithState, _extends43({}, props, {
    dispatch
  }));
}
function Treemap(props) {
  let _props$className;
  const {
    width,
    height
  } = props;
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  return React63.createElement(RechartsStoreProvider, {
    preloadedState: {
      options
    },
    reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "Treemap"
  }, React63.createElement(ReportChartSize, {
    width,
    height
  }), React63.createElement(ReportChartMargin, {
    margin: defaultTreemapMargin
  }), React63.createElement(TreemapDispatchInject, props));
}

// node_modules/recharts/es6/chart/Sankey.js
const React64 = __toESM(require_react());
const import_react71 = __toESM(require_react());
const import_maxBy3 = __toESM(require_maxBy3());
const import_sumBy2 = __toESM(require_sumBy2());
const import_get7 = __toESM(require_get2());
const _excluded53 = ["sourceX", "sourceY", "sourceControlX", "targetX", "targetY", "targetControlX", "linkWidth"];
const _excluded216 = ["width", "height", "className", "style", "children"];
function _extends44() {
  return _extends44 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends44.apply(null, arguments);
}
function _objectWithoutProperties36(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose36(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose36(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys57(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread57(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys57(Object(t), true).forEach(function(r2) {
      _defineProperty59(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys57(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty59(e, r, t) {
  return (r = _toPropertyKey59(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey59(t) {
  const i = _toPrimitive59(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive59(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const interpolationGenerator = (a2, b) => {
  const ka2 = +a2;
  const kb = b - ka2;
  return (t) => ka2 + kb * t;
};
const centerY = (node) => node.y + node.dy / 2;
const getValue = (entry) => entry && entry.value || 0;
const getSumOfIds = (links, ids) => ids.reduce((result, id) => result + getValue(links[id]), 0);
const getSumWithWeightedSource = (tree, links, ids) => ids.reduce((result, id) => {
  const link2 = links[id];
  const sourceNode = tree[link2.source];
  return result + centerY(sourceNode) * getValue(links[id]);
}, 0);
const getSumWithWeightedTarget = (tree, links, ids) => ids.reduce((result, id) => {
  const link2 = links[id];
  const targetNode = tree[link2.target];
  return result + centerY(targetNode) * getValue(links[id]);
}, 0);
const ascendingY = (a2, b) => a2.y - b.y;
const searchTargetsAndSources = (links, id) => {
  const sourceNodes = [];
  const sourceLinks = [];
  const targetNodes = [];
  const targetLinks = [];
  for (let i = 0, len = links.length; i < len; i++) {
    const link2 = links[i];
    if (link2.source === id) {
      targetNodes.push(link2.target);
      targetLinks.push(i);
    }
    if (link2.target === id) {
      sourceNodes.push(link2.source);
      sourceLinks.push(i);
    }
  }
  return {
    sourceNodes,
    sourceLinks,
    targetLinks,
    targetNodes
  };
};
const updateDepthOfTargets = (tree, curNode) => {
  const {
    targetNodes
  } = curNode;
  for (let i = 0, len = targetNodes.length; i < len; i++) {
    const target = tree[targetNodes[i]];
    if (target) {
      target.depth = Math.max(curNode.depth + 1, target.depth);
      updateDepthOfTargets(tree, target);
    }
  }
};
const getNodesTree = (_ref2, width, nodeWidth) => {
  const {
    nodes,
    links
  } = _ref2;
  const tree = nodes.map((entry, index2) => {
    const result = searchTargetsAndSources(links, index2);
    return _objectSpread57(_objectSpread57(_objectSpread57({}, entry), result), {}, {
      value: Math.max(getSumOfIds(links, result.sourceLinks), getSumOfIds(links, result.targetLinks)),
      depth: 0
    });
  });
  for (let i = 0, len = tree.length; i < len; i++) {
    const node = tree[i];
    if (!node.sourceNodes.length) {
      updateDepthOfTargets(tree, node);
    }
  }
  const maxDepth = (0, import_maxBy3.default)(tree, (entry) => entry.depth).depth;
  if (maxDepth >= 1) {
    const childWidth = (width - nodeWidth) / maxDepth;
    for (let _i = 0, _len = tree.length; _i < _len; _i++) {
      const _node = tree[_i];
      if (!_node.targetNodes.length) {
        _node.depth = maxDepth;
      }
      _node.x = _node.depth * childWidth;
      _node.dx = nodeWidth;
    }
  }
  return {
    tree,
    maxDepth
  };
};
const getDepthTree = (tree) => {
  const result = [];
  for (let i = 0, len = tree.length; i < len; i++) {
    const node = tree[i];
    if (!result[node.depth]) {
      result[node.depth] = [];
    }
    result[node.depth].push(node);
  }
  return result;
};
const updateYOfTree = (depthTree, height, nodePadding, links) => {
  const yRatio = Math.min(...depthTree.map((nodes) => (height - (nodes.length - 1) * nodePadding) / (0, import_sumBy2.default)(nodes, getValue)));
  for (let d = 0, maxDepth = depthTree.length; d < maxDepth; d++) {
    for (let i = 0, len = depthTree[d].length; i < len; i++) {
      const node = depthTree[d][i];
      node.y = i;
      node.dy = node.value * yRatio;
    }
  }
  return links.map((link2) => _objectSpread57(_objectSpread57({}, link2), {}, {
    dy: getValue(link2) * yRatio
  }));
};
const resolveCollisions = function resolveCollisions2(depthTree, height, nodePadding) {
  const sort2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  for (let i = 0, len = depthTree.length; i < len; i++) {
    const nodes = depthTree[i];
    const n = nodes.length;
    if (sort2) {
      nodes.sort(ascendingY);
    }
    let y0 = 0;
    for (let j = 0; j < n; j++) {
      const node = nodes[j];
      const dy = y0 - node.y;
      if (dy > 0) {
        node.y += dy;
      }
      y0 = node.y + node.dy + nodePadding;
    }
    y0 = height + nodePadding;
    for (let _j = n - 1; _j >= 0; _j--) {
      const _node2 = nodes[_j];
      const _dy = _node2.y + _node2.dy + nodePadding - y0;
      if (_dy > 0) {
        _node2.y -= _dy;
        y0 = _node2.y;
      } else {
        break;
      }
    }
  }
};
const relaxLeftToRight = (tree, depthTree, links, alpha2) => {
  for (let i = 0, maxDepth = depthTree.length; i < maxDepth; i++) {
    const nodes = depthTree[i];
    for (let j = 0, len = nodes.length; j < len; j++) {
      const node = nodes[j];
      if (node.sourceLinks.length) {
        const sourceSum = getSumOfIds(links, node.sourceLinks);
        const weightedSum = getSumWithWeightedSource(tree, links, node.sourceLinks);
        const y2 = weightedSum / sourceSum;
        node.y += (y2 - centerY(node)) * alpha2;
      }
    }
  }
};
const relaxRightToLeft = (tree, depthTree, links, alpha2) => {
  for (let i = depthTree.length - 1; i >= 0; i--) {
    const nodes = depthTree[i];
    for (let j = 0, len = nodes.length; j < len; j++) {
      const node = nodes[j];
      if (node.targetLinks.length) {
        const targetSum = getSumOfIds(links, node.targetLinks);
        const weightedSum = getSumWithWeightedTarget(tree, links, node.targetLinks);
        const y2 = weightedSum / targetSum;
        node.y += (y2 - centerY(node)) * alpha2;
      }
    }
  }
};
const updateYOfLinks = (tree, links) => {
  for (let i = 0, len = tree.length; i < len; i++) {
    const node = tree[i];
    let sy = 0;
    let ty = 0;
    node.targetLinks.sort((a2, b) => tree[links[a2].target].y - tree[links[b].target].y);
    node.sourceLinks.sort((a2, b) => tree[links[a2].source].y - tree[links[b].source].y);
    for (let j = 0, tLen = node.targetLinks.length; j < tLen; j++) {
      const link2 = links[node.targetLinks[j]];
      if (link2) {
        link2.sy = sy;
        sy += link2.dy;
      }
    }
    for (let _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++) {
      const _link = links[node.sourceLinks[_j2]];
      if (_link) {
        _link.ty = ty;
        ty += _link.dy;
      }
    }
  }
};
const computeData = (_ref2) => {
  const {
    data,
    width,
    height,
    iterations,
    nodeWidth,
    nodePadding,
    sort: sort2
  } = _ref2;
  const {
    links
  } = data;
  const {
    tree
  } = getNodesTree(data, width, nodeWidth);
  const depthTree = getDepthTree(tree);
  const newLinks = updateYOfTree(depthTree, height, nodePadding, links);
  resolveCollisions(depthTree, height, nodePadding, sort2);
  let alpha2 = 1;
  for (let i = 1; i <= iterations; i++) {
    relaxRightToLeft(tree, depthTree, newLinks, alpha2 *= 0.99);
    resolveCollisions(depthTree, height, nodePadding, sort2);
    relaxLeftToRight(tree, depthTree, newLinks, alpha2);
    resolveCollisions(depthTree, height, nodePadding, sort2);
  }
  updateYOfLinks(tree, newLinks);
  return {
    nodes: tree,
    links: newLinks
  };
};
const getCoordinateOfTooltip = (item, type) => {
  if (type === "node") {
    return {
      x: +item.x + +item.width / 2,
      y: +item.y + +item.height / 2
    };
  }
  return "sourceX" in item && {
    x: (item.sourceX + item.targetX) / 2,
    y: (item.sourceY + item.targetY) / 2
  };
};
const getPayloadOfTooltip = (item, type, nameKey) => {
  const {
    payload
  } = item;
  if (type === "node") {
    return {
      payload,
      name: getValueByDataKey(payload, nameKey, ""),
      value: getValueByDataKey(payload, "value")
    };
  }
  if ("source" in payload && payload.source && payload.target) {
    const sourceName = getValueByDataKey(payload.source, nameKey, "");
    const targetName = getValueByDataKey(payload.target, nameKey, "");
    return {
      payload,
      name: "".concat(sourceName, " - ").concat(targetName),
      value: getValueByDataKey(payload, "value")
    };
  }
  return null;
};
const sankeyPayloadSearcher = (_, activeIndex, computedData, nameKey) => {
  if (activeIndex == null || typeof activeIndex !== "string") {
    return void 0;
  }
  const splitIndex = activeIndex.split("-");
  const [targetType, index2] = splitIndex;
  const item = (0, import_get7.default)(computedData, "".concat(targetType, "s[").concat(index2, "]"));
  if (item) {
    const payload = getPayloadOfTooltip(item, targetType, nameKey);
    return payload;
  }
  return void 0;
};
const options2 = {
  chartName: "Sankey",
  defaultTooltipEventType: "item",
  validateTooltipEventTypes: ["item"],
  tooltipPayloadSearcher: sankeyPayloadSearcher,
  eventEmitter: void 0
};
function getTooltipEntrySettings9(props) {
  const {
    dataKey,
    nameKey,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    data
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: void 0,
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      name,
      nameKey,
      color: fill2,
      unit: ""
      // Sankey does not have unit, why?
    }
  };
}
const defaultSankeyMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
function renderLinkItem(option, props) {
  if (React64.isValidElement(option)) {
    return React64.cloneElement(option, props);
  }
  if (typeof option === "function") {
    return option(props);
  }
  let {
    sourceX,
    sourceY,
    sourceControlX,
    targetX,
    targetY,
    targetControlX,
    linkWidth
  } = props, others = _objectWithoutProperties36(props, _excluded53);
  return React64.createElement("path", _extends44({
    className: "recharts-sankey-link",
    d: "\n          M".concat(sourceX, ",").concat(sourceY, "\n          C").concat(sourceControlX, ",").concat(sourceY, " ").concat(targetControlX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY, "\n        "),
    fill: "none",
    stroke: "#333",
    strokeWidth: linkWidth,
    strokeOpacity: "0.2"
  }, svgPropertiesNoEvents(others)));
}
const buildLinkProps = (_ref3) => {
  const {
    link: link2,
    nodes,
    left,
    top,
    i,
    linkContent,
    linkCurvature
  } = _ref3;
  const {
    sy: sourceRelativeY,
    ty: targetRelativeY,
    dy: linkWidth
  } = link2;
  const sourceNode = nodes[link2.source];
  const targetNode = nodes[link2.target];
  const sourceX = sourceNode.x + sourceNode.dx + left;
  const targetX = targetNode.x + left;
  const interpolationFunc = interpolationGenerator(sourceX, targetX);
  const sourceControlX = interpolationFunc(linkCurvature);
  const targetControlX = interpolationFunc(1 - linkCurvature);
  const sourceY = sourceNode.y + sourceRelativeY + linkWidth / 2 + top;
  const targetY = targetNode.y + targetRelativeY + linkWidth / 2 + top;
  const linkProps = _objectSpread57({
    sourceX,
    targetX,
    sourceY,
    targetY,
    sourceControlX,
    targetControlX,
    sourceRelativeY,
    targetRelativeY,
    linkWidth,
    index: i,
    payload: _objectSpread57(_objectSpread57({}, link2), {}, {
      source: sourceNode,
      target: targetNode
    })
  }, filterProps(linkContent, false));
  return linkProps;
};
function SankeyLinkElement(_ref4) {
  const {
    props,
    i,
    linkContent,
    onMouseEnter: _onMouseEnter,
    onMouseLeave: _onMouseLeave,
    onClick: _onClick,
    dataKey
  } = _ref4;
  const activeCoordinate = getCoordinateOfTooltip(props, "link");
  const activeIndex = "link-".concat(i);
  const dispatch = useAppDispatch();
  const events = {
    onMouseEnter: (e) => {
      dispatch(setActiveMouseOverItemIndex({
        activeIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
      _onMouseEnter(props, e);
    },
    onMouseLeave: (e) => {
      dispatch(mouseLeaveItem());
      _onMouseLeave(props, e);
    },
    onClick: (e) => {
      dispatch(setActiveClickItemIndex({
        activeIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
      _onClick(props, e);
    }
  };
  return React64.createElement(Layer, events, renderLinkItem(linkContent, props));
}
function AllSankeyLinkElements(_ref5) {
  const {
    modifiedLinks,
    links,
    linkContent,
    onMouseEnter,
    onMouseLeave,
    onClick,
    dataKey
  } = _ref5;
  return React64.createElement(Layer, {
    className: "recharts-sankey-links",
    key: "recharts-sankey-links"
  }, links.map((link2, i) => {
    const linkProps = modifiedLinks[i];
    return React64.createElement(SankeyLinkElement, {
      key: "link-".concat(link2.source, "-").concat(link2.target, "-").concat(link2.value),
      props: linkProps,
      linkContent,
      i,
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey
    });
  }));
}
function renderNodeItem(option, props) {
  if (React64.isValidElement(option)) {
    return React64.cloneElement(option, props);
  }
  if (typeof option === "function") {
    return option(props);
  }
  return (
    // @ts-expect-error recharts radius is not compatible with SVG radius
    React64.createElement(Rectangle, _extends44({
      className: "recharts-sankey-node",
      fill: "#0088fe",
      fillOpacity: "0.8"
    }, svgPropertiesNoEvents(props)))
  );
}
const buildNodeProps = (_ref6) => {
  const {
    node,
    nodeContent,
    top,
    left,
    i
  } = _ref6;
  const {
    x: x2,
    y: y2,
    dx,
    dy
  } = node;
  const nodeProps = _objectSpread57(_objectSpread57({}, filterProps(nodeContent, false)), {}, {
    x: x2 + left,
    y: y2 + top,
    width: dx,
    height: dy,
    index: i,
    payload: node
  });
  return nodeProps;
};
function NodeElement(_ref7) {
  const {
    props,
    nodeContent,
    i,
    onMouseEnter: _onMouseEnter2,
    onMouseLeave: _onMouseLeave2,
    onClick: _onClick2,
    dataKey
  } = _ref7;
  const dispatch = useAppDispatch();
  const activeCoordinate = getCoordinateOfTooltip(props, "node");
  const activeIndex = "node-".concat(i);
  const events = {
    onMouseEnter: (e) => {
      dispatch(setActiveMouseOverItemIndex({
        activeIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
      _onMouseEnter2(props, e);
    },
    onMouseLeave: (e) => {
      dispatch(mouseLeaveItem());
      _onMouseLeave2(props, e);
    },
    onClick: (e) => {
      dispatch(setActiveClickItemIndex({
        activeIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
      _onClick2(props, e);
    }
  };
  return React64.createElement(Layer, events, renderNodeItem(nodeContent, props));
}
function AllNodeElements(_ref8) {
  const {
    modifiedNodes,
    nodeContent,
    onMouseEnter,
    onMouseLeave,
    onClick,
    dataKey
  } = _ref8;
  return React64.createElement(Layer, {
    className: "recharts-sankey-nodes",
    key: "recharts-sankey-nodes"
  }, modifiedNodes.map((modifiedNode, i) => {
    return React64.createElement(NodeElement, {
      props: modifiedNode,
      nodeContent,
      i,
      onMouseEnter,
      onMouseLeave,
      onClick,
      dataKey
    });
  }));
}
const Sankey = class extends import_react71.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty59(this, "state", {
      nodes: [],
      links: [],
      modifiedLinks: [],
      modifiedNodes: []
    });
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      data,
      width,
      height,
      margin,
      iterations,
      nodeWidth,
      nodePadding,
      sort: sort2,
      linkCurvature
    } = nextProps;
    if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || !shallowEqual(margin, prevState.prevMargin) || iterations !== prevState.prevIterations || nodeWidth !== prevState.prevNodeWidth || nodePadding !== prevState.prevNodePadding || sort2 !== prevState.sort) {
      const contentWidth = width - (margin && margin.left || 0) - (margin && margin.right || 0);
      const contentHeight = height - (margin && margin.top || 0) - (margin && margin.bottom || 0);
      const {
        links,
        nodes
      } = computeData({
        data,
        width: contentWidth,
        height: contentHeight,
        iterations,
        nodeWidth,
        nodePadding,
        sort: sort2
      });
      const top = (0, import_get7.default)(margin, "top") || 0;
      const left = (0, import_get7.default)(margin, "left") || 0;
      const modifiedLinks = links.map((link2, i) => {
        return buildLinkProps({
          link: link2,
          nodes,
          i,
          top,
          left,
          linkContent: nextProps.link,
          linkCurvature
        });
      });
      const modifiedNodes = nodes.map((node, i) => {
        return buildNodeProps({
          node,
          nodeContent: nextProps.node,
          i,
          top,
          left
        });
      });
      return _objectSpread57(_objectSpread57({}, prevState), {}, {
        nodes,
        links,
        modifiedLinks,
        modifiedNodes,
        prevData: data,
        prevWidth: iterations,
        prevHeight: height,
        prevMargin: margin,
        prevNodePadding: nodePadding,
        prevNodeWidth: nodeWidth,
        prevIterations: iterations,
        prevSort: sort2
      });
    }
    return null;
  }
  handleMouseEnter(item, type, e) {
    const {
      onMouseEnter
    } = this.props;
    if (onMouseEnter) {
      onMouseEnter(item, type, e);
    }
  }
  handleMouseLeave(item, type, e) {
    const {
      onMouseLeave
    } = this.props;
    if (onMouseLeave) {
      onMouseLeave(item, type, e);
    }
  }
  handleClick(item, type, e) {
    const {
      onClick
    } = this.props;
    if (onClick) onClick(item, type, e);
  }
  render() {
    const _this$props = this.props, {
      width,
      height,
      className,
      style,
      children
    } = _this$props, others = _objectWithoutProperties36(_this$props, _excluded216);
    if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
      return null;
    }
    const {
      links,
      modifiedNodes,
      modifiedLinks
    } = this.state;
    const attrs = svgPropertiesNoEvents(others);
    return React64.createElement(RechartsStoreProvider, {
      preloadedState: {
        options: options2
      },
      reduxStoreName: className !== null && className !== void 0 ? className : "Sankey"
    }, React64.createElement(SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings9,
      args: this.props
    }), React64.createElement(SetComputedData, {
      computedData: {
        links: modifiedLinks,
        nodes: modifiedNodes
      }
    }), React64.createElement(ReportChartSize, {
      width,
      height
    }), React64.createElement(ReportChartMargin, {
      margin: defaultSankeyMargin
    }), React64.createElement(TooltipPortalContext.Provider, {
      value: this.state.tooltipPortal
    }, React64.createElement(RechartsWrapper, {
      className,
      style,
      width,
      height,
      ref: (node) => {
        if (this.state.tooltipPortal == null) {
          this.setState({
            tooltipPortal: node
          });
        }
      },
      onMouseEnter: void 0,
      onMouseLeave: void 0,
      onClick: void 0,
      onMouseMove: void 0,
      onMouseDown: void 0,
      onMouseUp: void 0,
      onContextMenu: void 0,
      onDoubleClick: void 0,
      onTouchStart: void 0,
      onTouchMove: void 0,
      onTouchEnd: void 0
    }, React64.createElement(Surface, _extends44({}, attrs, {
      width,
      height
    }), children, React64.createElement(AllSankeyLinkElements, {
      links,
      modifiedLinks,
      linkContent: this.props.link,
      dataKey: this.props.dataKey,
      onMouseEnter: (linkProps, e) => this.handleMouseEnter(linkProps, "link", e),
      onMouseLeave: (linkProps, e) => this.handleMouseLeave(linkProps, "link", e),
      onClick: (linkProps, e) => this.handleClick(linkProps, "link", e)
    }), React64.createElement(AllNodeElements, {
      modifiedNodes,
      nodeContent: this.props.node,
      dataKey: this.props.dataKey,
      onMouseEnter: (nodeProps, e) => this.handleMouseEnter(nodeProps, "node", e),
      onMouseLeave: (nodeProps, e) => this.handleMouseLeave(nodeProps, "node", e),
      onClick: (nodeProps, e) => this.handleClick(nodeProps, "node", e)
    })))));
  }
};
_defineProperty59(Sankey, "displayName", "Sankey");
_defineProperty59(Sankey, "defaultProps", {
  nameKey: "name",
  dataKey: "value",
  nodePadding: 10,
  nodeWidth: 10,
  linkCurvature: 0.5,
  iterations: 32,
  margin: {
    top: 5,
    right: 5,
    bottom: 5,
    left: 5
  },
  sort: true
});

// node_modules/recharts/es6/chart/RadarChart.js
const React65 = __toESM(require_react());
const import_react72 = __toESM(require_react());
const allowedTooltipTypes4 = ["axis"];
const defaultProps9 = {
  layout: "centric",
  startAngle: 90,
  endAngle: -270,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
};
const RadarChart = (0, import_react72.forwardRef)((props, ref) => {
  const propsWithDefaults = resolveDefaultProps(props, defaultProps9);
  return React65.createElement(PolarChart, {
    chartName: "RadarChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes4,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: propsWithDefaults,
    ref
  });
});

// node_modules/recharts/es6/chart/ScatterChart.js
const React66 = __toESM(require_react());
const import_react73 = __toESM(require_react());
const allowedTooltipTypes5 = ["item"];
const ScatterChart = (0, import_react73.forwardRef)((props, ref) => {
  return React66.createElement(CartesianChart, {
    chartName: "ScatterChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: allowedTooltipTypes5,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});

// node_modules/recharts/es6/chart/AreaChart.js
const React67 = __toESM(require_react());
const import_react74 = __toESM(require_react());
const allowedTooltipTypes6 = ["axis"];
const AreaChart = (0, import_react74.forwardRef)((props, ref) => {
  return React67.createElement(CartesianChart, {
    chartName: "AreaChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes6,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});

// node_modules/recharts/es6/chart/RadialBarChart.js
const React68 = __toESM(require_react());
const import_react75 = __toESM(require_react());
const allowedTooltipTypes7 = ["axis", "item"];
const defaultProps10 = {
  layout: "radial",
  startAngle: 0,
  endAngle: 360,
  cx: "50%",
  cy: "50%",
  innerRadius: 0,
  outerRadius: "80%"
};
const RadialBarChart = (0, import_react75.forwardRef)((props, ref) => {
  const propsWithDefaults = resolveDefaultProps(props, defaultProps10);
  return React68.createElement(PolarChart, {
    chartName: "RadialBarChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes7,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: propsWithDefaults,
    ref
  });
});

// node_modules/recharts/es6/chart/ComposedChart.js
const React69 = __toESM(require_react());
const import_react76 = __toESM(require_react());
const allowedTooltipTypes8 = ["axis"];
const ComposedChart = (0, import_react76.forwardRef)((props, ref) => {
  return React69.createElement(CartesianChart, {
    chartName: "ComposedChart",
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: allowedTooltipTypes8,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});

// node_modules/recharts/es6/chart/SunburstChart.js
const React70 = __toESM(require_react());
const import_react77 = __toESM(require_react());
const import_get8 = __toESM(require_get2());
function _extends45() {
  return _extends45 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends45.apply(null, arguments);
}
function ownKeys58(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread58(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys58(Object(t), true).forEach(function(r2) {
      _defineProperty60(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys58(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty60(e, r, t) {
  return (r = _toPropertyKey60(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey60(t) {
  const i = _toPrimitive60(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive60(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const defaultTextProps = {
  fontWeight: "bold",
  paintOrder: "stroke fill",
  fontSize: ".75rem",
  stroke: "#FFF",
  fill: "black",
  pointerEvents: "none"
};
function getMaxDepthOf(node) {
  if (!node.children || node.children.length === 0) return 1;
  const childDepths = node.children.map((d) => getMaxDepthOf(d));
  return 1 + Math.max(...childDepths);
}
function convertMapToRecord(map5) {
  const record = {};
  map5.forEach((value, key) => {
    record[key] = value;
  });
  return record;
}
function getTooltipEntrySettings10(_ref2) {
  const {
    dataKey,
    nameKey,
    data,
    stroke,
    fill: fill2,
    positions
  } = _ref2;
  return {
    dataDefinedOnItem: data.children,
    // Redux store will not accept a Map because it's not serializable
    positions: convertMapToRecord(positions),
    // Sunburst does not support many of the properties as other charts do so there's plenty of defaults here
    settings: {
      stroke,
      strokeWidth: void 0,
      fill: fill2,
      nameKey,
      dataKey,
      // if there is a nameKey use it, otherwise make the name of the tooltip the dataKey itself
      name: nameKey ? void 0 : dataKey,
      hide: false,
      type: void 0,
      color: fill2,
      unit: ""
    }
  };
}
const defaultSunburstMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
const payloadSearcher = (data, activeIndex) => {
  return (0, import_get8.default)(data, activeIndex);
};
const addToSunburstNodeIndex = function addToSunburstNodeIndex2(indexInChildrenArr) {
  const activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
const preloadedState = {
  options: {
    validateTooltipEventTypes: ["item"],
    defaultTooltipEventType: "item",
    chartName: "Sunburst",
    tooltipPayloadSearcher: payloadSearcher,
    eventEmitter: void 0
  }
};
const SunburstChartImpl = (_ref2) => {
  const {
    className,
    data,
    children,
    width,
    height,
    padding = 2,
    dataKey = "value",
    nameKey = "name",
    ringPadding = 2,
    innerRadius = 50,
    fill: fill2 = "#333",
    stroke = "#FFF",
    textOptions = defaultTextProps,
    outerRadius = Math.min(width, height) / 2,
    cx = width / 2,
    cy = height / 2,
    startAngle = 0,
    endAngle = 360,
    onClick,
    onMouseEnter,
    onMouseLeave
  } = _ref2;
  const dispatch = useAppDispatch();
  const rScale = linear2([0, data[dataKey]], [0, endAngle]);
  const treeDepth = getMaxDepthOf(data);
  const thickness = (outerRadius - innerRadius) / treeDepth;
  const sectors = [];
  const positions = /* @__PURE__ */ new Map([]);
  const [tooltipPortal, setTooltipPortal] = (0, import_react77.useState)(null);
  function handleMouseEnter(node, e) {
    if (onMouseEnter) onMouseEnter(node, e);
    dispatch(setActiveMouseOverItemIndex({
      activeIndex: node.tooltipIndex,
      activeDataKey: dataKey,
      activeCoordinate: positions.get(node.name)
    }));
  }
  function handleMouseLeave(node, e) {
    if (onMouseLeave) onMouseLeave(node, e);
    dispatch(mouseLeaveItem());
  }
  function handleClick(node) {
    if (onClick) onClick(node);
    dispatch(setActiveClickItemIndex({
      activeIndex: node.tooltipIndex,
      activeDataKey: dataKey,
      activeCoordinate: positions.get(node.name)
    }));
  }
  function drawArcs(childNodes, options3) {
    const depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const {
      radius,
      innerR,
      initialAngle,
      childColor,
      nestedActiveTooltipIndex
    } = options3;
    let currentAngle = initialAngle;
    if (!childNodes) return;
    childNodes.forEach((d, i) => {
      let _ref3, _d$fill;
      const currentTooltipIndex = depth === 1 ? "[".concat(i, "]") : addToSunburstNodeIndex(i, nestedActiveTooltipIndex);
      const nodeWithIndex = _objectSpread58(_objectSpread58({}, d), {}, {
        tooltipIndex: currentTooltipIndex
      });
      const arcLength = rScale(d[dataKey]);
      const start = currentAngle;
      const fillColor = (_ref3 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref3 !== void 0 ? _ref3 : fill2;
      const {
        x: textX,
        y: textY
      } = polarToCartesian(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2));
      currentAngle += arcLength;
      sectors.push(
        // eslint-disable-next-line react/no-array-index-key
        React70.createElement("g", {
          key: "sunburst-sector-".concat(d.name, "-").concat(i)
        }, React70.createElement(Sector, {
          onClick: () => handleClick(nodeWithIndex),
          onMouseEnter: (e) => handleMouseEnter(nodeWithIndex, e),
          onMouseLeave: (e) => handleMouseLeave(nodeWithIndex, e),
          fill: fillColor,
          stroke,
          strokeWidth: padding,
          startAngle: start,
          endAngle: start + arcLength,
          innerRadius: innerR,
          outerRadius: innerR + radius,
          cx,
          cy
        }), React70.createElement(Text, _extends45({}, textOptions, {
          alignmentBaseline: "middle",
          textAnchor: "middle",
          x: textX + cx,
          y: cy - textY
        }), d[dataKey]))
      );
      const {
        x: tooltipX,
        y: tooltipY
      } = polarToCartesian(cx, cy, innerR + radius / 2, start);
      positions.set(d.name, {
        x: tooltipX,
        y: tooltipY
      });
      return drawArcs(d.children, {
        radius,
        innerR: innerR + radius + ringPadding,
        initialAngle: start,
        childColor: fillColor,
        nestedActiveTooltipIndex: currentTooltipIndex
      }, depth + 1);
    });
  }
  drawArcs(data.children, {
    radius: thickness,
    innerR: innerRadius,
    initialAngle: startAngle
  });
  const layerClass = clsx("recharts-sunburst", className);
  return React70.createElement(TooltipPortalContext.Provider, {
    value: tooltipPortal
  }, React70.createElement(RechartsWrapper, {
    className,
    width,
    height,
    ref: (node) => {
      if (tooltipPortal == null && node != null) {
        setTooltipPortal(node);
      }
    },
    onMouseEnter: void 0,
    onMouseLeave: void 0,
    onClick: void 0,
    onMouseMove: void 0,
    onMouseDown: void 0,
    onMouseUp: void 0,
    onContextMenu: void 0,
    onDoubleClick: void 0,
    onTouchStart: void 0,
    onTouchMove: void 0,
    onTouchEnd: void 0
  }, React70.createElement(Surface, {
    width,
    height
  }, React70.createElement(Layer, {
    className: layerClass
  }, sectors), React70.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings10,
    args: {
      dataKey,
      data,
      stroke,
      fill: fill2,
      nameKey,
      positions
    }
  }), children)));
};
const SunburstChart = (props) => {
  let _props$className;
  return React70.createElement(RechartsStoreProvider, {
    preloadedState,
    reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "SunburstChart"
  }, React70.createElement(ReportChartSize, {
    width: props.width,
    height: props.height
  }), React70.createElement(ReportChartMargin, {
    margin: defaultSunburstMargin
  }), React70.createElement(SunburstChartImpl, props));
};

// node_modules/recharts/es6/cartesian/Funnel.js
const React72 = __toESM(require_react());
const import_react78 = __toESM(require_react());
const import_omit3 = __toESM(require_omit2());

// node_modules/recharts/es6/util/FunnelUtils.js
const React71 = __toESM(require_react());
function _extends46() {
  return _extends46 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends46.apply(null, arguments);
}
function ownKeys59(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread59(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys59(Object(t), true).forEach(function(r2) {
      _defineProperty61(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys59(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty61(e, r, t) {
  return (r = _toPropertyKey61(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey61(t) {
  const i = _toPrimitive61(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive61(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function typeGuardTrapezoidProps(option, props) {
  const xValue = "".concat(props.x || option.x);
  const x2 = parseInt(xValue, 10);
  const yValue = "".concat(props.y || option.y);
  const y2 = parseInt(yValue, 10);
  const heightValue = "".concat((props === null || props === void 0 ? void 0 : props.height) || (option === null || option === void 0 ? void 0 : option.height));
  const height = parseInt(heightValue, 10);
  return _objectSpread59(_objectSpread59(_objectSpread59({}, props), getPropsFromShapeOption(option)), {}, {
    height,
    x: x2,
    y: y2
  });
}
function FunnelTrapezoid(props) {
  return React71.createElement(Shape, _extends46({
    shapeType: "trapezoid",
    propTransformer: typeGuardTrapezoidProps
  }, props));
}

// node_modules/recharts/es6/state/selectors/funnelSelectors.js
function ownKeys60(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread60(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys60(Object(t), true).forEach(function(r2) {
      _defineProperty62(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys60(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty62(e, r, t) {
  return (r = _toPropertyKey62(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey62(t) {
  const i = _toPrimitive62(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive62(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
const pickFunnelSettings = (_state, funnelSettings) => funnelSettings;
const selectFunnelTrapezoids = createSelector([selectChartOffsetInternal, pickFunnelSettings, selectChartDataAndAlwaysIgnoreIndexes], (offset, _ref2, _ref22) => {
  const {
    data,
    dataKey,
    nameKey,
    tooltipType,
    lastShapeType,
    reversed,
    customWidth,
    cells,
    presentationProps
  } = _ref2;
  const {
    chartData
  } = _ref22;
  let displayedData;
  if (data != null && data.length > 0) {
    displayedData = data;
  } else if (chartData != null && chartData.length > 0) {
    displayedData = chartData;
  }
  if (displayedData && displayedData.length) {
    displayedData = displayedData.map((entry, index2) => _objectSpread60(_objectSpread60(_objectSpread60({
      payload: entry
    }, presentationProps), entry), cells && cells[index2] && cells[index2].props));
  } else if (cells && cells.length) {
    displayedData = cells.map((cell) => _objectSpread60(_objectSpread60({}, presentationProps), cell.props));
  } else {
    return [];
  }
  return computeFunnelTrapezoids({
    dataKey,
    nameKey,
    displayedData,
    tooltipType,
    lastShapeType,
    reversed,
    offset,
    customWidth
  });
});

// node_modules/recharts/es6/cartesian/Funnel.js
const _excluded54 = ["onMouseEnter", "onClick", "onMouseLeave", "shape", "activeShape"];
const _excluded217 = ["stroke", "fill", "legendType", "hide", "isAnimationActive", "animationBegin", "animationDuration", "animationEasing", "nameKey", "lastShapeType"];
function _extends47() {
  return _extends47 = Object.assign ? Object.assign.bind() : function(n) {
    for (let e = 1; e < arguments.length; e++) {
      const t = arguments[e];
      for (const r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends47.apply(null, arguments);
}
function _objectWithoutProperties37(e, t) {
  if (null == e) return {};
  let o, r, i = _objectWithoutPropertiesLoose37(e, t);
  if (Object.getOwnPropertySymbols) {
    const n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose37(r, e) {
  if (null == r) return {};
  const t = {};
  for (const n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function ownKeys61(e, r) {
  const t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    let o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread61(e) {
  for (let r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys61(Object(t), true).forEach(function(r2) {
      _defineProperty63(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys61(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty63(e, r, t) {
  return (r = _toPropertyKey63(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey63(t) {
  const i = _toPrimitive63(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive63(t, r) {
  if ("object" != typeof t || !t) return t;
  const e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    const i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function getTooltipEntrySettings11(props) {
  const {
    dataKey,
    nameKey,
    stroke,
    strokeWidth,
    fill: fill2,
    name,
    hide,
    tooltipType,
    data
  } = props;
  return {
    dataDefinedOnItem: data,
    positions: props.trapezoids.map((_ref2) => {
      const {
        tooltipPosition
      } = _ref2;
      return tooltipPosition;
    }),
    settings: {
      stroke,
      strokeWidth,
      fill: fill2,
      dataKey,
      name,
      nameKey,
      hide,
      type: tooltipType,
      color: fill2,
      unit: ""
      // Funnel does not have unit, why?
    }
  };
}
function FunnelLabelListProvider(_ref2) {
  const {
    showLabels,
    trapezoids,
    children
  } = _ref2;
  const labelListEntries = (0, import_react78.useMemo)(() => {
    if (!showLabels) {
      return void 0;
    }
    return trapezoids === null || trapezoids === void 0 ? void 0 : trapezoids.map((entry) => {
      const viewBox = {
        x: entry.x,
        y: entry.y,
        // Label positions in Funnel are calculated relative to upperWidth so that's what we need to pass here as "width"
        width: entry.upperWidth,
        height: entry.height
      };
      return _objectSpread61(_objectSpread61({}, viewBox), {}, {
        value: entry.name,
        payload: entry.payload,
        parentViewBox: void 0,
        viewBox,
        fill: entry.fill
      });
    });
  }, [showLabels, trapezoids]);
  return React72.createElement(CartesianLabelListContextProvider, {
    value: labelListEntries
  }, children);
}
function FunnelTrapezoids(props) {
  const {
    trapezoids,
    allOtherFunnelProps
  } = props;
  const activeItemIndex = useAppSelector((state) => selectActiveIndex(state, "item", state.tooltip.settings.trigger, void 0));
  let {
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps,
    shape,
    activeShape
  } = allOtherFunnelProps, restOfAllOtherProps = _objectWithoutProperties37(allOtherFunnelProps, _excluded54);
  const onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherFunnelProps.dataKey);
  const onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
  const onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherFunnelProps.dataKey);
  return React72.createElement(React72.Fragment, null, trapezoids.map((entry, i) => {
    const isActiveIndex = Boolean(activeShape) && activeItemIndex === String(i);
    const trapezoidOptions = isActiveIndex ? activeShape : shape;
    const trapezoidProps = _objectSpread61(_objectSpread61({}, entry), {}, {
      option: trapezoidOptions,
      isActive: isActiveIndex,
      stroke: entry.stroke
    });
    return React72.createElement(Layer, _extends47({
      className: "recharts-funnel-trapezoid"
    }, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
      // @ts-expect-error the types need a bit of attention
      onMouseEnter: onMouseEnterFromContext(entry, i),
      onMouseLeave: onMouseLeaveFromContext(entry, i),
      onClick: onClickFromContext(entry, i),
      key: "trapezoid-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.name, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value)
    }), React72.createElement(FunnelTrapezoid, trapezoidProps));
  }));
}
function TrapezoidsWithAnimation(_ref3) {
  const {
    previousTrapezoidsRef,
    props
  } = _ref3;
  const {
    trapezoids,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    onAnimationEnd,
    onAnimationStart
  } = props;
  const prevTrapezoids = previousTrapezoidsRef.current;
  const [isAnimating, setIsAnimating] = (0, import_react78.useState)(false);
  const showLabels = !isAnimating;
  const animationId = useAnimationId(trapezoids, "recharts-funnel-");
  const handleAnimationEnd = (0, import_react78.useCallback)(() => {
    if (typeof onAnimationEnd === "function") {
      onAnimationEnd();
    }
    setIsAnimating(false);
  }, [onAnimationEnd]);
  const handleAnimationStart = (0, import_react78.useCallback)(() => {
    if (typeof onAnimationStart === "function") {
      onAnimationStart();
    }
    setIsAnimating(true);
  }, [onAnimationStart]);
  return React72.createElement(FunnelLabelListProvider, {
    showLabels,
    trapezoids
  }, React72.createElement(JavascriptAnimate, {
    animationId,
    begin: animationBegin,
    duration: animationDuration,
    isActive: isAnimationActive,
    easing: animationEasing,
    key: animationId,
    onAnimationStart: handleAnimationStart,
    onAnimationEnd: handleAnimationEnd
  }, (t) => {
    const stepData = t === 1 ? trapezoids : trapezoids.map((entry, index2) => {
      const prev = prevTrapezoids && prevTrapezoids[index2];
      if (prev) {
        return _objectSpread61(_objectSpread61({}, entry), {}, {
          x: interpolate(prev.x, entry.x, t),
          y: interpolate(prev.y, entry.y, t),
          upperWidth: interpolate(prev.upperWidth, entry.upperWidth, t),
          lowerWidth: interpolate(prev.lowerWidth, entry.lowerWidth, t),
          height: interpolate(prev.height, entry.height, t)
        });
      }
      return _objectSpread61(_objectSpread61({}, entry), {}, {
        x: interpolate(entry.x + entry.upperWidth / 2, entry.x, t),
        y: interpolate(entry.y + entry.height / 2, entry.y, t),
        upperWidth: interpolate(0, entry.upperWidth, t),
        lowerWidth: interpolate(0, entry.lowerWidth, t),
        height: interpolate(0, entry.height, t)
      });
    });
    if (t > 0) {
      previousTrapezoidsRef.current = stepData;
    }
    return React72.createElement(Layer, null, React72.createElement(FunnelTrapezoids, {
      trapezoids: stepData,
      allOtherFunnelProps: props
    }));
  }), React72.createElement(LabelListFromLabelProp, {
    label: props.label
  }), props.children);
}
function RenderTrapezoids(props) {
  const previousTrapezoidsRef = (0, import_react78.useRef)(void 0);
  return React72.createElement(TrapezoidsWithAnimation, {
    props,
    previousTrapezoidsRef
  });
}
const getRealWidthHeight = (customWidth, offset) => {
  const {
    width,
    height,
    left,
    right,
    top,
    bottom
  } = offset;
  const realHeight = height;
  let realWidth = width;
  if (isNumber(customWidth)) {
    realWidth = customWidth;
  } else if (typeof customWidth === "string") {
    realWidth = realWidth * parseFloat(customWidth) / 100;
  }
  return {
    realWidth: realWidth - left - right - 50,
    realHeight: realHeight - bottom - top,
    offsetX: (width - realWidth) / 2,
    offsetY: (height - realHeight) / 2
  };
};
const FunnelWithState = class extends import_react78.PureComponent {
  render() {
    const {
      className
    } = this.props;
    const layerClass = clsx("recharts-trapezoids", className);
    return React72.createElement(Layer, {
      className: layerClass
    }, React72.createElement(RenderTrapezoids, this.props));
  }
};
const defaultFunnelProps = {
  stroke: "#fff",
  fill: "#808080",
  legendType: "rect",
  hide: false,
  isAnimationActive: !Global.isSsr,
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  nameKey: "name",
  lastShapeType: "triangle"
};
function FunnelImpl(props) {
  const plotArea = usePlotArea();
  const _resolveDefaultProps = resolveDefaultProps(props, defaultFunnelProps), {
    stroke,
    fill: fill2,
    legendType,
    hide,
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    nameKey,
    lastShapeType
  } = _resolveDefaultProps, everythingElse = _objectWithoutProperties37(_resolveDefaultProps, _excluded217);
  const presentationProps = svgPropertiesNoEvents(props);
  const cells = findAllByType(props.children, Cell);
  const funnelSettings = (0, import_react78.useMemo)(() => ({
    dataKey: props.dataKey,
    nameKey,
    data: props.data,
    tooltipType: props.tooltipType,
    lastShapeType,
    reversed: props.reversed,
    customWidth: props.width,
    cells,
    presentationProps
  }), [props.dataKey, nameKey, props.data, props.tooltipType, lastShapeType, props.reversed, props.width, cells, presentationProps]);
  const trapezoids = useAppSelector((state) => selectFunnelTrapezoids(state, funnelSettings));
  if (hide || !trapezoids || !trapezoids.length || !plotArea) {
    return null;
  }
  const {
    height,
    width
  } = plotArea;
  return React72.createElement(React72.Fragment, null, React72.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings11,
    args: _objectSpread61(_objectSpread61({}, props), {}, {
      trapezoids
    })
  }), React72.createElement(FunnelWithState, _extends47({}, everythingElse, {
    stroke,
    fill: fill2,
    nameKey,
    lastShapeType,
    animationBegin,
    animationDuration,
    animationEasing,
    isAnimationActive,
    hide,
    legendType,
    height,
    width,
    trapezoids
  })));
}
function computeFunnelTrapezoids(_ref4) {
  const {
    dataKey,
    nameKey,
    displayedData,
    tooltipType,
    lastShapeType,
    reversed,
    offset,
    customWidth
  } = _ref4;
  const {
    left,
    top
  } = offset;
  const {
    realHeight,
    realWidth,
    offsetX,
    offsetY
  } = getRealWidthHeight(customWidth, offset);
  const maxValue = Math.max.apply(null, displayedData.map((entry) => getValueByDataKey(entry, dataKey, 0)));
  const len = displayedData.length;
  const rowHeight = realHeight / len;
  const parentViewBox = {
    x: offset.left,
    y: offset.top,
    width: offset.width,
    height: offset.height
  };
  let trapezoids = displayedData.map((entry, i) => {
    const rawVal = getValueByDataKey(entry, dataKey, 0);
    const name = getValueByDataKey(entry, nameKey, i);
    let val = rawVal;
    let nextVal;
    if (i !== len - 1) {
      nextVal = getValueByDataKey(displayedData[i + 1], dataKey, 0);
      if (nextVal instanceof Array) {
        [nextVal] = nextVal;
      }
    } else if (rawVal instanceof Array && rawVal.length === 2) {
      [val, nextVal] = rawVal;
    } else if (lastShapeType === "rectangle") {
      nextVal = val;
    } else {
      nextVal = 0;
    }
    const x2 = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX;
    const y2 = rowHeight * i + left + offsetY;
    const upperWidth = val / maxValue * realWidth;
    const lowerWidth = nextVal / maxValue * realWidth;
    const tooltipPayload = [{
      name,
      value: val,
      payload: entry,
      dataKey,
      type: tooltipType
    }];
    const tooltipPosition = {
      x: x2 + upperWidth / 2,
      y: y2 + rowHeight / 2
    };
    return _objectSpread61(_objectSpread61({
      x: x2,
      y: y2,
      width: Math.max(upperWidth, lowerWidth),
      upperWidth,
      lowerWidth,
      height: rowHeight,
      // @ts-expect-error getValueByDataKey does not validate the output type
      name,
      val,
      tooltipPayload,
      tooltipPosition
    }, (0, import_omit3.default)(entry, ["width"])), {}, {
      payload: entry,
      parentViewBox,
      labelViewBox: {
        x: x2 + (upperWidth - lowerWidth) / 4,
        y: y2,
        width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),
        height: rowHeight
      }
    });
  });
  if (reversed) {
    trapezoids = trapezoids.map((entry, index2) => {
      const newY = entry.y - index2 * rowHeight + (len - 1 - index2) * rowHeight;
      return _objectSpread61(_objectSpread61({}, entry), {}, {
        upperWidth: entry.lowerWidth,
        lowerWidth: entry.upperWidth,
        x: entry.x - (entry.lowerWidth - entry.upperWidth) / 2,
        y: entry.y - index2 * rowHeight + (len - 1 - index2) * rowHeight,
        tooltipPosition: _objectSpread61(_objectSpread61({}, entry.tooltipPosition), {}, {
          y: newY + rowHeight / 2
        }),
        labelViewBox: _objectSpread61(_objectSpread61({}, entry.labelViewBox), {}, {
          y: newY
        })
      });
    });
  }
  return trapezoids;
}
const Funnel = class extends import_react78.PureComponent {
  render() {
    return React72.createElement(FunnelImpl, this.props);
  }
};
_defineProperty63(Funnel, "displayName", "Funnel");
_defineProperty63(Funnel, "defaultProps", defaultFunnelProps);

// node_modules/recharts/es6/chart/FunnelChart.js
const React73 = __toESM(require_react());
const import_react79 = __toESM(require_react());
const allowedTooltipTypes9 = ["item"];
const FunnelChart = (0, import_react79.forwardRef)((props, ref) => {
  return React73.createElement(CartesianChart, {
    chartName: "FunnelChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: allowedTooltipTypes9,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref
  });
});
export {
  Area,
  AreaChart,
  Bar,
  BarChart,
  Brush,
  CartesianAxis,
  CartesianGrid,
  Cell,
  ComposedChart,
  Cross,
  Curve,
  Customized,
  DefaultLegendContent,
  DefaultTooltipContent,
  Dot,
  ErrorBar,
  Funnel,
  FunnelChart,
  Global,
  Label,
  LabelList,
  Layer,
  Legend,
  Line,
  LineChart,
  Pie,
  PieChart,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Polygon,
  Radar,
  RadarChart,
  RadialBar,
  RadialBarChart,
  Rectangle,
  ReferenceArea,
  ReferenceDot,
  ReferenceLine,
  ResponsiveContainer,
  Sankey,
  Scatter,
  ScatterChart,
  Sector,
  SunburstChart,
  Surface,
  Symbols,
  Text,
  Tooltip,
  Trapezoid,
  Treemap,
  XAxis,
  YAxis,
  ZAxis,
  getNiceTickValues,
  useActiveTooltipDataPoints,
  useActiveTooltipLabel,
  useChartHeight,
  useChartWidth,
  useMargin,
  useOffset,
  usePlotArea,
  useXAxisDomain,
  useYAxisDomain
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=recharts.js.map
